<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris的个人博客</title>
  
  <subtitle>我的代码要为成艺术品</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-08-12T09:37:26.059Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Multi-level Graph Convolutional Networks for Cross-platform</title>
    <link href="http://yoursite.com/2022/08/12/Multi-level-Graph-Convolutional-Networks-for-Cross-platform-1/"/>
    <id>http://yoursite.com/2022/08/12/Multi-level-Graph-Convolutional-Networks-for-Cross-platform-1/</id>
    <published>2022-08-12T14:23:32.000Z</published>
    <updated>2022-08-12T09:37:26.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用于跨平台锚定节点对齐的多层次图卷积神经网络">用于跨平台锚定节点对齐的多层次图卷积神经网络</h1><p>我们提出了一种新的框架，即统一考虑局部网络结构和超图结构上的多层图卷积。我们提出了一种双相空间协调机制，在基于网络划分的并行训练和不同社交网络的账户匹配中调整嵌入空间，以便其能适用于大规模社交网络。</p><p>与简单图相比，超图允许一条边（也就是同端边）同时连接两个以上的节点。这意味着图中节点之间的非成对关系可以很容易地组织起来并表示为超边。此外，超图是鲁棒的、灵活的，可以适应各种各样的社会网络，无论给定的网络是纯社会网络或具有各种类型的异质社会网络属性和链接。</p><p>提出了一个多层图卷积网络MGCN，联合学习在不同粒度w.r.t.级别上的网络顶点的嵌入灵活的GCN内核(即，简单的图GCN，超图GCN)。社交网络的简单图结构信息反映了用户之间的关系，超图就是反映了不同网络的语义信息。例如，基于N跳邻居的超图(用户的n跳邻居通过同一超边缘连接)在某种程度上代表了朋友圈。基于中心性的超图表示不同的社会水平（具有相似中心性价值观的用户可能具有相同的社会地位）。因此，通过定义各种超图并将其交互到网络嵌入学习中，将促进选择更好的用户表示。为了支持这一点，我们提出的MGCN框架是灵活的，并且可以合并各种超图定义，它可以将任何超图作为向量表示 ，使模型结构对各种超图定义不变。</p><p>通过扩展GCN来开发和整合超图背后的基本原理是，超图提供了一个更灵活的网络表示，可以包含额外的和更丰富的信息组合，针对局部网络拓扑上的单个图gcn。一般的GCN只有两层，所以只能获取一个结点的局部特性。</p><p>作者这里提出了一种新的训练方式，首先将大规模的社交网络划分为集群，并以完全分散的方式学习网络嵌入。为了对齐学习到的不同簇的嵌入空间，我们提出了一种新的两相空间和解机制。在第一阶段，我们对齐从同一网络中的每个簇中学习到的嵌入空间。除了同一网络中不同子网络之间的对齐外，第二阶段空间和解还通过少量的观测锚定节点对两个不同的网络进行对齐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用于跨平台锚定节点对齐的多层次图卷积神经网络&quot;&gt;用于跨平台锚定节点对齐的多层次图卷积神经网络&lt;/h1&gt;
&lt;p&gt;我们提出了一种新的框架，即统一考虑局部网络结构和超图结构上的多层图卷积。我们提出了一种双相空间协调机制，在基于网络划分的并行训练和不同社交网络的账户匹配
      
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机理论</title>
    <link href="http://yoursite.com/2022/07/28/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2022/07/28/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/</id>
    <published>2022-07-28T13:34:44.000Z</published>
    <updated>2022-08-01T05:08:23.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础">1. 基础</h1><p>集合A的n次幂(<span class="math inline">\(n≥0\)</span>)递归地定义为： <span class="math display">\[\begin{equation}A^n=\begin{cases}\left\{\varepsilon\right\}&amp; \text{ $ n=0 $ } \\A^{n-1}A&amp; \text{ $ n≥1 $ }\end{cases}\end{equation}\]</span> <img src="../images/集合的幂.png"></p><ul><li>克林闭包：<span class="math inline">\(\Sigma^*=U_{i=0}^{∞} \Sigma^i\)</span></li><li>正闭包：<span class="math inline">\(\Sigma^+=U_{i=1}^{∞} \Sigma^i\)</span></li><li><span class="math inline">\(\Sigma^*=\Sigma^+ \or \left\{\varepsilon\right\}\)</span></li></ul><h1 id="有限状态机">2. 有限状态机</h1><p>确定的有穷状态机的模型如下：</p><p><img src="../images/确定的有穷自动机.png"></p><p>确定的有穷自动机(DFA)定义为：A的五元组：<span class="math inline">\(A=(Q,\Sigma,\delta,q_0,F)\)</span>。</p><ul><li>Q：有穷状态集</li><li><span class="math inline">\(\Sigma\)</span>：有穷输入符号集或字母表</li><li><span class="math inline">\(\delta\)</span>：<span class="math inline">\(Q\times \Sigma \to Q\)</span>，状态转移函数</li><li><span class="math inline">\(q_0 \in Q\)</span>：初始状态</li><li><span class="math inline">\(F \subseteq Q\)</span>：终结状态集或接收状态集</li></ul><p>状态转移图如下：</p><p><img src="../images/状态转移图.png"></p><h2 id="扩展转移函数">扩展转移函数</h2><p>扩展<span class="math inline">\(\delta\)</span>到字符串，定义扩展转移函数<span class="math inline">\(\hat \delta:Q \times \Sigma^* \to Q\)</span>为： <span class="math display">\[\begin{equation}\hat \delta(q,w)=\begin{cases}q&amp; \text{ $ w=\varepsilon $ } \\\delta(\hat \delta(q,x),a)&amp; \text{ $ w=xa $ }\end{cases}\end{equation}\]</span> 其中<span class="math inline">\(a \in \Sigma, w,x \in \Sigma^*\)</span>，那么当<span class="math inline">\(w=a_0a_1...a_n\)</span>，则有<span class="math inline">\(\hat \delta(q,w)=\delta(\hat \delta(q,a_0a_1...a_{n-1}),a_n)...\)</span>就这样一直嵌套递归下去。</p><h3 id="dfa的语言与正则语言">DFA的语言与正则语言</h3><p>定义：若<span class="math inline">\(D=(Q,\Sigma,\delta,q_0,F)\)</span>是一个DFA,则D接受的语言为：<span class="math inline">\(L(D)=\left\{w \in \Sigma^*| \hat \delta(q_0,w) \in F\right\}\)</span></p><p>定义：如果语言L是某个DFA D的语言，即<span class="math inline">\(L=L(D)\)</span>，则称L是正则语言。</p><h2 id="非确定有穷自动机">非确定有穷自动机</h2><p><img src="../images/非确定的有穷自动机.png"></p><p>非确定有穷自动机（NFA）的形式定义：</p><p><span class="math inline">\(A=(Q,\Sigma,\delta,q_0,F)\)</span></p><ul><li>Q：有穷状态集</li><li><span class="math inline">\(\Sigma\)</span>：有穷输入符号集或字母表</li><li><span class="math inline">\(\delta:Q\times \Sigma \to 2^Q\)</span>状态转移函数</li><li><span class="math inline">\(q_0 \in Q\)</span>：为初始状态</li><li><span class="math inline">\(F \subseteq Q\)</span>：为终结状态集或接受状态集</li></ul><h2 id="dfa和nfa的等价性">DFA和NFA的等价性</h2><ul><li><p>定理1：如果L被NFA接受，当且仅当L被DFA接受。</p><p>非确定性并没有增加有穷自动机的能力。</p></li></ul><h2 id="带有空转移的非确定有穷自动机">带有空转移的非确定有穷自动机</h2><p>空转移指的是不消耗字符串就能够进行转移的，空串<span class="math inline">\(\varepsilon\)</span>。</p><p>定义为如下：</p><p><img src="../images/带有空转移非确定有穷自动机的形式定义.png"></p><p><span class="math inline">\(\varepsilon-NFA,NFA,DFA\)</span>之间的主要区别：</p><ul><li>NFA,<span class="math inline">\(\varepsilon-NFA\)</span>自动机在某状态读入某个字符时，可能有多个转移。</li><li><span class="math inline">\(\varepsilon-NFA,NFA,DFA\)</span>在读入某个字符时，可能没有状态转移</li><li><span class="math inline">\(\varepsilon-NFA\)</span>自动机在某状态，可能不读入字符就进行转移</li></ul><h3 id="状态的varepsilon-闭包">状态的<span class="math inline">\(\varepsilon-\)</span>闭包</h3><p>状态q的<span class="math inline">\(\varepsilon-\)</span>闭包记为<span class="math inline">\(E_{CLOSE}(q)\)</span>，表示从q经过<span class="math inline">\(\varepsilon \varepsilon ... \varepsilon\)</span>序列可达的全部状态集合，递归定义为：</p><ul><li><span class="math inline">\(q \in E_{CLOSE}(q)\)</span></li><li><span class="math inline">\(\forall p \in E_{CLOSE}(q)\)</span>，若<span class="math inline">\(r \in \delta(p, \varepsilon)\)</span>，则<span class="math inline">\(r \in E_{CLOSE}(q)\)</span></li></ul><h1 id="正则表达式">3. 正则表达式</h1><p>正则表达式的递归定义：</p><p>如果<span class="math inline">\(\Sigma\)</span>为字母表，则<span class="math inline">\(\Sigma\)</span>上的正则表达式递归定义为：</p><ul><li><span class="math inline">\(\varPhi\)</span>是一个正则表达式，表示空语言</li><li><span class="math inline">\(\varepsilon\)</span>是一个正则表达式，表示语言<span class="math inline">\(\left\{\varepsilon\right\}\)</span></li><li><span class="math inline">\(\forall a \in \Sigma\)</span>，a是一个正则表达式，表示语言<span class="math inline">\(\left\{a\right\}\)</span></li><li>如果正则表达式<span class="math inline">\(r\)</span>和<span class="math inline">\(s\)</span>分别表示语言R和S，那么<span class="math inline">\(r+s,rs,r^*,(r)\)</span>都是正则表达式，分别表示语言：<span class="math inline">\(R \or S, R \cdot S,R^*,R\)</span></li></ul><p>正则表达式的优先级：</p><ul><li>首先括号优先级最高</li><li>其次<span class="math inline">\(r^*\)</span></li><li>然后是连接运算<span class="math inline">\(rs, r \cdot s\)</span></li><li>最后加最低<span class="math inline">\(r+s,r \or s\)</span></li></ul><p>正则表达式示例：</p><p><img src="../images/正则表达式示例.png"></p><ul><li>定理：若<span class="math inline">\(L=L(A)\)</span>是某DFA A的语言，那么存在正则表达式R满足<span class="math inline">\(L=L(R)\)</span></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;1. 基础&lt;/h1&gt;
&lt;p&gt;集合A的n次幂(&lt;span class=&quot;math inline&quot;&gt;\(n≥0\)&lt;/span&gt;)递归地定义为： &lt;span class=&quot;math display&quot;&gt;\[
\begin{equation}
A^n=
\
      
    
    </summary>
    
    
    
      <category term="网课学习" scheme="http://yoursite.com/tags/%E7%BD%91%E8%AF%BE%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Multi-level Graph Convolutional Networks for Cross-platform</title>
    <link href="http://yoursite.com/2022/06/27/Multi-level-Graph-Convolutional-Networks-for-Cross-platform/"/>
    <id>http://yoursite.com/2022/06/27/Multi-level-Graph-Convolutional-Networks-for-Cross-platform/</id>
    <published>2022-06-27T11:10:59.000Z</published>
    <updated>2022-06-27T08:56:59.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨平台锚定链路预测的多层次图卷积网络">跨平台锚定链路预测的多层次图卷积网络</h1><p>现有的方法要么严重依赖于高质量的用户已生成的内容（包含用户的配置文件），或者如果只关注网络拓扑，就会出现数据不足问题，使研究人员陷入不可解决的模型选择困境。为了解决这一问题，我们提出了一个新的框架，即统一考虑局部网络结构和超图结构上的多层次图卷积。该方法克服了现有工作中的数据不足问题，不一定依赖于用户人口统计信息。此外，为了使所提出的方法能够处理大规模的社交网络，我们提出了一种双相空间和解机制来对齐两个网络分区中的嵌入空间 基于不同社交网络的并行训练和账户匹配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跨平台锚定链路预测的多层次图卷积网络&quot;&gt;跨平台锚定链路预测的多层次图卷积网络&lt;/h1&gt;
&lt;p&gt;现有的方法要么严重依赖于高质量的用户已生成的内容（包含用户的配置文件），或者如果只关注网络拓扑，就会出现数据不足问题，使研究人员陷入不可解决的模型选择困境。为了解决这一
      
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>多元信用评估系统</title>
    <link href="http://yoursite.com/2022/06/20/%E5%A4%9A%E5%85%83%E4%BF%A1%E7%94%A8%E8%AF%84%E4%BC%B0%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2022/06/20/%E5%A4%9A%E5%85%83%E4%BF%A1%E7%94%A8%E8%AF%84%E4%BC%B0%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-20T15:46:12.000Z</published>
    <updated>2022-06-22T14:19:00.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共享模式发现">1. 共享模式发现</h1><p>训练时，首先针对每个社交媒体网络，根据用户社会多媒体行为建立每个用户的行为特征表示。然后利用大量的无人口统计属性标注的用户行为数据，通过多源自编码器来无监督的学习用户稳定的特征表示。在得到了用户稳定的特征表示后，将已知人口统计属性作为监督，利用常用的支持向量机等分类器进行用户人口统计属性推断模型的训练。</p><p>预测时，给定在不同社交媒体网络上的网络行为，先提取用户行为特征，然后根据多源自编码器获得用户的稳定特征表示后，利用训练得到的模型推断出用户的人口统计属性。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/20/%E5%A4%9A%E5%85%83%E4%BF%A1%E7%94%A8%E8%AF%84%E4%BC%B0%E7%B3%BB%E7%BB%9F/blog\source\_posts\多元信用评估系统\共享模式发现.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">共享模式发现</div></center><p>当然我们这里没有三个网络，我们可以将微博转发和微博原创当做两个网络。</p><p>两个社交媒体网络上的稳定特征：</p><ul><li><p>两个社交媒体网络上的行为特征<span class="math inline">\(f^t,f^t\)</span>通过互相重构的方式，将同一用户的两个社交媒体网络上的行为特征，映射到用户的人口属性空间，在最小化重构误差过程中，获得的隐特征<span class="math inline">\(h^{tg}\)</span>和<span class="math inline">\(h^{gt}\)</span>即为用户人口属性空间的特征表示。</p><p><span class="math inline">\(h^{gt}=encoder^t(f^t):=\zeta(W_e^tf^t+b_e^t)\)</span>：将<span class="math inline">\(f^t\)</span>编码</p><p><span class="math inline">\(\widetilde f^{gt}=decoder^g(h^{gt}):=W^g_dh^{gt}+b_d^g\)</span>：</p><p><span class="math inline">\(h^{tg}=encoder^g(f^g):=\zeta(W_e^gf^g+b_e^g)\)</span></p><p><span class="math inline">\(\widetilde f^{tg} = decoder^t(h^{tg}):=W_d^{t}h^{tg}+b_d^t\)</span></p><p><span class="math inline">\(\Phi_t=\sum_{u\in U}||f^t-\widetilde f^{tg}||^2_2\)</span></p><p><span class="math inline">\(\Phi_g=\sum_{u\in U}||f^g-\widetilde f^{gt}||^2_2\)</span></p></li><li></li></ul><h1 id="基于多源信用数据信用评估">2. 基于多源信用数据信用评估</h1><p>基本的思路就是：首先基于多源数据关联和共享模式发现方法获得同一个自然人的由多源行为数据到稳定用户属性之间的映射，然后基于用户属性预测信用等级情况。</p><p>在集成学习框架的第一层，首先分别从微博和网易云音乐两个中文社交媒体网络上的动态信息中提取用户的行为特征。然后根据层次自编码器，寻找行为特征之间的共享模式。</p><p>最后，分别使用SVM，决策树和逻辑回归，根据一致和稳定的用户特征表示得到用户属于各个信用等级的概率大小，将其作为第一层提取出的高层次特征和第二层的输入特征。</p><p>在集成学习框架的第二层，将第一层得到的高层次特征和用户在微博上除了动态信息外的12种信息串联起来，使用GDBT作为分类器，对用户信用进行评估。第二层输入特征只有17维，既有连续值，又有离散值。使用的是GDBT算法进行分类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;共享模式发现&quot;&gt;1. 共享模式发现&lt;/h1&gt;
&lt;p&gt;训练时，首先针对每个社交媒体网络，根据用户社会多媒体行为建立每个用户的行为特征表示。然后利用大量的无人口统计属性标注的用户行为数据，通过多源自编码器来无监督的学习用户稳定的特征表示。在得到了用户稳定的特征表示后
      
    
    </summary>
    
    
    
      <category term="项目工作" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>研究工作笔记</title>
    <link href="http://yoursite.com/2022/06/20/%E7%A0%94%E7%A9%B6%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/06/20/%E7%A0%94%E7%A9%B6%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-19T16:45:46.000Z</published>
    <updated>2022-07-26T14:57:21.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="embedding部分">1. embedding部分</h1><h2 id="splitter的embedding">1.1 splitter的embedding</h2><p>首先这个embedding用到了一个非重叠的聚类算法，说白了就是划分子图，并将子图构成一幅新图。在EgoNetSplitter()类中进行了相关的一系列操作。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/20/%E7%A0%94%E7%A9%B6%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/blog\source\_posts\研究工作笔记\测试所用图.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">测试所用图</div></center><p>按照代码中的思路，这个流程可以分为以下几步：</p><p>（1）首先对每个节点，划分其ego-net。</p><p><strong>ego-net也就是自我中心网络，网络结点由唯一的中心节点ego，以及这个节点的邻居alters组成，边只包括ego与alter之间以及alter与alter之间的边。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.components = &#123;&#125;</span><br><span class="line">self.personalities = &#123;&#125;</span><br><span class="line">self.index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> tqdm(self.graph.nodes()):</span><br><span class="line">    self._create_egonet(node)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ego_net_minus_ego = self.graph.subgraph(self.graph.neighbors(node))<span class="comment">#得到一阶邻居子图,构成了一幅图,不包含节点本身，邻居原先有边相连的保留</span></span><br><span class="line"><span class="comment"># 针对当下节点的ego-net的连通节点以idx:nodes_idx的形式存储，idx没有明显的跟节点相关的意义，这个只是局部变量</span></span><br><span class="line">components = &#123;i: n <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nx.connected_components(ego_net_minus_ego))&#125;</span><br><span class="line"><span class="comment"># 对于components，如果是上图中的2节点就是&#123;0: &#123;1, 6, 7&#125;, 1: &#123;3&#125;&#125;</span></span><br><span class="line">new_mapping = &#123;&#125;</span><br><span class="line">personalities = []</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> components.items():<span class="comment">#遍历ego-net中的alters</span></span><br><span class="line">    personalities.append(self.index)<span class="comment">#添加全局变量index，也就是表示personas的index</span></span><br><span class="line">    <span class="keyword">for</span> other_node <span class="keyword">in</span> v:<span class="comment">#遍历连通的结点，一个连通的alters就是一个persona标号</span></span><br><span class="line">        new_mapping[other_node] = self.index<span class="comment">#将当前的结点映射到persona</span></span><br><span class="line">        self.index = self.index+<span class="number">1</span><span class="comment">#这个index是对于全局都会相加的</span></span><br><span class="line">        self.components[node] = new_mapping<span class="comment">#对于当前节点，node_idx -&gt; idx的映射，是ego_net中的，对应于personalities中的映射,idx表示personas的序号，也就是原始图中的结点映射到new_mapping中，new_mapping装的是当前原始结点的一阶邻居结点到personas的映射</span></span><br><span class="line">        self.personalities[node] = personalities<span class="comment">#当前节点的personalities就是index，对于全局而言的，所以这个意思就是，我有多少个连通着的邻居，我就有多少个personalities</span></span><br></pre></td></tr></table></figure><p>经过上述的操作之后，self.components的结构就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: &#123;<span class="number">1</span>: <span class="number">0</span>&#125;, <span class="number">1</span>: &#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">6</span>: <span class="number">2</span>&#125;, <span class="number">2</span>: &#123;<span class="number">1</span>: <span class="number">3</span>, <span class="number">6</span>: <span class="number">3</span>, <span class="number">7</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>&#125;, <span class="number">3</span>: &#123;<span class="number">9</span>: <span class="number">5</span>, <span class="number">2</span>: <span class="number">6</span>&#125;, <span class="number">10</span>: &#123;<span class="number">9</span>: <span class="number">7</span>, <span class="number">11</span>: <span class="number">8</span>&#125;, <span class="number">11</span>: &#123;<span class="number">10</span>: <span class="number">9</span>, <span class="number">12</span>: <span class="number">10</span>&#125;, <span class="number">12</span>: &#123;<span class="number">11</span>: <span class="number">11</span>, <span class="number">7</span>: <span class="number">12</span>&#125;, <span class="number">6</span>: &#123;<span class="number">1</span>: <span class="number">13</span>, <span class="number">2</span>: <span class="number">13</span>, <span class="number">7</span>: <span class="number">13</span>&#125;, <span class="number">7</span>: &#123;<span class="number">2</span>: <span class="number">14</span>, <span class="number">6</span>: <span class="number">14</span>, <span class="number">12</span>: <span class="number">15</span>&#125;, <span class="number">8</span>: &#123;<span class="number">9</span>: <span class="number">16</span>&#125;, <span class="number">9</span>: &#123;<span class="number">8</span>: <span class="number">17</span>, <span class="number">10</span>: <span class="number">18</span>, <span class="number">3</span>: <span class="number">19</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>怎么解释这个数据结构呢？就是<strong>{原始图中的结点：{原始图中结点的一阶邻居：persona结点}}</strong>，比方说1结点有0,2,6三个邻居，其中0属于persona1，而2和6都属于persona2。</p><p>而self.personalities是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: [<span class="number">0</span>], <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>: [<span class="number">5</span>, <span class="number">6</span>], <span class="number">10</span>: [<span class="number">7</span>, <span class="number">8</span>], <span class="number">11</span>: [<span class="number">9</span>, <span class="number">10</span>], <span class="number">12</span>: [<span class="number">11</span>, <span class="number">12</span>], <span class="number">6</span>: [<span class="number">13</span>], <span class="number">7</span>: [<span class="number">14</span>, <span class="number">15</span>], <span class="number">8</span>: [<span class="number">16</span>], <span class="number">9</span>: [<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]&#125;</span><br></pre></td></tr></table></figure><p>这个数据结构为每个节点存储了一个列表，表示当前原始图中的结点被分为哪几个personas。</p><p>（2）接下来将personalities映射为新的结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_map_personalities</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Mapping the personas to new nodes.</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">    self.personality_map = &#123;p: n <span class="keyword">for</span> n <span class="keyword">in</span> self.graph.nodes() <span class="keyword">for</span> p <span class="keyword">in</span>          self.personalities[n]&#125;</span><br></pre></td></tr></table></figure><p>最后得到的self.personality_map为：其实也就是persona_node-&gt;原始结点的映射。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">3</span>, <span class="number">6</span>: <span class="number">3</span>, <span class="number">7</span>: <span class="number">10</span>, <span class="number">8</span>: <span class="number">10</span>, <span class="number">9</span>: <span class="number">11</span>, <span class="number">10</span>: <span class="number">11</span>, <span class="number">11</span>: <span class="number">12</span>, <span class="number">12</span>: <span class="number">12</span>, <span class="number">13</span>: <span class="number">6</span>, <span class="number">14</span>: <span class="number">7</span>, <span class="number">15</span>: <span class="number">7</span>, <span class="number">16</span>: <span class="number">8</span>, <span class="number">17</span>: <span class="number">9</span>, <span class="number">18</span>: <span class="number">9</span>, <span class="number">19</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>（3）然后我们得在新得到的personas之间添加边</p><p>根据论文中所讲的，如果<span class="math inline">\((u,v) \in E,v \in N_u^i \and u \in N_v^j\)</span>那么就添加一条边<span class="math inline">\((u_j,v_i)\)</span>到<span class="math inline">\(E&#39;\)</span>中。什么意思呢？就是说如果在原始图中u和v是有边的，那么显然他们互为一阶邻居，如果v是在u的邻居的第i个连通分量中，而u是在v的第j个连通分量中，那么就在新的persona中的i，j对应的顶点添加连边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_persona_graph</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a persona graph using the egonet components.</span></span><br><span class="line"><span class="string">    这个对应论文中的第四步：在persona graph中使用全局的聚类算法得到一个分类S''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"Creating the persona graph."</span>)</span><br><span class="line">    self.persona_graph_edges = [self._get_new_edge_ids(e) <span class="keyword">for</span> e <span class="keyword">in</span> tqdm(self.graph.edges())]</span><br><span class="line">    self.persona_graph = nx.from_edgelist(self.persona_graph_edges)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_new_edge_ids</span><span class="params">(self, edge)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Getting the new edge identifiers.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        edge: Edge being mapped to the new identifiers.</span></span><br><span class="line"><span class="string">    往新的图中添加边，所谓的新的图就是有多少个personas就有多少个结点</span></span><br><span class="line"><span class="string">    self.components针对&#123;node_idx:&#123;当下节点的ego-net的连通节点以idx:nodes_idx的形式存储&#125;&#125;</span></span><br><span class="line"><span class="string">    测试中为&#123;0: &#123;1: 0&#125;, 1: &#123;0: 1, 2: 2, 6: 2&#125;, 2: &#123;1: 3, 6: 3, 7: 3, 3: 4&#125;, 3: &#123;9: 5, 2: 6&#125;, 10: &#123;9: 7, 11: 8&#125;,</span></span><br><span class="line"><span class="string">    11: &#123;10: 9, 12: 10&#125;, 12: &#123;11: 11, 7: 12&#125;, 6: &#123;1: 13, 2: 13, 7: 13&#125;, 7: &#123;2: 14, 6: 14, 12: 15&#125;,</span></span><br><span class="line"><span class="string">    8: &#123;9: 16&#125;, 9: &#123;8: 17, 10: 18, 3: 19&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    原始图中的边为：[(0, 1), (1, 2), (1, 6), (2, 3), (2, 7), (2, 6), (3, 9), (10, 11),</span></span><br><span class="line"><span class="string">    (10, 9), (11, 12), (12, 7), (6, 7), (8, 9)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    测试的输出的边为：[(0, 1), (2, 3), (2, 13), (4, 6), (3, 14), (3, 13), (5, 19),</span></span><br><span class="line"><span class="string">    (8, 9), (7, 18), (10, 11), (12, 15), (13, 14), (16, 17)]</span></span><br><span class="line"><span class="string">    函数输入的是原始图中的边，输出的是应该添加到新的图中的边</span></span><br><span class="line"><span class="string">    那么如何添加呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    输入边(1,2)，函数返回的是(self.components[1][2], self.components[2][1])</span></span><br><span class="line"><span class="string">    也就是(2, 3)</span></span><br><span class="line"><span class="string">    为啥要这样？</span></span><br><span class="line"><span class="string">    self.components[1][2]定位的是1结点的2这个一阶邻居结点在新图中对应的persona</span></span><br><span class="line"><span class="string">    self.components[2][1]定位的是2结点的1这个一阶邻居节点在新图中对应的persona</span></span><br><span class="line"><span class="string">    因为在原始图中这两个分出来的persona是相连接的，所以我们必须给他连一条边</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这里必须有的概念是：</span></span><br><span class="line"><span class="string">    同一个节点在不同的节点的一阶邻居中的persona是不一样的，因为persona都是在自增的，如果说有边的话</span></span><br><span class="line"><span class="string">    这样做的目的就是为了把节点从拓扑上分割开来，让节点充当有不同的角色，注意这个是单纯考虑拓扑结构的。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> (self.components[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]], self.components[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]])</span><br></pre></td></tr></table></figure><p>首先进行的是构建新的连边函数_get_new_edge_ids()，输入边(1,2)，函数返回的是<span class="math inline">\((self.components[1][2], self.components[2][1])\)</span>，也就是(2, 3)，为啥要这样？ <span class="math inline">\(self.components[1][2]\)</span>定位的是1结点的2这个一阶邻居结点在新图中对应的persona <span class="math inline">\(self.components[2][1]\)</span>定位的是2结点的1这个一阶邻居节点在新图中对应的persona 因为在原始图中这两个节点是相连接的，那么分出来的persona也应该是相连接的，所以在新构建的图中我们必须给他连一条边。 最后根据这些连边的关系，构建出一幅新的图，注意：<strong>新图可能是并不全连通的，而且新图中的边的数量等于原图中的边的数量。</strong></p><p>在得到新图之后，断开的组件可能给图表示学习造成很多困扰，所以提出两点来解决这个问题。</p><ul><li><p>首先，我们建议添加一个约束条件，即角色表示除了能够预测GP中它周围的角色外，还能够预测它们的原始节点。给定一个persona <span class="math inline">\(v_i\)</span>，我们提出求出其embedding包括对原始图G中的节点vo的依赖性：</p><p><span class="math inline">\(Pr(v_0| \Phi_{G_P(v_i)})\)</span></p><p>为了控制图正则化的强度，我们引入了参数λ,结合了deepwalk的优化方程就会产生以下的优化问题：</p><p><span class="math inline">\(minimize_{\Phi_{G_P}} -logPr({v_{i-w},...,v_{i+w}/ v_i}| \Phi_{G_P}(v_i)- \lambda logPr(v_0| \Phi_{G_P}(v_i)))\)</span></p><p>说白了这个就是用原来的图去监督现在的persona的图表示学习，不要让它偏离的过分。</p></li><li><p>其次，还使用原始的结点表示<span class="math inline">\(\Phi_G(v)\)</span>初始化结点v的persona图的结点表示，将这个作为先验。</p></li></ul><p><strong>这个地方还得研究的是：1. 首先优化函数loss要如何能酷炫点？魔改一下，为了让其适用于网络对齐任务。2. 试试看别的模型，比方说deepwalk，node2vec还有GCN对整体的影响。3. 是否可以加上用户的属性信息作为监督，怎么加呢？直接concat？还是弄个神经网络计算loss。4. 如何让网络对齐任务和embedding部分融合的更好。</strong></p><h1 id="对齐部分">2. 对齐部分</h1><p>上面我们所做的是得到了一个图，将原本可能全连通的图变成了一个非全连通的图。</p><h2 id="wasserstein距离的应用">2.1 wasserstein距离的应用</h2><p>paper：</p><p>这个论文解决的问题是：未能达到匹配的邻居一致性：在一个图中接近的节点通常与在另一个图中接近的节点不匹配。出于这个考虑，作者使用的是proximity-preserving node embedding methods。</p><p>在这里作者解决了两个问题，分别如下：</p><ul><li><p>procrustes问题：<span class="math inline">\(min_{Q \in O^d}||Y_1Q-Y_2||^2_2\)</span>，这个问题就是正交普鲁克问题，可以直接给出最优解的。</p><p>这个问题的求解等价于求<span class="math inline">\(Q^*=UV^T\)</span>，其中<span class="math inline">\(U \Sigma V^T\)</span>是<span class="math inline">\(XY^T\)</span>的SVD分解，Q是正交的矩阵。</p></li><li><p>wasserstein问题：<span class="math inline">\(min_{P \in P^n}||Y_1-PY_2||\)</span></p></li></ul><p>首先这个论文要解决的就是一个凸初始化的问题，<span class="math inline">\(min_{P \in B^n}||(A_1P-PA_2)||_2^2\)</span>，其中的<span class="math inline">\(B^n\)</span>是<span class="math inline">\(P^n\)</span>的凸包，可以使用frank-wolfe算法得到<span class="math inline">\(P^*\)</span>，这个可以通过<span class="math inline">\(n_0\)</span>次的迭代以及正则化参数<span class="math inline">\(\lambda_0\)</span>来实现，使用<span class="math inline">\(Y_1\)</span>和<span class="math inline">\(P^*Y_2\)</span>，初始化的<span class="math inline">\(Q\)</span>可以被正交的procrustes方法来生成。</p><p>首先介绍sinkhorn算法，细节不去深究，直接上代码，这个就是为了求解optimal transport问题的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ot.bregman.sinkhorn(a, b, M, reg, method=<span class="string">'sinkhorn'</span>, numItermax=<span class="number">1000</span>, stopThr=<span class="number">1e-09</span>, verbose=<span class="literal">False</span>, log=<span class="literal">False</span>, warn=<span class="literal">True</span>, **kwargs)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a: shape(dim_a)对源网络的权重的采样</span></span><br><span class="line"><span class="string">b: shape(dim_b)对目标网络的权重的采样</span></span><br><span class="line"><span class="string">M: 代价函数</span></span><br><span class="line"><span class="string">reg: 正则化项, &gt;0</span></span><br><span class="line"><span class="string">stopThr: 迭代终止的loss</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return: </span></span><br><span class="line"><span class="string">gamma(shape(dim_a, dim_b)): 最优传输矩阵</span></span><br><span class="line"><span class="string">log: 仅当参数中的log==True时，日志字典才会返回</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解决的是熵正则化的最优传输问题，并且返回最优传输矩阵。最优化的问题如下：</p><p><span class="math inline">\(\gamma^* = arg\ min_y \ &lt;\gamma, M&gt;_F+reg * \Omega( \gamma)\)</span></p><p>约束条件为：</p><p><span class="math inline">\(s.t. \ \gamma \vec 1 = \vec a\)</span></p><p><span class="math inline">\(\gamma ^T \vec 1\)</span>=<span class="math inline">\(\vec b\)</span></p><p><span class="math inline">\(\gamma = \geq 0\)</span></p><p>其中：</p><ul><li>M是代价函数：<span class="math inline">\((dima_a, dim_b)\)</span></li><li><span class="math inline">\(\Omega\)</span>是熵正则化，<span class="math inline">\(\Omega(\gamma)= \Sigma_{i,j} \gamma_{i,j}log(\gamma_{i,j})\)</span></li><li><span class="math inline">\(\vec a, \vec b\)</span>是源和目标权重，两者求和都是1</li></ul><p>利用frank-wolfe算法和sinkhorn来求解可以得到一个最优的初始化的<span class="math inline">\(P^*\)</span></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">1</span>, niter + <span class="number">1</span>): <span class="comment"># 10轮次的迭代？</span></span><br><span class="line">    <span class="keyword">if</span> it % <span class="number">10</span> == <span class="number">0</span>: print(it)</span><br><span class="line">    <span class="string">'''G就是初始化要用的min ||(A_1P - PA_2)||'''</span></span><br><span class="line">    G = P.dot(K2_X) + K2_Y.dot(P) - <span class="number">2</span> * K_Y.dot(P.dot(K_X))</span><br><span class="line">    <span class="comment"># G = G.todense() #TODO how to get around this??</span></span><br><span class="line">    <span class="comment"># TODO 为啥会出现matrix类型呢？</span></span><br><span class="line">    <span class="keyword">if</span> (type(G) == np.matrix): <span class="comment"># G有可能出现的是matrix类型，转换了</span></span><br><span class="line">        G = G.A</span><br><span class="line">    q = ot.sinkhorn(np.ones(n), np.ones(n), G, reg, stopThr=<span class="number">1e-3</span>) <span class="comment"># 得到了最优传输矩阵</span></span><br><span class="line">    q = sparse.csr_matrix(q) <span class="comment"># 压缩稀疏矩阵</span></span><br><span class="line">    <span class="comment">#print q.shape</span></span><br><span class="line">    alpha = <span class="number">2.0</span> / float(<span class="number">2.0</span> + it)</span><br><span class="line">    P = alpha * q + (<span class="number">1.0</span> - alpha) * P <span class="comment"># P是最先初始化的, frank-wolfe算法更新方向</span></span><br></pre></td></tr></table></figure><p>然后求解<span class="math inline">\(min_{Q \in O^d}||Y_1Q-PY_2||\)</span>可以得到一个初始化的<span class="math inline">\(Q_0\)</span>，显然这个是个正交procrustes问题，可以通过<span class="math inline">\(P^*YX^T\)</span>的SVD得到。</p><h3 id="cone-align的具体做法">2.2 CONE-Align的具体做法</h3><ul><li>首先要进行初始化的步骤：</li></ul><p><span class="math inline">\(P^*=argmin_{P∈B^n}||(A_1P-PA_2)||_2^2\)</span>，这个是啥意思了？</p><p>这里相当于引入两个图的邻接矩阵，用两个图的邻接矩阵来进行初始化的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">n, d = X.shape</span><br><span class="line"><span class="keyword">if</span> apply_sqrt:</span><br><span class="line">    X, Y = sqrt_eig(X), sqrt_eig(Y)</span><br><span class="line"><span class="keyword">if</span> K_X <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">K_X = np.dot(X, X.T)</span><br><span class="line"><span class="keyword">if</span> K_Y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    K_Y = np.dot(Y, Y.T)</span><br><span class="line">K_Y *= sparse.linalg.norm(K_X) / sparse.linalg.norm(K_Y)</span><br><span class="line">K2_X, K2_Y = K_X.dot(K_X), K_Y.dot(K_Y)</span><br><span class="line"><span class="comment">#print K_X, K_Y, K2_X, K2_Y</span></span><br><span class="line">K_X, K_Y, K2_X, K2_Y = K_X.toarray(), K_Y.toarray(), K2_X.toarray(), K2_Y.toarray()</span><br><span class="line">P = np.ones([n, n]) / float(n)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">1</span>, niter + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> it % <span class="number">10</span> == <span class="number">0</span>: print(it)</span><br><span class="line">    G = P.dot(K2_X) + K2_Y.dot(P) - <span class="number">2</span> * K_Y.dot(P.dot(K_X))</span><br><span class="line">    <span class="comment">#G = G.todense() #TODO how to get around this??</span></span><br><span class="line">    <span class="keyword">if</span> (type(G) == np.matrix): <span class="comment"># G有可能出现的是matrix类型，转换了</span></span><br><span class="line">        G = G.A</span><br><span class="line">    q = ot.sinkhorn(np.ones(n), np.ones(n), G, reg, stopThr=<span class="number">1e-3</span>)</span><br><span class="line">    q = sparse.csr_matrix(q)</span><br><span class="line">    <span class="comment">#print q.shape</span></span><br><span class="line">    alpha = <span class="number">2.0</span> / float(<span class="number">2.0</span> + it)</span><br><span class="line">    P = alpha * q + (<span class="number">1.0</span> - alpha) * P</span><br><span class="line">obj = np.linalg.norm( P.dot(K_X) - K_Y.dot(P) )</span><br><span class="line">print(obj)</span><br><span class="line"><span class="keyword">return</span> utils.procrustes(P.dot(X), Y).T, P</span><br></pre></td></tr></table></figure><p>首先：<span class="math inline">\(K_X=X*X^T,K_Y=Y*Y^T\)</span></p><p>然后计算得到：<span class="math inline">\(K_Y=K_Y*||K_X|| \div ||K_Y||\)</span></p><p><span class="math inline">\(K2_X=K_X*K_X=X*X^T*X*X^T\)</span></p><p><span class="math inline">\(K2_Y=K_Y*K_Y\)</span></p><p>这个函数就是用frank-Wolfe算法来求解这个<span class="math inline">\(P^*\)</span>。</p><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;embedding部分&quot;&gt;1. embedding部分&lt;/h1&gt;
&lt;h2 id=&quot;splitter的embedding&quot;&gt;1.1 splitter的embedding&lt;/h2&gt;
&lt;p&gt;首先这个embedding用到了一个非重叠的聚类算法，说白了就是划分子图，并
      
    
    </summary>
    
    
    
      <category term="研究工作" scheme="http://yoursite.com/tags/%E7%A0%94%E7%A9%B6%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Meta Diagram based Active Social Networks</title>
    <link href="http://yoursite.com/2022/06/17/Meta-Diagram-based-Active-Social-Networks/"/>
    <id>http://yoursite.com/2022/06/17/Meta-Diagram-based-Active-Social-Networks/</id>
    <published>2022-06-17T11:05:42.000Z</published>
    <updated>2022-06-17T03:12:12.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>这个论文是专门用在社交网络的对齐，社交网络存在一些问题：缺少训练数据，网络异质性以及一对一约束。现存的方法需要大量的训练集，与其他的同质性网络对齐不同的，社交网络对齐是异质性的对齐。此外，锚链上的一对一基数约束使它们的推理过程相互关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;1. 简介&lt;/h1&gt;
&lt;p&gt;这个论文是专门用在社交网络的对齐，社交网络存在一些问题：缺少训练数据，网络异质性以及一对一约束。现存的方法需要大量的训练集，与其他的同质性网络对齐不同的，社交网络对齐是异质性的对齐。此外，锚链上的一对一基数约束使它们的推理过程
      
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-17T01:44:45.000Z</published>
    <updated>2022-08-22T04:40:36.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统笔记">0. 操作系统笔记</h1><p><a id="more"></a></p><p>本笔记是基于《操作系统导论》书籍，王道的操作系统考研以及哈工大李治军老师的操作系统课程做的笔记[https://www.bilibili.com/video/BV1d4411v7u7?spm_id_from=333.337.search-card.all.click&amp;vd_source=2c8f06c2de9e2684a8af9b7eb62c75b7]。希望自己能了解点底层的东西。</p><h1 id="操作系统简介">1. 操作系统简介</h1><p>操作系统要知道的关键问题就是操作系统如何将资源虚拟化，操作系统主要一种通用的技术，也就是虚拟化。操作系统将物力资源（如处理器、内存或者磁盘）转换为更通用、更强大且更易于使用的虚拟形式。</p><p>操作系统就是相当于沟通计算机应用和计算机的桥梁，是软件。管理的硬件包含：CPU管理，内存管理，终端管理，磁盘管理，文件管理，网络管理，电源管理，多核管理。</p><p>操作系统的层次如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\操作系统的层次.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">操作系统的层次</div></center><pre><code>&lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;D:\blog\source\_posts\操作系统\系统调用过程.png&quot;&gt;&lt;br&gt;&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;&quot;&gt;系统调用过程&lt;/div&gt;</code></pre><pre><code>  &lt;img style=&quot;border-radius: 0.3125em;  box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;   src=&quot;D:\blog\source\_posts\操作系统\第一类虚拟机管理程序.png&quot;&gt;  &lt;br&gt;  &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;  display: inline-block;  color: #999;  padding: 2px;&quot;&gt;第一类虚拟机管理程序&lt;/div&gt;</code></pre><ul><li>第二类虚拟机管理程序：就相当于一个普通的进程。仍然伪装成具有CPU和各种设备的完整计算机。就相当于在VMware中安装虚拟机那样。</li></ul><h1 id="进程与线程">2. 进程与线程</h1><h2 id="进程的概念与特征">2.1 进程的概念与特征</h2><p>在多道程序的环境下，允许多个程序并发的执行，此时它们将失去封闭性，并具有间断性以及不可再现性的特征。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的<strong>并发性和共享性</strong>。</p><p>为了使参与并发执行的每个程序和数据都能独立的运行，必须为之配置一个专门的数据结构，称为进程控制块（process control block）PCB。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应的，由<strong>程序段、相关数据段和PCB</strong>三部分构成了进程实体。创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程中的PCB。<strong>PCB是进程存在的唯一标志。</strong></p><p>可以简单的理解为：进程是程序的一次执行的过程。进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><p>进程的特征如下：</p><ul><li>动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态的产生、变化和消亡的。</li><li>并发性：指多个进程实体同存于内存中，能在一段时间内同时进行。</li><li>独立性：指进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。但凡未建立PCB的程序，都不能作为一个独立的单位参与运行。</li><li>异步性：由于进程的相互制约，使得进程按各自独立的、不可预知的速度向前推进。</li></ul><h3 id="进程的状态与转换">2.1.1 进程的状态与转换</h3><p>进程在生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断地发生变化。</p><ul><li>运行态：进程正在处理机上运行。</li><li>就绪态：进程获得了除处理机外的一切所需资源，一旦得到了处理机，便可以立即运行。系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态：进程正在等待某一事件而暂停运行，即使处理机空闲，该进程也不能运行。系统也将处于阻塞态的进程排成阻塞队列。</li><li>创建态：进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所需的资源；最后把该进程转入就绪态并插入就绪队列。<strong>但是如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时处于创建态。</strong></li><li>结束态：进程正从系统中消失，可能是进程正常结束或其他原因退出运行。结束运行时，系统首先将该进程置于结束态，然后进一步处理资源释放和回收等工作。</li></ul><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\5种进程状态的切换.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">5种进程状态的切换</div></center><h3 id="进程的组织">2.1.3 进程的组织</h3><ul><li>进程控制块：进程创建时，操作系统为它新建一个PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。<strong>PCB是进程实体的一部分，是进程存在的唯一标志。</strong>进程执行时，系统通过PCB了解进程的现行状态信息，以便操作系统对其进行控制和管理，进程结束时，系统回收其PCB，该进程随之消亡。在进程的整个生命周期内，系统总是通过PCB对进程进行控制的。</li></ul><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\PCB包含的信息.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">PCB包含的信息</div></center><ul><li>程序段：程序段就是能被进程调度到CPU执行的程序代码段。程序可能被多个进程共享，即多个进程可以运行同一个程序。</li><li>数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</li></ul><h3 id="进程控制">2.1.3 进程控制</h3><ul><li><p>进程的创建：</p><p>允许一个进程创建另一个进程，此时创建者称为父进程，被创建的称为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将从父进程那里获得的资源归还给父进程。在撤销父进程时，通常也会撤销其所有子进程。</p><p>创建新进程的步骤为：</p><p>（1）为新进程分配一个唯一的进程标识号，并申请一个空白的PCB（PCB是有限的）。若PCB申请失败，则创建失败。</p><p>（2）为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等。这些资源或从操作系统获得，或仅从父进程获得。若资源不足，则并不是创建失败，而是处于创建态，等待内存资源。</p><p>（3）初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息以及设置进程的优先级等。</p><p>（4）若进程就绪队列能够接纳新的进程，则将新进程插入就绪队列，等待被调度运行。</p></li><li><p>进程的终止：</p><p>终止的情况有：正常结束、异常结束或者外界干预结束。</p><p>终止进程的过程为：</p><p>（1）根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。</p><p>（2）若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</p><p>（3）若该进程还有子孙进程，则应该将其子孙进程终止。</p><p>（4）将该进程所拥有的全部资源，或归还给父进程，或归还给操作系统。</p><p>（5）将该PCB从所在队列（链表）中删除。</p></li><li><p>进程的阻塞和唤醒</p><p>阻塞原语的执行过程如下：</p><p>（1）找到将要被阻塞进程的标识号对应的PCB</p><p>（2）若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</p><p>（3）把该PCB插入相应时间的等待队列，将处理机资源调度给其他就绪进程。</p><p>唤醒原语如下：</p><p>（1）在该事件的等待队列中找到相应进程的PCB</p><p>（2）将其从等待队列中移除，并设置其状态为就绪态。</p><p>（3）把该PCB插入就绪队列，等待调度程序调度。</p></li></ul><h3 id="进程的通信">2.1.4 进程的通信</h3><p>进程之间交换信息的方式主要有三类：</p><ul><li><p>共享存储</p><p>在通信的进程之间存在一块可以直接访问的共享内存，通过对这片共享空间进行读写操作实现进程之间的信息交换。</p></li></ul><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\共享内存.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">共享存储</div></center><p>​ 在共享空间进行读写操作时，需要使用同步互斥工具，对共享空间的读写进行控制。共享内存有两种：低级方式的共享是基于数据结构的共享；高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享的存储空间和同步的互斥工具，而数据交换则由用户自己安排读写指令完成。</p><p><strong>进程空间一般都是独立的，想让两个进程共享空间就必须通过系统调用实现，而进程内的线程是自然共享进程空间的。</strong></p><ul><li>消息传递</li></ul><p>在消息传递系统中，进程间的数据交换以格式化的信息为单位。这种情况是在进程之间不存在可直接访问的共享空间的时候选择的。<strong>这种方式隐藏了通信实现的细节，使通信过程对用户透明，简化了通信程序的设计，是当前应用最广泛的进程间通信机制。</strong>这种机制能够很好地支持多处理机系统，分布式系统和计算机网络，所以也成为这些领域最重要的通信工具。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\消息传递.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">消息传递</div></center><p>（1）直接通信方式。发送进程直接把消息发送给接受进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p><p>（2）间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这个中间实体一般称为信箱。</p><ul><li>管道通信</li></ul><p>管道就是用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件。向管道提供（共享文件）输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。管道机制必须提供：互斥、同步和确定对方的存在。</p><p>管道可以克服使用文件的两个问题：</p><p>（1）限制管道的大小。管道是一个固定大小的缓冲区。在Linux中该缓冲区的大小为4KB，这使得它的大小不像文件那样不加检验的增长。使用单个固定缓冲区也会带来问题，写管道时可能变满，随后对管道的write()调用将默认的被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</p><p>（2）读进程也可能工作的比写进程快。当所有的当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认的被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</p><h2 id="线程和多线程">2.2 线程和多线程</h2><p><strong>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p><p>线程相当于<strong>轻量级进程</strong>，是一个基本的CPU单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程的所有资源。一个线程可以创建和撤销另一个进程，同一个进程中的多个进程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中出现间断性。线程有就绪、阻塞和运行三种基本状态。</p><h3 id="线程与进程的比较">2.2.1 线程与进程的比较</h3><ul><li>调度。在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间也可以并发执行，甚至不同进程中的线程也能并发执行。</li><li>拥有资源。进程是系统中拥有资源的基本单位，而线程不拥有系统资源（<strong>仅有一点必不可少，能保证独立运行的资源</strong>）。但是线程可以访问其隶属进程的系统资源，同一进程的所有线程都具有相同的地址空间。</li><li>独立性。每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程不可见。同一进程中的不同线程是为了提高并发性及进行相互间的合作而创建的，它们共享进程的地址空间和资源。</li><li>系统开销。在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源，操作系统为此付出的开销明显大于创建或撤销线程时的开销。同样在涉及上下文切换的地方，线程的开销也是要小于进程的。</li><li>支持多处理机系统。进程只能运行在一个处理机上，对于多线程进程，可以将进程中的多个线程分配到多个处理机上执行。</li></ul><h3 id="线程的属性">2.2.2 线程的属性</h3><ul><li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个惟一的标识符和一个线程控制块，PCB记录了线程执行的寄存器状态和栈等现场状态。</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</li><li>同一个进程中的各个线程共享该进程所拥有的资源。</li><li>线程是处理机的独立调度单位，多个线程是可以并发执行的，在多CPU的计算机系统中，各线程可以同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。</li></ul><h3 id="线程的状态与转换">2.2.3 线程的状态与转换</h3><ul><li>执行状态：线程已获得处理机而正在运行。</li><li>就绪状态：线程已具备各种执行条件，只需再获得CPU便可立即执行。</li><li>阻塞状态：线程在执行中因某事件受阻而处于暂停状态。</li></ul><h3 id="线程的实现方式">2.2.4 线程的实现方式</h3><ul><li>用户级线程</li></ul><p>在用户级线程中，有关线程管理（创建、撤销和切换等）的所有工作都由程序在用户空间中完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中运行开始，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\线程创建方式.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">线程创建方式</div></center><p>对于设置了用户级线程的系统，其调度仍然是以进程为单位进行的，各个流程轮流执行一个时间片。这种实现方式的优点为：1.线程切换不需要转换到内核空间，节省了模式切换的开销。2.调度算法可以是进程专用的，不同的进程可以根据自身的需要选择不同的调度算法。3.用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。</p><p>缺点为：1.系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内所有线程都被阻塞。2.不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行。</p><ul><li>内核级线程</li></ul><p>内核级线程也是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。内核级线程的实现方式的优点为：1.能发挥多处理机的优势，内核能同时调度统一进程的多个线程并执行。2.如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可以运行其他进程中的线程。3.支持线程具有很小的数据结构和堆栈，线程切换比较快，开销小。4.内核本身可以采用多线程技术，可以提高系统的执行速度和效率。</p><p>缺点为：同一进程中的线程切换，需要从用户态转到核心态进行，系统开销比较大。因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。</p><ul><li>组合方式</li></ul><p>多线程的模型有以下三种：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\多线程模型.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">多线程模型</div></center><h2 id="同步与互斥">2.3 同步与互斥</h2><p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约的关系。为了协调进程之间的相互制约的关系，引入了进程同步的概念。</p><ol type="1"><li>临界资源</li></ol><p>虽然多个进程可以共享系统中的各种资源，但是其中许多资源一次只能为一个进程所使用，我们将一次允许一个进程使用的资源称为<strong>临界资源</strong>。对临界资源的访问可以分为四个部分：</p><ul><li>进入区：为了进入临界区使用临界资源，需要检查是否能够进入临界区，若能的话就设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li><li>临界区：进程中访问临界资源的那段代码。</li><li>退出区：将正在访问临界区的标志清除。</li><li>剩余区：代码中的其余部分。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section; <span class="comment">//进入区</span></span><br><span class="line">    critical section; <span class="comment">//临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section; <span class="comment">//退出区</span></span><br><span class="line">    remainder section; <span class="comment">//剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> ()</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>同步</li></ol><p>同步也是制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</p><ol start="3" type="1"><li>互斥</li></ol><p>互斥也称为间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>为禁止两个进程同时进入临界区，同步机制应该遵循以下准则：</p><ul><li>空闲让进。</li><li>忙则等待。</li><li>有限等待。（有限时间内进入临界区）</li><li>让权等待。（当进程不能进入临界区时，应该立即释放处理器，防止进程忙等待）</li></ul><h3 id="互斥锁">2.3.1 互斥锁</h3><p>解决临界区最简单的工具就是互斥锁。一个进程在进入临界区时应获得锁，在退出临界区的时候释放锁。函数acquire()获得锁，release()释放锁。</p><p>每个互斥锁一个布尔变量available，表示锁是否可用，如果可用的话调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">available</span>)</span><br><span class="line">        ;<span class="comment">//忙等待</span></span><br><span class="line">    <span class="built_in">available</span> = <span class="literal">false</span>;<span class="comment">//获得锁</span></span><br><span class="line">    <span class="built_in">release</span>()&#123;</span><br><span class="line">        <span class="built_in">available</span> = <span class="literal">true</span>;<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p><p>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一个CPU时，就浪费了CPU周期，因此互斥锁通常用于多处理系统。</p><h3 id="信号量">2.3.2 信号量</h3><p>信号量机制可以用来同步与互斥的问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可以记为“P操作”和“V操作”。<strong>原语是指完成某种功能而不被分割、不被中断执行的操作序列，通常可由硬件来实现。原语不可中断在于原语对变量的操作过程若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。</strong></p><ul><li>记录型信号量</li></ul><p>是一种不存在忙等现象的进程同步机制。除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><p>相应的wait(S)和signal(S)的操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;<span class="comment">//相当于申请资源</span></span><br><span class="line">    S.value--;<span class="comment">//表示进程请求一个该类资源</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        add <span class="keyword">this</span> <span class="built_in">process</span> to S.L;</span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;<span class="comment">//相当于释放资源</span></span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">remove</span> a <span class="built_in">process</span> P from S.L;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用信号量实现同步</li></ul><p>设S为实现进程<span class="math inline">\(P_1,P_2\)</span>同步的公共信号量，初值为0.进程<span class="math inline">\(P_2\)</span>中的语句y要使用进程<span class="math inline">\(P_1\)</span>中语句的运行结果，所以只有当语句x执行完成之后语句y才可以执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;<span class="comment">//初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    x;<span class="comment">//语句x</span></span><br><span class="line">    V(S);<span class="comment">//告诉进程P2，语句x已经完成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);<span class="comment">//检查语句x是否运行完成</span></span><br><span class="line">    y;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若<span class="math inline">\(P_2\)</span>执行到<span class="math inline">\(P(S)\)</span>时，S为0，执行P操作会把进程<span class="math inline">\(P_2\)</span>阻塞，并放入阻塞队列；当进程<span class="math inline">\(P_1\)</span>中x执行完后，执行V操作，把<span class="math inline">\(P_2\)</span>从阻塞队列中放回就绪队列，当<span class="math inline">\(P_2\)</span>得到处理机时，就得以继续执行。</p><h2 id="管程">2.4 管程</h2><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当导致系统死锁。<strong>管程就是用来保证进程的互斥，无序程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了变量条件，可以让程序员灵活的实现进程同步。</strong></p><p>管程由4部分组成：1.管程的名称；2.局部于管程内部的共享数据结构说明；3.对该数据结构进行操作的一组过程或函数；4.对局部于管程内部的共享数据设置初始值的语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;<span class="comment">//定义一个名称为"Demo"的管程</span></span><br><span class="line">    <span class="comment">//定义共享数据结构，对应系统中的某种共享资源共享数据结构S</span></span><br><span class="line">    <span class="comment">//对共享数据结构初始化的语句</span></span><br><span class="line">    init_code()&#123;</span><br><span class="line">        S=<span class="number">5</span>;<span class="comment">//初始资源数等于5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过程1：申请一个资源</span></span><br><span class="line">    take_away()&#123;</span><br><span class="line">        对共享数据结构x的一系列处理</span><br><span class="line">        S--;<span class="comment">//可用资源数-1</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过程2：归还一个资源</span></span><br><span class="line">    give_back()&#123;</span><br><span class="line">        对共享数据结构x的一系列处理</span><br><span class="line">        S++;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>管程把对共享资源的操作封装起来，管程内的共享数据只能被管程内的过程所访问。</li><li>每次仅允许一个进程进入管程，从而实现进程互斥。</li></ul><h2 id="死锁">2.5 死锁</h2><p>在多道程序系统中，由于多个进程的并发执行，带来了死锁的现象。死锁就是指多个进程由于竞争资源而造成的一种僵局，互相等待，若无外力作用，这些进程都将无法向前推进。</p><h3 id="死锁产生的原因">2.5.1 死锁产生的原因</h3><ul><li><p>系统资源的竞争</p></li><li><p>进程推进顺序非法</p><p>进程在运行过程中，请求和释放资源的顺序不当，同样会造成死锁。例如并发进程<span class="math inline">\(P_1,P_2\)</span>分别保持了资源<span class="math inline">\(R_1,R_2\)</span>，而进程<span class="math inline">\(P_1\)</span>申请资源<span class="math inline">\(R_2\)</span>，进程<span class="math inline">\(P_2\)</span>申请资源<span class="math inline">\(R_1\)</span>时，两者都会因为所需资源被占用而阻塞，于是导致死锁。</p></li></ul><h3 id="死锁产生的必要条件">2.5.2 死锁产生的必要条件</h3><ul><li>互斥条件：进程要求对所分配的资源进行排他性使用，即在一段时间内某资源仅为一个进程所占用。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</li><li>请求并保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求被进程阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ul><h3 id="死锁的处理策略">2.5.3 死锁的处理策略</h3><ul><li>死锁预防。设置某些限制条件，破坏产生死锁的4个条件中的一个或几个。</li><li>避免死锁。在资源启动的动态分配过程中，用某种方法阻止系统进入不安全状态。</li><li>死锁的检测及解除。</li></ul><h3 id="死锁避免的方法">2.5.4 死锁避免的方法</h3><h4 id="系统安全状态">2.5.4.1 系统安全状态</h4><p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应该先计算此分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配，否则让进程等待。</p><p>安全状态就是系统能按照某种进程推进顺序(<span class="math inline">\(P_1,P_2,...,P_n\)</span>)为每个进程<span class="math inline">\(P_i\)</span>分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序完成。此时称<span class="math inline">\(P_1,P_2,...,P_n\)</span>为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态。反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p><h4 id="银行家算法">2.5.4.2 银行家算法</h4><p>来源于：[https://qyliang.blog.csdn.net/article/details/80245715?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-80245715-blog-124103874.pc_relevant_show_downloadRating&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-80245715-blog-124103874.pc_relevant_show_downloadRating&amp;utm_relevant_index=1]:</p><p>银行家算法的本质就是：当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探作废，让该进程继续等待。</p><p><img src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/银行家算法.png"></p><ul><li>首先是银行家算法中的进程：包含进程<span class="math inline">\(P_i\)</span>的需求资源数量（也是最大需求资源数量，MAX），已分配给该进程的资源A(Allocation)，还需要的资源数量(Need = M - A)</li><li>Available为空闲资源数量，即资源池</li></ul><p>假设资源<span class="math inline">\(P_1\)</span>申请资源，银行家算法首先试探的分配给它，若申请的资源数量小于等于available，然后接着判断分配给<span class="math inline">\(P_1\)</span>后剩余的资源，能不能使得进程队列的某个进程执行完毕，若没有进程可以执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随着时间推移，系统将处于死锁状态）。</p><p>若有进程可以执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有的进程都可以执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列。</p><p>银行家算法的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Max[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//各进程对资源的最大需求数</span></span><br><span class="line"><span class="keyword">int</span> Allocation[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//已经给各进程分配了多少资源</span></span><br><span class="line"><span class="keyword">int</span> Need[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//各进程还需要多少资源</span></span><br><span class="line"><span class="keyword">int</span> Available[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//总的可用资源</span></span><br><span class="line"><span class="keyword">int</span> Request[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//进程此次申请的各种资源数</span></span><br><span class="line"><span class="keyword">int</span> Afford[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//还有多少可用资源</span></span><br><span class="line"><span class="keyword">int</span> Security[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//安全序列的进程</span></span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//各类资源名称</span></span><br><span class="line"><span class="keyword">int</span> M, N; <span class="comment">//进程数和资源种类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入可分配的资源种类数量："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"个资源的名称："</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Name[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; Name[i] &lt;&lt; <span class="string">"资源的可分配数量："</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Available[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请输入进程数量："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请输入进程的Max矩阵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Max[i][j]; <span class="comment">//输入每个进程所需要的各种资源的最大数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请输入进程的Allocation矩阵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> every[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Allocation[i][j]; <span class="comment">//每个进程已经分配的各种资源的数量</span></span><br><span class="line">            Need[i][j] = Max[i][j] - Allocation[i][j]; <span class="comment">//Need数组通过最大-已经获得</span></span><br><span class="line">            every[j] += Allocation[i][j]; <span class="comment">//统计每一种类已经分配的资源数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        Available[i] = Available[i] - every[i]; <span class="comment">//总的-已经分配处去的=现在剩余的可分配数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"       "</span> &lt;&lt;<span class="string">"系统当前可用的资源矩阵Available:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"               "</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  "</span> &lt;&lt; Name[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"               "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt; Available[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"         "</span> &lt;&lt; <span class="string">"系统当前资源分配情况如下:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt; <span class="string">"       Max      Allocation     Need      "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程名  "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Name[j] &lt;&lt; <span class="string">"    "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123; <span class="comment">//打印进程的三个矩阵</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Pro"</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt;Max[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt; Allocation[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt; Need[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_Safe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> isAfford[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//是否有足够的资源分配给进程，使之完成运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        Afford[i] = Available[i]; <span class="comment">//在执行安全算法开始时，work=available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, m = <span class="number">0</span>;<span class="comment">//count是用来统计系统足够某个进程所需的某种资源数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAfford[i] == <span class="number">0</span> &amp;&amp; Need[i][j] &lt;= Afford[j])&#123;</span><br><span class="line">                <span class="comment">//如果进程没有执行且资源需求条件满足</span></span><br><span class="line">                count ++;<span class="comment">//这种资源是够的</span></span><br><span class="line">                <span class="keyword">if</span> (count == N)&#123;<span class="comment">//表示对i号进程的所有资源都满足</span></span><br><span class="line">                    isAfford[i] = <span class="number">1</span>;<span class="comment">//记录i号进程为可执行</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                        Afford[k] = Afford[k] + Allocation[i][k];<span class="comment">//进程执行成功，回收各资源</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Security[m++] = i;<span class="comment">//此进程可以进入安全序列</span></span><br><span class="line">                    i = <span class="number">-1</span>;<span class="comment">//将i设置为-1，通过for循环执行i++后变为0，从第一个进程重新开始找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;             <span class="comment">//依次检查各进程，如果有一个不满足，就说明不安全</span></span><br><span class="line">        <span class="keyword">if</span>(isAfford[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"系统不安全"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"系统安全"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"一个安全序列为:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"P"</span> &lt;&lt; Security[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;M<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"--&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入手动分配资源的进程编号:"</span>;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; id)&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt; M<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"进程不存在!请重新输入!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请重新输入希望手动分配资源的进程的编号:"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请分别输入各类请求资源数("</span> &lt;&lt; N &lt;&lt; <span class="string">"个):"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Request[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"开始为进程Pro"</span> &lt;&lt; id &lt;&lt; <span class="string">"分配资源,请等待..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Request[i]&gt;Need[id][i])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程请求资源数大于所需资源数，无法分配!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Request[i]&gt;Available[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程请求资源数大于可用资源数，无法分配!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Available[i] -= Request[i];           <span class="comment">//可用资源数减少</span></span><br><span class="line">            Allocation[id][i] += Request[i];      <span class="comment">//已分配资源数增加</span></span><br><span class="line">            Need[id][i] -= Request[i];            <span class="comment">//所需资源数减少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_Safe())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"分配资源完成!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">                Available[i] += Request[i];           <span class="comment">//分配资源回收</span></span><br><span class="line">                Allocation[id][i] -= Request[i];</span><br><span class="line">                Need[id][i] += Request[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="string">"此次分配会导致系统不安全，无法分配!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"                 "</span> &lt;&lt; <span class="string">"银行家算法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    init(); <span class="comment">//初始化</span></span><br><span class="line">    show_info();</span><br><span class="line">    is_Safe();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"               "</span> &lt;&lt; <span class="string">"手动进行资源请求"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"               "</span> &lt;&lt; <span class="string">"输入R/r请求资源"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"               "</span> &lt;&lt; <span class="string">"输入E/e退出程序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"              "</span> &lt;&lt; <span class="string">"****************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> choice;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请选择资源分配(R/r)还是退出(E/e):"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(choice==<span class="string">'R'</span>||choice==<span class="string">'r'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bank())&#123;          <span class="comment">//可分配</span></span><br><span class="line">                show_info();     <span class="comment">//展示信息</span></span><br><span class="line">            &#125;           <span class="comment">//这边由于上述bank()算法已经进行了安全性检查，此处无需再次调用</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                show_info();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="string">'E'</span>||choice==<span class="string">'e'</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"退出程序成功!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请正确选择!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁检测和解除">2.6 死锁检测和解除</h2><p>系统死锁可以利用资源分配图来描述。</p><p><img src="../images/死锁资源分配.png"></p><p>圆圈表示一个进程，框表示一类资源，一种类型的资源可能有多个，进程到资源的有向边称为请求边，表示该进程中申请一个单位的该类资源；从资源到进程的边称为分配边，表示该类资源已有一个资源分配给了该进程。</p><h3 id="死锁定理">2.6.1 死锁定理</h3><ul><li>在资源分配图中，找出既不阻塞又不孤点的进程<span class="math inline">\(P_i\)</span>（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有的空闲资源）。判断某种资源是否有空闲，应该用它的资源数量减去它在资源分配图中的出度。</li><li>进程<span class="math inline">\(P_i\)</span>释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。</li><li>死锁解除：1.资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。2.撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。3.进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而非被剥夺。</li></ul><h1 id="内存管理">3. 内存管理</h1><h2 id="内存管理的概念">3.1 内存管理的概念</h2><p>内存管理的主要功能有：</p><ul><li>内存空间的分配与回收</li><li>地址转换</li><li>内存空间的扩充</li><li>内存共享</li><li>存储保护</li></ul><p>将用户源程序变为可在内存中执行的程序，通常需要以下步骤：编译，链接，装入。</p><p><img src="../images/用户程序变为可执行程序.png"></p><p>程序的链接方式：</p><ul><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。将几个模块装配成一个装入模块时：1、修改相对地址，编译后的所有目标模块都是从0开始的相对地址；2、变换外部调用符号，将每个模块中所用的外部调用符号也都变换成相对地址。</li><li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。</li><li>运行时动态链接：对于某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。凡在执行过程中未被用到的目标模块，都不会被调入内存和被连接到装入模块上。</li></ul><p>装入方式同样有以下三种：</p><ul><li>绝对装入：只适用于单道程序环境。在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序难找装入模块中的地址，将程序和数据装入内存。</li><li>可重定位装入：在多道程序环境下，多个目标模块的起始地址通常都是从0开始的，程序中的其他地址都是相对于起始地址的，此时应该采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。在装入时对目标程序中指令和数据地址的修改过程称为重定位。</li><li>动态运行时装入：动态重定位，程序在内存中若发生移动，装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。</li></ul><p><img src="../images/重定位类型.png"></p><p><strong>逻辑地址和物理地址</strong>：编译后，每个目标模块都从0号单源开始编址，这称为目标模块的相对地址（逻辑地址）；当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序一次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间（虚拟地址空间）。进程在运行时，看到和使用的地址都是逻辑地址。</p><p><strong>物理地址空间</strong>是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换为物理地址，这叫做<strong>地址重定位</strong>。操作系统通过内存管理部件（MMU）将进程使用的逻辑地址转换为物理地址。</p><p><strong>进程的内存映像</strong>：当一个程序调入内存运行时，就构成了进程的内存映像。一个内存映像一般有几个要素：1.代码段，即程序的二进制代码，是只读的，可以被多个进程共享；2.数据段，即程序运行时加工处理的对象，包括全局变量和静态变量；3.进程控制块（PCB），存放在系统区，控制和管理进程；4.堆，用来存放动态分配的变量，通过调用malloc函数动态的向高地址分配空间；5.栈，用来实现函数调用，从用户空间的最大地址往低地址方向增长。</p><p><strong>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样，当调用malloc和free这样的函数时，堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态扩展和收缩，每调用一个函数，栈就会增长，从一个函数返回时，栈就会收缩。</strong></p><p><img src="../images/内存中的一个进程.png"></p><h3 id="内存保护">内存保护</h3><p>确保每个进程都有一个单独的内存空间。需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可以采取两种方法：</p><ul><li>在CPU中设置一对上下限寄存器，存放用户作业在驻村中的上限和下限地址，每当CPU要访问一个地址时，分别和两个寄存器的值比较，判断有无越界。</li><li>采用重定位寄存器和界地址寄存器来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。内存管理机构动态的将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送给内存单元。<strong>只有操作系统内核才能加载这两个寄存器，而不允许用户程序修改。</strong></li></ul><p><img src="../images/重定位寄存器和界地址寄存器.png"></p><h3 id="内存共享">内存共享</h3><p>只有只读的区域才可以共享。<strong>可重入代码又称纯代码，是一种允许多个进程同时访问但不允许任何进程修改的代码。</strong>在实际执行时，可以为每个进程配以局部数据区，把在执行中可能改变的部分复制到该数据区，这样程序在执行时只需对该私有数据区中的内存进行修改，不去改变共享的代码。</p><h3 id="连续分配管理方式">连续分配管理方式</h3><ul><li>单一连续分配：内存在此方式下分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；在用户区内存中，仅有一道用户程序，即整个内存的用户空间由该程序独占。</li><li>固定分区分配：是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区。</li></ul><h3 id="动态分区分配">动态分区分配</h3><p>是在进程装入内存时，根据进程的实际需要，动态的为之分配内存，并使分区的大小正好适合进程的需要。系统中分区的大小和数目是可变的。</p><p>动态分区在开始时是很好的，但是之后内存中可能会出现越来越多的小的内存块，内存的利用率也随之降低。这些小的内存块称为外部碎片，存在于所有分区的外部。克服外部碎片可以通过紧凑技术解决，即操作系统不时地对进程进行移动和整理。</p><p>在进程装入或换入主存时，若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区分配策略。</p><ul><li>首次适应算法：空闲分区以地址地址递增的顺序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。</li><li>临近适应算法：分配内存时从上次查找结束时的位置开始继续查找。</li><li>最佳适应算法：空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业。</li><li>最坏适应算法：空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区。</li></ul><h2 id="基本分页存储管理">3.2 基本分页存储管理</h2><p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存利用率都比较低。分页的思想就是为了尽量避免碎片的产生：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>分页存储中的几个基本概念：</p><ul><li><p>页面和页面大小：进程中的块称为页或者页面，内存中的块称为页框或者页帧。外存直接称为块或者盘块。进程在执行时需要申请主存空间，即要为每个页面分配主存中的可用页框，页和页框一一对应。</p></li><li><p>地址结构：分页存储管理的逻辑地址结构如下图所示：</p><p><img src="../images/分页存储逻辑地址结构.png"></p><p>地址结构决定了虚拟内存的寻址空间有多大。</p></li><li><p>页表：为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，页表一般存在于内存中。表的作用是实现页号到物理块号的地址映射。</p><p><img src="../images/页表的作用.png"></p></li></ul><h3 id="基本地址变换机构">基本地址变换机构</h3><p><img src="../images/地址变换机构.png"></p><p>设置一个页表寄存器（PTR），存放页表在内存的起始地址F和页表长度M。设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ul><li>计算页号P（P=A/L）和页内偏移W（W=A%L）</li><li>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行</li><li>页表中页号P对应的页表项地址=页表起始地址F+页号Px页表项长度，取出该页表项内容b，即为物理块号。</li><li>计算<span class="math inline">\(E=b\times L + W\)</span></li></ul><h3 id="具有快表的地址变换机构">具有快表的地址变换机构</h3><p>由上面的地址变换可知，若页表全部放在内存中，则存取一个数据或一个指令至少要访问内存</p><h1 id="网课笔记">4. 网课笔记</h1><h1 id="c语言知识">4.0 C语言知识</h1><p><img src="../images/C语言程序状态.png"></p><p><strong>程序其实也是个状态机。</strong>这是从源代码角度来看程序的。</p><p>从状态机的视角来看，程序就是<span class="math inline">\(计算\to syscall \to 计算 \to ...\)</span>这样的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">        movq $SYS_write, %rax   #write(</span><br><span class="line">        movq $1,        %rdi    # fd&#x3D;1,</span><br><span class="line">        movq $st,       %rsi    # buf&#x3D;st,</span><br><span class="line">        movq $(ed - st),%rdx    # count&#x3D;ed-st</span><br><span class="line">        syscall                 # );</span><br><span class="line"></span><br><span class="line">        movq $SYS_exit, %rax    #exit(</span><br><span class="line">        movq $1,        %rdi    # status&#x3D;1</span><br><span class="line">        syscall                 # );</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">        .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br></pre></td></tr></table></figure><p>上面这段代码可以说是最小的hello world的实现，里面提到了几个寄存器。寄存器属于CPU中的一块存储区域，有非常高的读写速度。</p><ul><li>rax:</li><li>rdi:</li><li>rsi:</li><li>rdx:</li></ul><p>寄存器的结构一般如下：</p><p><img src="../images/寄存器的结构.png"></p><p><img src="../images/寄存器的结构1.png"></p><p>逆向分析中常见的寄存器有4种：通用寄存器、段寄存器、标志位寄存器和指令指针寄存器。通用寄存器如下。</p><ul><li>EAX：(针对操作数和结果数据的)累加器 ，返回函数结果</li><li>EBX：(DS段中的数据指针)基址寄存器</li><li>ECX：(字符串和循环操作数)计数器</li><li>EDX：(I/O指针)数据寄存器</li><li>EBP：(SS段中栈内数据指针)扩展基址指针寄存器</li><li>ESI：(字符串操作源指针)源变址寄存器</li><li>EDI：(字符串操作目标指针)目的变址寄存器</li><li>ESP：(SS段中栈指针)栈指针寄存器</li></ul><p>编译器的作用就是将源代码（状态机）转换为二进制代码（状态机）<span class="math inline">\(C=compile(S)\)</span>，那么正确的编译就是：S与C的可观测行为严格一致。</p><p>现在的编译器会在保证观测一致性的前提下改写代码：</p><ul><li>内嵌汇编也可以参与优化</li><li>其他优化可能会跨过不带barrier的asm volatile。</li><li>eventual memory consistency</li></ul><h2 id="并发">4.1 并发</h2><p>并发的基本单位：线程</p><p>并发共享内存的多个执行流：1.执行流拥有独立的堆栈/寄存器 2.共享全部的内存（指针可以互相引用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">unistd.h为Linux/Unix系统中内置头文件，包含了许多系统服务的函数原型，</span></span><br><span class="line"><span class="comment">例如read函数、write函数和getpid函数等。</span></span><br><span class="line"><span class="comment">其作用相当于windows操作系统的"windows.h"，</span></span><br><span class="line"><span class="comment">是操作系统为用户提供的统一API接口，方便调用系统提供的一些服务。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREAD 64</span></span><br><span class="line"><span class="keyword">enum</span> &#123; T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id, status;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread;</span><br><span class="line">  <span class="keyword">void</span> (*entry)(<span class="keyword">int</span>);<span class="comment">//指针函数，传参是int类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池，并创建指向线程池的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> = <span class="title">tpool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wrapper</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传参arg是一个指针对象</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> = (<span class="title">struct</span> <span class="title">thread</span> *)<span class="title">arg</span>;</span></span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">void</span> *fn)</span> </span>&#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);<span class="comment">//创建合法的线程</span></span><br><span class="line">  *tptr = (struct thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  pthread_create是Unix下创建线程的函数。</span></span><br><span class="line"><span class="comment">  传参：</span></span><br><span class="line"><span class="comment">  int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg);</span></span><br><span class="line"><span class="comment">  tidp：事先创建好的pthread_t类型的参数。成功时tidp指向的内存单元被设置为新创建线程的线程ID。</span></span><br><span class="line"><span class="comment">  attr：用于定制各种不同的线程属性。</span></span><br><span class="line"><span class="comment">  start_rtn：新穿件线程从此函数开始运行。</span></span><br><span class="line"><span class="comment">  arg：start_rtn函数的参数。无参数时设置为null即可。</span></span><br><span class="line"><span class="comment">  返回值：成功返回0，否则返回错误码</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> = &amp;<span class="title">tpool</span>[<span class="title">i</span>];</span></span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发有个问题就是：<strong>原子性的丧失</strong>。所谓的原子性就是一段代码执行独占整个计算机系统。</p><ul><li>单处理多线程：线程在运行时可能被中断，切换到另一个线程执行。</li><li>多处理器多线程：线程根本就是并行执行的。</li></ul><p>比方说下面这个程序，就是因为线程起了冲突才造成最终的错误的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="comment">//        sum ++;</span></span><br><span class="line">        <span class="comment">//even if assembly, it returns the wrong res</span></span><br><span class="line"><span class="comment">//        asm volatile("add $1, %0": "+m"(sum));</span></span><br><span class="line">        <span class="comment">//true when we add lock to the threads</span></span><br><span class="line">        <span class="comment">//but the time usage increased dramatically</span></span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock add $1, %0"</span>: <span class="string">"+m"</span>(sum))</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//two simple threads make conflicts</span></span><br><span class="line">    create(Tsum);</span><br><span class="line">    create(Tsum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %ld\n"</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥和原子性是重点，以下俩API实现是关键：</p><ul><li>lock(&amp;lk)</li><li>unlock(&amp;lk)</li><li>实现临界区之间的绝对串行化</li><li>程序的其他部分仍然可以并行执行</li></ul><p>这里要注意的重点就是：<strong>多处理器编程是不原子、能乱序、不立即可见的。这些都是来自于编译优化，处理器也就是编译器。</strong></p><p>并发造成另一个问题就是顺序性问题，比方说下面这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="comment">//        sum ++;</span></span><br><span class="line">        <span class="comment">//even if assembly, it returns the wrong res</span></span><br><span class="line"><span class="comment">//        asm volatile("add $1, %0": "+m"(sum));</span></span><br><span class="line">        <span class="comment">//true when we add lock to the threads</span></span><br><span class="line">        <span class="comment">//but the time usage increased dramatically</span></span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock add $1, %0"</span>: <span class="string">"+m"</span>(sum))</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//two simple threads make conflicts</span></span><br><span class="line">    create(Tsum);</span><br><span class="line">    create(Tsum);</span><br><span class="line">    join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %ld\n"</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是任凭编译器进行优化的话，可能会出现不一样的输出结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock add $1, %0"</span>: <span class="string">"+m"</span>(sum))</span></span>;</span><br></pre></td></tr></table></figure><p>这句话的引入就是为了阻止编译器对内存访问"eventually consistent"的处理导致的共享内存作为线程同步工具的失效。插入上面的内嵌汇编就是为了优化不能穿越，告诉编译器不要去优化这个代码。</p><p>最后一个可能产生的问题就是不可见性。</p><p>单个处理器用电路把汇编代码编译成更小的<span class="math inline">\(\mu \ ops\)</span>，在任何时刻，处理器都维护一个<span class="math inline">\(\mu \ op\)</span>的池子。每个周期向池子补充尽可能多的<span class="math inline">\(\mu \ op\)</span>，也就是多发射。每一个周期执行尽可能多的<span class="math inline">\(\mu \ op\)</span>，也就是乱序执行，按序提交。满足单处理器eventual memory consistency的执行，在多处理器上可能无法序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     # &lt;-----------+</span><br><span class="line">movl $1, (x)   #   |</span><br><span class="line">movl (y), %eax # --+</span><br></pre></td></tr></table></figure><p>这段代码如果x发生cache miss，可以让y先执行，在多处理器上的表现就可能是y=0,x=0，产生错误的结果。</p><h3 id="互斥">互斥</h3><p>互斥是为了保证两个线程不能同时执行一段代码。</p><p><strong>如果只允许内存的读和写的话，如何保证共享内存上的互斥呢？</strong></p><p>首先介绍一个Peterson算法：</p><p>Peterson算法使用两个控制变量flag和turn，其中flag[n]的值为真表示ID号为n的进程希望进入该临界区。变量turn保存有权访问共享资源的进程的ID号。</p><p>假设A和B争用厕所：这里的旗子就是表示的谁想要上厕所，标签表示当两个进程都想上厕所时，谁可以上。</p><ul><li>想进入厕所之前，A/B都要先举起自己的旗子<ul><li>A确认旗子举好以后，往厕所门上贴上“B正在使用的标签”</li><li>B确认旗子举好以后，往厕所门上贴上“A正在使用”的标签。</li></ul></li><li>然后，如果对方的旗子举起来，且门上的名字不是自己，等待；否则可以进入厕所。</li><li>出厕所后，放下自己的旗子。</li></ul><p><strong>要注意看到的和下一步决策不能够同时执行，这也就是并发麻烦的所在。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdatomic.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_int</span> nested;<span class="comment">//atomic_int保证了线程的安全性</span></span><br><span class="line"><span class="keyword">atomic_int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critical_section</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> cnt = atomic_fetch_add(&amp;nested, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//only one thread in the pool?</span></span><br><span class="line">    assert(atomic_fetch_add(&amp;nested, <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">    atomic_fetch_add(&amp;nested, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">volatile</span> x = <span class="number">0</span>, y = <span class="number">0</span>, <span class="built_in">turn</span> = A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>; <span class="comment">//PC=1，把自己的旗子举起来</span></span><br><span class="line">        <span class="built_in">turn</span> = B; <span class="comment">//PC=2，把对方的标签贴上去</span></span><br><span class="line">        <span class="keyword">while</span> (y &amp;&amp; <span class="built_in">turn</span> == B);<span class="comment">//只要对面的旗子举起来并且标签还是对面，就一直空等待</span></span><br><span class="line">        critical_section();<span class="comment">//出来进入临界区</span></span><br><span class="line">        x = <span class="number">0</span>;<span class="comment">//PC=4，旗子放下来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        y = <span class="number">1</span>; <span class="comment">//PC=1</span></span><br><span class="line">        <span class="built_in">turn</span> = A; <span class="comment">//PC=2</span></span><br><span class="line">        <span class="keyword">while</span> (x &amp;&amp; <span class="built_in">turn</span> == A);</span><br><span class="line">        critical_section();</span><br><span class="line">        y = <span class="number">0</span>;<span class="comment">//PC=4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    create(TA);</span><br><span class="line">    create(TB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入临界区的时候：</p><p>1.如果只有一个人举旗，他就可以直接进入；</p><p>2.如果两个人同时举旗，由厕所门上的标签决定谁进（手快有，被另一个人的标签覆盖（太心机了，看似谦让，实则自私），手慢无）</p><p>3.A看到B没有举旗，那么B一定不在临界区，或者B想进去但是还没有来得及把A正在使用贴在门上。</p><p>4.A看到B举旗子，A一定已经把旗子举起来了。</p><h3 id="如何在多处理器上实现线程互斥">如何在多处理器上实现线程互斥？</h3><p>实现互斥的根本困难在于：不能同时读/写共享内存。</p><h4 id="自旋锁">自旋锁</h4><p>这里是假设硬件能为我们提供一条瞬间完成的读+写指令。如果多个人同时请求，由硬件选出一个胜者，败者要等胜者完成后才能继续执行。</p><p>用xchg实现互斥，还是用厕所那个例子来说：</p><p>1.首先最开始的时候在厕所门口放一个桌子（共享变量），初始时桌子上是钥匙</p><p>2.想要上厕所的同学（一条xchg指令）</p><p>​ 看一眼桌子上的东西是钥匙还是禁止进 入，如果是禁止进入的话就等</p><p>3.出厕所的同学要把钥匙归还到桌子上</p><p>python下实现这个自旋锁的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spinlock</span>:</span></span><br><span class="line">    locked = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @thread</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">t1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self.locked, seen = <span class="string">'🔒'</span>, self.locked</span><br><span class="line">                <span class="keyword">if</span> seen != <span class="string">'🔒'</span>: <span class="keyword">break</span></span><br><span class="line">            cs = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">del</span> cs</span><br><span class="line">            self.locked = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @thread</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">t2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                self.locked, seen = <span class="string">'🔒'</span>, self.locked</span><br><span class="line">                <span class="keyword">if</span> seen != <span class="string">'🔒'</span>: <span class="keyword">break</span></span><br><span class="line">            cs = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">del</span> cs</span><br><span class="line">            self.locked = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @marker</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mark_t1</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> localvar(state, <span class="string">'t1'</span>, <span class="string">'cs'</span>): <span class="keyword">return</span> <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @marker</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mark_t2</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> localvar(state, <span class="string">'t2'</span>, <span class="string">'cs'</span>): <span class="keyword">return</span> <span class="string">'green'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @marker</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mark_both</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> localvar(state, <span class="string">'t1'</span>, <span class="string">'cs'</span>) <span class="keyword">and</span> localvar(state, <span class="string">'t2'</span>, <span class="string">'cs'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'red'</span></span><br></pre></td></tr></table></figure><p>然而自旋锁存在以下缺陷：</p><ul><li>自旋（共享变量）会触发处理器间的缓存同步，延迟增加</li><li>除了进入临界区的线程，其他处理器上的线程都在空转，争抢锁的处理器越多，利用率越低。</li><li>获得自旋锁的线程可能被操作系统切换出去，实现100%的资源浪费。</li></ul><p>所以自旋锁的使用场景有限：1.临界区几乎不拥挤；2.持有自旋锁时禁止执行流切换。</p><h4 id="互斥锁-1">互斥锁</h4><p>那么我们可以很简单的想到，如何把自己的CPU让渡给其他作业执行。</p><p>这个C语言代码并不能做到，应该把锁放在操作系统中：</p><p><em>syscall(SYSCALL_lock, &amp;lk);</em>：试图获取lk，但是如果失败，就切换到其他线程。</p><p><em>syscall(SYSCALL_unlock, &amp;lk);</em>：释放lk，如果有等待锁的线程就唤醒。</p><p><strong>实现线程+长临界区的互斥：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">操作系统=更衣室管理员。</span><br><span class="line">先到的人（线程）：</span><br><span class="line">    成功获得手环，进入游泳馆</span><br><span class="line">    *lk = locked，系统调用直接返回</span><br><span class="line">后到的人（线程）：</span><br><span class="line">    不能进入游泳馆，等待排队</span><br><span class="line">    线程放入等待队列，执行线程切换(<span class="built_in">yield</span>)</span><br><span class="line">洗完澡出来的人（线程）：</span><br><span class="line">    交还手环给管理员；管理员把手环再交给排队的人。</span><br><span class="line">    如果等待队列不为空，则等待队列中取出一个线程允许执行。</span><br><span class="line">    如果等待队列为空，*lk = unlocked。</span><br><span class="line">管理员OS使用自旋锁确保自己处理手环的过程是原子的。</span><br></pre></td></tr></table></figure><p>下面是互斥锁的实现的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Spinlock</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">spinlock_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPIN_INIT() 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">atomic_xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"lock xchg %0, %1"</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"+m"</span>(*addr), <span class="string">"=a"</span>(result) : <span class="string">"1"</span>(newval) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> value = atomic_xchg(lk, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *lk)</span> </span>&#123;</span><br><span class="line">  atomic_xchg(lk, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutex</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">pthread_mutex_t</span> <span class="keyword">mutex_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUTEX_INIT() PTHREAD_MUTEX_INITIALIZER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(<span class="keyword">mutex_t</span> *lk)</span>   </span>&#123; pthread_mutex_lock(lk); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(<span class="keyword">mutex_t</span> *lk)</span> </span>&#123; pthread_mutex_unlock(lk); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Conditional Variable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">pthread_cond_t</span> <span class="keyword">cond_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COND_INIT() PTHREAD_COND_INITIALIZER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cond_wait pthread_cond_wait</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cond_broadcast pthread_cond_broadcast</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cond_signal pthread_cond_signal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Semaphore</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P sem_wait</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V sem_post</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_INIT(sem, val) sem_init(sem, 0, val)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread-sync.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000000000</span></span><br><span class="line"><span class="keyword">mutex_t</span> lock = MUTEX_INIT();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> n, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        mutex_lock(&amp;lock);</span><br><span class="line">        sum ++;</span><br><span class="line">        mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    assert(argc == <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> nthread = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    n = N / nthread;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nthread; ++i) &#123;</span><br><span class="line">        create(Tsum);</span><br><span class="line">    &#125;</span><br><span class="line">    join();</span><br><span class="line">    assert(sum == n * nthread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个如果我们使用spinlock来看运行的时间的话，开多个线程的时间是要大于开单个线程的时间的；而如果使用mutex_lock的话则不会有显著的变化。</p><p>当然也能将spin_lock和mutex_lock结合起来，结合优点。</p><h2 id="同步">4.2 同步</h2><p>这里首先引出一个生产者-消费者问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;<span class="keyword">while</span>(<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"("</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">")"</span>);&#125;</span><br></pre></td></tr></table></figure><p>如何在printf前后增加代码，使得打印的括号序列满足：</p><ul><li><p>一定是某个合法括号序列的前缀</p></li><li><p>括号嵌套深度不超过n</p></li><li><p>同步：等到有空位的时候再打印左括号；等到能配对时再打印右括号。</p></li></ul><p>这里左括号相当于生产资源（任务）、放入队列；右括号相当于从队列中取出资源（任务）执行。</p><p>能否用互斥锁来实现括号问题呢？</p><ul><li>左括号：嵌套深度（队列）不足n时才能打印</li><li>右括号：嵌套深度（队列）&gt;1时才能打印</li></ul><p>下面的思路就是用互斥锁来实现这个生产者消费者的思想的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread-sync.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">mutex_t</span> lk = MUTEX_INIT();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);<span class="comment">//首先创建一把互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;<span class="comment">//如果包里面的东西是满的，那么就一直得等待</span></span><br><span class="line">      mutex_unlock(&amp;lk);<span class="comment">//并且放弃当前的锁</span></span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">//一旦出来了，说明包里面有剩余空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"("</span>);<span class="comment">//可以打印</span></span><br><span class="line">    mutex_unlock(&amp;lk);<span class="comment">//并且释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  assert(argc == <span class="number">2</span>);</span><br><span class="line">  n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    create(Tproduce);</span><br><span class="line">    create(Tconsume);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可能造成的问题就是所有的进程都要访问一下锁，复杂度很大。这里的做法是将上述代码中的自旋变为睡眠，在完成操作的时候唤醒。</p><p>条件变量API：</p><ul><li>wait(cv, mutex)：调用时必须保证已经获得mutex，释放mutex、进入睡眠状态</li><li>signal/notify(cv)：如果有线程正在等待cv，则唤醒其中一个线程。</li><li>broadcast/notifyAll(cv)：唤醒全部正在等待的cv进程。</li></ul><p>主要的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_lock(&amp;lk);<span class="comment">//进去之前先给一把锁</span></span><br><span class="line">  <span class="keyword">if</span> (count == n) cond_wait(&amp;cv, &amp;lk);<span class="comment">//如果当前的包是满的，那么得等待一会</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"("</span>); count++; cond_signal(&amp;cv);<span class="comment">//传递消息给条件变量cv，唤醒正在等待其的变量</span></span><br><span class="line">  mutex_unlock(&amp;lk);<span class="comment">//解开锁的占用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_lock(&amp;lk);</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) cond_wait(&amp;cv, &amp;lk);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">")"</span>); count--; cond_signal(&amp;cv);</span><br><span class="line">  mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种可能面临的问题如下：</p><p><img src="../images/同步的问题.png"></p><p>我们需要对代码进行的改变有：</p><p>首先要将if改变为while，一直等待不满足的条件过去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!cond) &#123;</span><br><span class="line">  wait(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">assert(cond);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 互斥锁保证了在此期间条件 cond 总是成立</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>当其他的线程条件可能被满足的时候，应该广播信号而不是单播：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcast(&amp;cv);</span><br></pre></td></tr></table></figure><h3 id="信号量-1">信号量</h3><p>回到上面的更衣室管理问题，我们完全没有必要限制手环的数量，可以让更多的人进入更衣室。</p><p>管理员可以持有任意数量的手环，更衣室容量的上限。先进入更衣室的同学先得到，手环用完之后才需要等同学出来。</p><p>线程可以任意变出一个手环：1.把手环看成是令牌；2.得到令牌的可以进入执行；3、可以随时创建令牌。</p><p>这里说的手环=令牌=一个资源=信号量semaphore。</p><ul><li>P(&amp;sem) - prolaag = try + decrease; wait; down; in<ul><li>等待一个手环后返回</li><li>如果此时管理员手上有空闲的手环，立即返回</li></ul></li><li>V(&amp;sem) - verhoog = increase; post; up; out<ul><li>变出一个手环，送给管理员</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread-sync.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> <span class="built_in">fill</span>, empty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;empty);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    V(&amp;<span class="built_in">fill</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;<span class="built_in">fill</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    V(&amp;empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  assert(argc == <span class="number">2</span>);</span><br><span class="line">  SEM_INIT(&amp;<span class="built_in">fill</span>, <span class="number">0</span>);</span><br><span class="line">  SEM_INIT(&amp;empty, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    create(producer);</span><br><span class="line">    create(consumer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程和协程">线程和协程</h3><ul><li><p>进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p></li><li><p>线程：线程是指进程内的一个执行单元,也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p></li><li><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p></li><li><p>协程和线程的区别：</p><p>\1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。</p><p>\2) 线程进程都是同步机制，而协程则是异步。</p><p>\3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</p><p>4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</p><p>5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。</p><p>6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</p></li></ul><h2 id="操作系统的启动">4.1 操作系统的启动</h2><h3 id="引导扇区">4.1.1 引导扇区</h3><p>计算机的工作方式就是<strong>取址执行</strong>，如下图：</p><p><img src><img src="../images/计算机的工作方式.png" alt="计算机的工作方式"></p><p>计算机上电之后的执行是怎么样的呢？</p><p>对于x86PC，开机经过以下步骤：</p><ul><li>x86PC刚开机时CPU处于实模式（这个跟保护模式对应，实模式的寻址CS:IP（CS&lt;&lt;4 + IP），和保护模式不一样）</li><li>开机时，CS=0xFFFF;IP=0x0000</li><li>寻址0xFFFF0（ROM BIOS映射区）</li><li>检查RAM，键盘，显示器，软硬磁盘</li><li>将磁盘0磁道0扇区读入0x7c00处（<strong>0磁道0扇区就是操作系统的引导扇区</strong>）</li><li>设置cs=0x07c0，ip=0x0000（这个时候cs&lt;&lt;4+ip == ox7c00，也就是说要寻址到0x7c00处继续执行）</li></ul><p>引导扇区有512字节，就是启动设备的第一个扇区，开机的时候按住del键就可以进入启动设备设置界面，可以设置为光盘启动。启动设备信息被设置在CMOS中，第一个扇区上存放着开机后执行的第一段我们可以控制的程序。</p><p>下面是引导扇区代码：bootsect.s：</p><p>这里：BOOTSEG = 0x07c0</p><p>​ INITSEG = 0x9000</p><p>​ SETUPSEG = 0x9020</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">mov ax, #BOOTSEGmov ds, ax &#x2F;&#x2F;将ds设置为0x7c0</span><br><span class="line">mov ax, #INITSEGmov es, ax &#x2F;&#x2F;将es设置为0x9000</span><br><span class="line">mov cx, #256</span><br><span class="line">sub si, sisub di, di &#x2F;&#x2F;构成段内偏移来构建地址，ds:di&#x3D;ds&lt;&lt;4 + di &#x3D; 0x7c00, es:ei &#x3D; es&lt;&lt;4 + ei &#x3D; 0x90000</span><br><span class="line">rep movw &#x2F;&#x2F;移动256个字，512个字节，从0x7c00处移动到0x90000，腾出空间给后面用</span><br><span class="line">jmpi go, INITSEG &#x2F;&#x2F;当前程序已经在0x9000处，偏移地址是go，是一个地方，也就是跳到go处继续执行</span><br><span class="line"></span><br><span class="line">go:</span><br><span class="line">mov ax, cs &#x2F;&#x2F;cs &#x3D; 0x9000</span><br><span class="line">mov ds, axmov es, axmov ss, axmov sp, #oxff00</span><br><span class="line">load_setup:&#x2F;&#x2F;载入setup模块</span><br><span class="line">mov dx, #0x0000mov cx, #0x0002mov bx,#0x0200</span><br><span class="line">mov ax, #0x0200+SETUPLENint 0x13 &#x2F;&#x2F;BIOS中断</span><br><span class="line">jnc ok_load_setup</span><br><span class="line">mov dx, #0x0000</span><br><span class="line">mov ax, #0x0000 &#x2F;&#x2F;复位</span><br><span class="line">int 0x13</span><br><span class="line">jload_setup &#x2F;&#x2F;重读</span><br></pre></td></tr></table></figure><p>上面的load_setup代码中，0x13是BIOS读磁盘扇区的中断：ah=0x02-读磁盘，al=扇区数量(SETUPLEN=4)，ch=柱面号，cl=开始扇区，dh=磁头号，dl=驱动器号，es:bx=内存地址。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\操作系统启动盘.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">操作系统启动盘</div></center><p>首先int 0x13就是定位到BIOS读磁盘扇区，cx=#0x0002，低八位是从第二个扇区开始读，也就是上图中蓝色的部分。ax=#0x0200+SETUPLEN就是开始读磁盘，读的就是4个，刚好对应于setup的四个扇区。（其实也就是高八位ah，低八位al）。es:bx对应于段基址+段内偏移，bx=#0x0200，cs=0x9000，那么移动到的位置就是#0x90200</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ok_load_setup:&#x2F;&#x2F;载入setup模块</span><br><span class="line">mov dl, #0x00mov ax, #0x0800 &#x2F;&#x2F;ah&#x3D;8获得磁盘参数</span><br><span class="line">int 0x13mov ch, #0x00 mov sectors, cx</span><br><span class="line">mov ah, #0x03xor bh, bhint 0x10 &#x2F;&#x2F;读光标</span><br><span class="line">mov cx, #24mov bx, #0x0007 &#x2F;&#x2F;7是显示属性</span><br><span class="line">mov bp, #msg1mov ax, #1301int 0x10 &#x2F;&#x2F;显示字符</span><br><span class="line">mov ax, #SYSSEG &#x2F;&#x2F;SYSSEG&#x3D;0x1000</span><br><span class="line">mov es, ax</span><br><span class="line">call read_it &#x2F;&#x2F;读入system模块</span><br><span class="line">jmpi 0, SETUPSEG</span><br></pre></td></tr></table></figure><p>那么int 0x10处显示的是什么字符呢？它访问的是#msg1处的内容，这部分的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sectors: .word 0 &#x2F;&#x2F;磁道扇区数</span><br><span class="line">msg1: .byte 13, 10</span><br><span class="line">  .ascii &quot;Loading system...&quot;</span><br><span class="line">  .byte 13, 10, 13, 10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read_it: mov ax, escmp ax, #ENDSEGjb ok1_read</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">ok1_read:</span><br><span class="line">mov ax, sectors</span><br><span class="line">sub ax, sread &#x2F;&#x2F;sread是当前磁道已读取扇区数，ax未读扇区数</span><br><span class="line">call read_track &#x2F;&#x2F;读磁道</span><br></pre></td></tr></table></figure><p>可以转到setup执行了，jmpi 0, SETUPSEG。</p><h3 id="setup模块">4.1.2 setup模块</h3><p>setup模块将完成os启动前的设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start: mov ax, #INITSEG mov ds, axmov ah, #0x03</span><br><span class="line">xor bh, bh int 0x10&#x2F;&#x2F;取光标位置 mov ah, #0x88 int 0x15 mov [2], ax ...&#x2F;&#x2F;获取0x15扩展内存的大小，后面那句话将9000左移四位加2就是90002，也就是扩展内存数</span><br><span class="line">cli &#x2F;&#x2F;不允许中断</span><br><span class="line">mov ax, #0x0000cld</span><br><span class="line">do_move: mov es, ax add ax, #0x1000</span><br><span class="line">cmp ax, #0x9000 jz end_move</span><br><span class="line">mov ds, ax sub di, di&#x2F;&#x2F;di&#x3D;0</span><br><span class="line">sub si, si&#x2F;&#x2F;si&#x3D;0</span><br><span class="line">mov cx, #0x8000&#x2F;&#x2F;将这段空间留给操作系统用</span><br><span class="line">rep &#x2F;&#x2F;将system模块移到0地址</span><br><span class="line">movsw</span><br><span class="line">jmp do_move</span><br></pre></td></tr></table></figure><p>将setup移到0地址处后，操作系统要让硬件进入保护模式了，保护模式下int n和cs: ip解释不再和实模式一样。用GDT将cs: ip变为物理地址。</p><p><strong>GDT：全局描述表，是在保护模式下必不可少的一个数据结构。在实模式下，对一个内存地址的访问是通过segment:offset的方式进行的，也就是段基址左移四位+偏移地址就是我们要寻址的空间。</strong></p><p><strong>而到了保护模式时，内存的管理分为两种：段模式和页模式，其中页模式也是基于段模式的。在保护模式下，地址仍然采用的是段地址：偏移地址的寻址方式，只不过段的概念发生了变化。保护模式下段值仍然由原来的16位的cs、ds寄存器表示，但是他们此时只是一个索引，这些索引指向一个数据结构的表项，表项中定义了一个段的起始地址、界限、属性等内容，这个数据结构就是<span class="math inline">\(GDT\)</span>，每个表项就是描述符。</strong></p><p>切换到保护模式也就是从16位机（1M寻址空间）到32位机（4G寻址空间）。进入保护模式的代码如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\进入保护模式的代码.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">进入保护模式的代码</div></center><p>最重要的三句代码就是上面的标红的代码，首先将ax设置为最后一位是1，再将ax赋值给cr0，也就是将cr0寄存器的最后一位置为1，启动保护模式，jmpi 0，8将cs=8，用来检查gdt。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\保护模式下的地址翻译和中断处理.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">保护模式下的地址翻译和中断处理</div></center><p>上面的图片就是保护模式下的地址翻译，首先根据cs找到GDT表中的位置，GDT表中会有个映射，然后加上ip之后就是表示的物理地址。</p><p><strong>IDT：中断描述符表，将每个1异常或者中断向量分别与他们的处理过程联系起来。IDT表也是由8字节长描述符组成的一个数组。</strong>总之给定一个n，它会帮你找到中断处理函数的入口。</p><p>所以我们必须初始化一些映射在GDT表中，初始化的程序如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\GDT表的初始化.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">GDT表的初始化</div></center><p>所以上述的jmpi 0,8最终寻址的地方其实是0，</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\jmpi指令的移动.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">jmpi指令的移动</div></center><p>system模块（目标代码）中的第一部分代码是head.s，head.s是一段在保护模式下运行的代码，setup是进入保护模式，head是进入之后的初始化。下面的代码是32位的汇编，因为进入了保护模式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">startup_32:</span><br><span class="line">movl $0x10, %eax mov %ax, %ds mov %ax, %es</span><br><span class="line">mov %as, %fs mov %as, %gs &#x2F;&#x2F;指向gdt的0x10项(数据段)</span><br><span class="line">lss _stack_start, %esp &#x2F;&#x2F;设置栈（系统栈）</span><br><span class="line">call setup_idt</span><br><span class="line">call setup_gdt</span><br><span class="line">xorl %eax, %eax</span><br><span class="line"></span><br><span class="line">1: incl %eax</span><br><span class="line">movl %eax, 0x000000 cmpl %eax, 0x100000</span><br><span class="line">je lb &#x2F;&#x2F;0地址处和1M地址处相同(A20没有开启),就死循环</span><br><span class="line">jmp after_page_tables &#x2F;&#x2F;页表</span><br><span class="line">setup_idt: lea ignore_int, %edx</span><br><span class="line">movl $0x00080000, %eax  movw %dx, %ax</span><br><span class="line">leaa _idt, %edi movl %eax, (%edi)</span><br></pre></td></tr></table></figure><p>在设置也表之后呢，执行下面的语句：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\设置页表之后.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">设置页表之后</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/blog\source\_posts\操作系统\main函数.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">main函数</div></center><h2 id="系统调用的实现">4.2 系统调用的实现</h2><p>硬件提供了<strong>主动进入内核的方法</strong>，对于Intel x86来说，就是中断指令int，int指令将使CS中的CPL改成0，进入内核。这是用户程序发起的调用内核代码的唯一方式。</p><p>系统调用的核心：</p><ul><li>用户程序中包含一段包含int指令的代码</li><li>操作系统写中断处理，获取想调程序的编号。</li><li>操作系统根据编号执行相应代码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统笔记&quot;&gt;0. 操作系统笔记&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Boosting Graph Alignment Algorithms笔记</title>
    <link href="http://yoursite.com/2022/06/16/Boosting-Graph-Alignment-Algorithms%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/06/16/Boosting-Graph-Alignment-Algorithms%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-15T20:51:16.000Z</published>
    <updated>2022-06-17T02:41:04.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">1. 简介</h1><p>作者研究了我们研究了两种最先进的图形对齐算法，利用节点表示，CONE-Align以及GRASP算法，并以一个总体的模块化框架来描述它们。</p><p>网络对齐任务一般包含以下：</p><ul><li>embed：为每个节点创建embedding</li><li>align：对齐两个图的嵌入空间，使相似的节点在公共空间中彼此接近。</li><li>assign：通过一些线性分配算法来匹配变换后的嵌入数。</li></ul><p>作者研究了三种模块的对齐算法REGAL，CONE-Align以及GRASP，并对CONE-Align以及GRASP提出了改进。</p><p>一些参数：</p><p>graph alignment：给定两个无向图：<span class="math inline">\(G_1=(V_1,E_1)\)</span>和<span class="math inline">\(G_2=(V_2,E_2)\)</span>，图对齐就是将两个网络中的结点互相对齐。</p><p>node embedding：嵌入函数<span class="math inline">\(f(v) \in R^k\)</span>是节点v的表示。</p><p>graph laplacian：<span class="math inline">\(\mathcal{L}=I-D^{-1/2}AD^{-1/2}\)</span>,其中A是G的邻接矩阵，D是度矩阵<span class="math inline">\(D_{ii}=\sum_{j=1}^nA_{ij}\)</span>。这个矩阵的特征分解是<span class="math inline">\(\mathcal{L}= \Phi \Lambda \Phi^T\)</span>，其中<span class="math inline">\(\Lambda\)</span>是特征值的对角矩阵。其对角线，<span class="math inline">\(\left\{\lambda_1,...,\lambda_n\right\}\)</span>是L的谱，<span class="math inline">\(\Phi_{\mathcal{L}}=[\phi_1 \phi_2...\phi_n]\)</span>是特征向量矩阵。特征向量可以解释为为每个节点分配一个实值的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;1. 简介&lt;/h1&gt;
&lt;p&gt;作者研究了我们研究了两种最先进的图形对齐算法，利用节点表示，CONE-Align以及GRASP算法，并以一个总体的模块化框架来描述它们。&lt;/p&gt;
&lt;p&gt;网络对齐任务一般包含以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;embed：为
      
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Splitter笔记</title>
    <link href="http://yoursite.com/2022/06/07/Splitter%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/06/07/Splitter%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-06T16:05:03.000Z</published>
    <updated>2022-06-10T13:00:07.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="splitter笔记">Splitter笔记</h2><a id="more"></a><p>这篇论文的最大的亮点就是将一个结点基于自我网络的原则分解，每个表示编码节点在节点参与的不同本地社区中的角色。嵌入方法能否从真实图的重叠聚类结构中获益？</p><p>这里考虑的是无向图，<span class="math inline">\(G=(V,E)\)</span>，<span class="math inline">\(G[U]=(U,E \and U \times U)\)</span>为G的结点的子集的诱导图（这里的<span class="math inline">\(U \times U\)</span>可以理解为有<span class="math inline">\(U \times U\)</span>条边，当然这些边都得在原图中存在，所以取了个交集）。<span class="math inline">\(N_u=\left\{v;(u,v) \in E\right\}\)</span>就是结点u的邻居集合，而它的ego-net就是在其邻居诱导出来的图<span class="math inline">\(G[N_u]\)</span>，u的ego-net并不包含结点u本身。令<span class="math inline">\(\mathcal{A}\)</span>作为输入的非重叠聚类算法，返回的就是将结点集合V划分为t个不相交的集合<span class="math inline">\(A(G)=(V_1,V_2,...,V_t)\)</span>。</p><p>首先这个论文考虑了一个persona分解的东西。首先使用在一个节点的自我网络中（它的邻居和它们的诱导子图）中发现的集群作为基础来定义一个新的图，即人物图，<span class="math inline">\(G_P\)</span>。将新的图里面的结点称为personas，将G中每个原始节点的交互划分为几个语义子组，这些子组捕获其网络行为的不同组件。</p><p>persona decomposition要做的就是将原始图G转换为persona graph <span class="math inline">\(G_P\)</span>：</p><ul><li>对于每个节点<span class="math inline">\(u \in V\)</span>,使用聚类算法<span class="math inline">\(\mathcal{A}(G[N_u])=\left\{N_u^1,N_u^2,...,N_u^{t_u}\right\}\)</span>，其中<span class="math inline">\(t_u=np_{\mathcal A}(G[N_u])\)</span>。</li><li>创建一个personas集合<span class="math inline">\(V&#39;\)</span>，在V中的每个节点<span class="math inline">\(v_0\)</span>对应在<span class="math inline">\(V_P\)</span>中的<span class="math inline">\(t_{v_0}\)</span>个personas（也就是<span class="math inline">\(v_0\)</span>的ego-net的分割数），表示为<span class="math inline">\(v_i\)</span>，<span class="math inline">\(i=1,...,t_{v_0}\)</span>。</li><li>为personas之间添加边。如果<span class="math inline">\((u,v)∈E,v∈N_u^i,v∈N_v^j\)</span>，那么添加一个边<span class="math inline">\((u_i,v_j)\)</span>到<span class="math inline">\(E_P\)</span>中。</li></ul><p>构造的persona graph具有以下的性质：</p><ul><li>每个位于<span class="math inline">\(G_P\)</span>中的结点都是来自原始网络中的结点，分割为一个或者多个personas。</li><li>原始图中的每个节点都可以映射到其相应的角色。但是<span class="math inline">\(G_P\)</span>的社区结构和原始网络比起来很不一样。</li></ul><p>上面创建的<span class="math inline">\(G_P\)</span>确实可以给每个结点创建多个embeddings，但是存在的问题就是创建的<span class="math inline">\(G_P\)</span>可能与原始网络非常的不一样，可能会存在许多不相连的组件，即使他们在原始网络中是相连的。</p><p>作者在这里提出了两个改进的策略：</p><p>（1）提出添加约束条件，persona表示不仅仅能预测在<span class="math inline">\(G_P\)</span>中其周围的personas，也能够预测原始结点。给定一个persona <span class="math inline">\(v_i\)</span>，作者提出要求它的表示包括对原始图G中的节点<span class="math inline">\(v_o\)</span>的依赖性：<span class="math inline">\(Pr(v_0| \Phi_{G_P(v_i)})\)</span>。</p><p>为了控制图正则化的强度，引入参数λ，那么就产生了下述的优化问题：</p><p><img src="../images/正则优化方程.png"></p><p>（2）作者提出来将v的personas表示<span class="math inline">\(\Phi_{G_P}(v)\)</span>依赖于原始的表示<span class="math inline">\(\Phi_G(v)\)</span>通过初始化作为一个先验知识。初始化所有的personas为<span class="math inline">\(R^d\)</span>中的同一个位置，结合正则表达的形式，将角色嵌入约束，使其表现为单个实体的内聚部分。</p><p>最后整个的算法流程为：</p><p><img src="../images/算法流程-16545859038562.png"></p><p>首先创建persona graph，初始化<span class="math inline">\(\Phi_G\)</span>，遍历所有结点<span class="math inline">\(v_0\)</span>及其personas，初始化<span class="math inline">\(v_0\)</span>的第j个persona。</p><h2 id="persona-graph的创建">persona graph的创建</h2><p>这篇论文中提出的ego-net的分割方法也是Google research发表的在2017 KDD会议上的论文。文章架构分为两步：首先是局部的ego-net分析，然后是全局的网络划分。</p><p><img src="../images/ego-splitting架构流程.png"></p><p>这里说的是有三个重叠的区域：<span class="math inline">\(\left\{a,b,c\right\},\left\{c,d,e,f\right\},\left\{f,g,h\right\}\)</span>。当我们要由c的邻居生成的图的时候，c的两个社区是很容易发现的，它们完全对应于这两个相互连接的组件<span class="math inline">\(\left\{a,b\right\}\)</span>以及<span class="math inline">\(\left\{d,e,f\right\}\)</span>。所以通过使用连接的组件，论文提出的方法能够检测出即使只有一个单节点c，但是c实际上有两个personas，并且这会将c拆分为两个不同的节点：<span class="math inline">\(c_1\)</span>和<span class="math inline">\(c_2\)</span>。注意到除了节点c和节点f，其他的结点是只有一个单独的社区。我们的算法保留这些结点在特定的persona，比方说<span class="math inline">\(d_1\)</span>是在d的case中的。</p><p>经过第一个局部的步骤之后，在第二阶段的全局步骤中，连接组件算法可以轻松的检测到图的重叠社区结构，通过将persona graph划分为集群<span class="math inline">\(\left\{a_1,b_1,c_1\right\},\left\{c_2,d_1,e_1,f_1\right\},\left\{f_2,g_1,h_1\right\}\)</span>，这些也就是在原始图中的重叠集群。</p><p>在重叠社区发现问题中，目标就设计算法<span class="math inline">\(R\)</span>，输入的是无向的图<span class="math inline">\(G=(V,E)\)</span>，并且输出一个集合<span class="math inline">\(S&#39;=R(G)\)</span>，是节点集合V的子集，我们称之为聚集，任意两个聚集之间不能相交。</p><p>在一个簇重建公式中，我们假设有一组节点的子集S，我们称之为ground-truth集群，算法的任务是恢复这样的簇。为了使检测问题有意义，S和G必须以一种能够从G中提取关于S的信息的方式相关联。</p><p>这篇论文设计了两种不同的场景评估算法。首先是标记的数据集，其中图带有元数据，识别已知的社区和我们想要检索的节点子集。第二种场景是生成模型，其中一个随机过程从一组集群中生成一个图，而算法需要恢复那些只能访问该图的集群。</p><h2 id="聚类检测问题">聚类检测问题</h2><p>给定一个ground truth集群<span class="math inline">\(C \in V\)</span>以及重构的集群<span class="math inline">\(C&#39; \in V\)</span>，我们定义精度为<span class="math inline">\(P(C&#39;,C)=|C \and C&#39;|/|C&#39;|\)</span>,以及召回：<span class="math inline">\(R(C&#39;,C)=|C \and C&#39;|/|C|\)</span>，F-1 score定义为：</p><p><img src="../images/F-1分数.png"></p><p>作者这里用两个标准评价集群检测：</p><ul><li><p>F-1 score：给定一个ground-truth 集群S和一个发现的集群S'，F1评分如下：</p><p><img src="../images/评价1.png"></p></li><li><p>归一化互信息(NMI)。</p></li></ul><p>给定一幅图<span class="math inline">\(G=(V,E)\)</span>以及节点子集<span class="math inline">\(U\)</span>，我们定义诱导图为<span class="math inline">\(G[U]=(U,E \and U \times U)\)</span>。对于一个结点<span class="math inline">\(u \in V\)</span>，u的邻域由连接到它的结点组成<span class="math inline">\(N_u=\left\{v;(u,v) \in E\right\}\)</span>，u的ego-net由在邻域上诱导的图组成<span class="math inline">\(G[N_u]\)</span>。自我网表示来自图连接上的节点u的局部视图(注意，u的自我网不包括节点u)。</p><p>有两个非重叠的聚类算法：局部聚类算法<span class="math inline">\(A^l\)</span>以及全局聚类算法<span class="math inline">\(A^g\)</span>，ego-splitting算法处理一个输入图并且输出一个聚类的集合<span class="math inline">\(S&#39;\)</span>：</p><ul><li>第一步：对于每个节点使用局部聚类算法来分割u的ego-net，令<span class="math inline">\(A^l(G[N_u])=\left\{N_u^1,N_u^2,...,N_u^{t_u}\right\}\)</span>，其中<span class="math inline">\(t_u=np(A^l,G[N_u])\)</span></li><li>第二步：创建personas集合。每个节点u将会跟在personas集合<span class="math inline">\(V&#39;\)</span>中的<span class="math inline">\(t_u\)</span>个personas关联，表示为<span class="math inline">\(u_i\)</span></li><li>第三步：在personas之间添加边。如果<span class="math inline">\((u,v)∈E,v∈N_u^i\)</span>并且<span class="math inline">\(u∈N_v^j\)</span>，那么就添加一条边<span class="math inline">\((u_j,v_i)\)</span>到<span class="math inline">\(E&#39;\)</span>中。</li><li>第四步：在<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>中使用全局的聚类算法，并且获得V'的分割S''。</li><li>第五步：对于集合<span class="math inline">\(C&#39;∈S&#39;&#39;\)</span>，<span class="math inline">\(C(C&#39;)=\left\{u \in V | \exist i \ s.t. u_i \in C&#39;\right\}\)</span></li></ul><p>通俗的讲，以上几个步骤就是下面的：首先根据全局的网络遍历所有的节点得到其ego-net（说白了也就是一阶邻居，不包含节点本身），然后找到这些个一阶邻居的分割，分成了多少个就代表这个节点有多少个personas，在新的persona graph添加边首先节点u和节点v得在原始网络中存在边，其次v在u的第i个邻域中，u在v的第j个邻域中，那么就添加ui和vj的边。就比方说上图中的ef连边，他是为了保证原本的连通性不受影响。第四步是使用全局的聚类算法<span class="math inline">\(A^g\)</span>到<span class="math inline">\(G&#39;\)</span>中，可以获得划分<span class="math inline">\(S&#39;&#39;\)</span>，</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/步骤1-3-16546792208425.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">步骤1-3</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/步骤4-5-16546792310987.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">步骤4-5</div></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;splitter笔记&quot;&gt;Splitter笔记&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="研究工作" scheme="http://yoursite.com/tags/%E7%A0%94%E7%A9%B6%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Towards Improving Embedding Based Models of</title>
    <link href="http://yoursite.com/2022/06/02/Towards-Improving-Embedding-Based-Models-of/"/>
    <id>http://yoursite.com/2022/06/02/Towards-Improving-Embedding-Based-Models-of/</id>
    <published>2022-06-02T14:52:16.000Z</published>
    <updated>2022-06-08T09:07:27.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用伪锚定改进基于嵌入的社会网络对齐模型">利用伪锚定改进基于嵌入的社会网络对齐模型</h1><p><a id="more"></a></p><p>现在的embedding方式可能会造成用户向量的过度接近，这个文章通过伪锚定节点来将结果向量分割的更开。进一步提出了一种元学习算法来指导学习过程中伪锚定嵌入的更新。</p><p>传统的方式就是把潜在的节点d的对应节点映射到一个低维度的子空间中，然而，由于密集局部结构中节点的数值表示彼此非常相似，因此很难将d与团内的邻居区分开来 特别是当没有足够的锚点来为对齐提供额外的信息时。</p><p>解决上述问题的一个直观的想法是通过强制节点嵌入在嵌入空间中保持更广泛的距离来限制“模糊区域”中的节点数量，从而 彼此之间更有区别。提出了一个双重策略：（1）首先我们通过直接连接到一些真正的锚来植入伪锚。在保留结构的目标下，我们希望伪锚定节点对真实的anchors和其一阶邻居所组成的局部结构有更多的影响，但是对远处的结点影响小。锚的一阶邻域的扩大群将形成一个更紧凑的团，从而更好地区分其他远离锚的拓扑节点。这样的话就能使得学习到的向量分割更远。（2）第二要解决的就是伪锚定节点在嵌入空间中的适当位置。在学习的过程中，使用了基于元学习的一种微调的策略，其动机是学习一个更新方向，可以在学习过程中驱动伪锚的嵌入远离“模糊区域”。特别地，我们使网络间的伪锚点关闭，而真实锚点的一阶邻居离它们更远。由于锚点的一阶邻居位于“模糊区域”附近，将伪锚点远离它们可以确保伪锚点向正确的方向更新。同时，这一策略可以缓解植入伪锚可能引入的锚周围扩大群的“过于接近”问题。在观察到的锚点和先验知识（从具有丰富标记数据的支持数据集学习）的监督下，在模型学习过程中调整伪节点的位置。最后，可以获得一个更有区别的嵌入空间，用于社交网络的用户对齐。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/模型结构框架.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1 模型结构</div></center><p>定义<span class="math inline">\(\Phi_{v_i}:v_i \to \vec u_i\)</span>表示在结构相似的假设下的<span class="math inline">\(v_i\)</span>结点的嵌入，网络嵌入的问题就是找到一个映射<span class="math inline">\(f_m(\vec u_i^s, \vec u_j^t) ∈ \left\{0,1\right\}\)</span>。</p><p>我们提出“植入”伪锚点作为指导伪锚点嵌入学习的手段，以避免锚点附近的节点嵌入紧密聚集 。通过两阶段来实现：首先是通过伪锚点的干预，将与真实锚点直接连接的节点拉离模糊区域，远离模糊区域。第二种方法是利用元学习来调整伪锚点的更新方向。这可以确保植入的伪锚点在学习过程中不会接近模糊区域，并可以再次避免在真实锚点周围形成的“过接近”嵌入 植入的假锚点的介绍。</p><p>其关键思想是植入伪锚点，对真实锚点周围的局部结构施加更大的影响，而对嵌入空间中远离锚点的节点的影响较小。然后，在伪锚点的拉力作用下，锚点附近的节点之间的推断嵌入距离更远(见图1b部分)。因此，“过度依赖” 可以缓解锚定节点周围的“损失”现象。</p><p>进一步解释为何植入伪锚定节点会导致在真实锚点的高阶邻域中节点嵌入的是均匀分布的，我们采用了典型的结构保留嵌入算法的学习过程。这些算法的目标是倾向于将某个节点vi及其邻近节点尽可能接近地嵌入到局部结构中，同时保持<span class="math inline">\(v_i\)</span>远离随机采样节点。这里我们将<span class="math inline">\(v_i\)</span>的相邻节点和随机抽样节点分别定义为<span class="math inline">\(context(v_i)\)</span>和<span class="math inline">\(neg(v_i)\)</span>，对于节点<span class="math inline">\(v_i,v_j∈\left\{context(v_i) \or neg(v_i)\right\}\)</span>，他们之间的结构保持目标函数为：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/结构保持目标函数.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图2 模型结构</div></center><p>其中<span class="math inline">\(\vec u_i\)</span>和<span class="math inline">\(\vec u_j\)</span>是anchor links的embeddings，<span class="math inline">\(L_j^i\)</span>的值取决于<span class="math inline">\(v_j\)</span>是否为<span class="math inline">\(v_i\)</span>的上下文节点：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/L的定义.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图3 L函数的定义</div></center><p>我们可以计算出对<span class="math inline">\(\vec u_i\)</span>来更新模型：</p><p><img src><img src="../images/梯度更新.png" alt="梯度更新"></p><p>对于一个特定的anchor node <span class="math inline">\(v_a\)</span>,<span class="math inline">\(\vec u_a\)</span>的更新准则为：</p><p><img src="../images/ua向量更新.png"></p><p>注意<span class="math inline">\(v_a\)</span>和<span class="math inline">\(v_i\)</span>是可以交换的，因为这里<span class="math inline">\(v_a\)</span>是要被更新的目标节点。</p><p>然后我们考虑图2中那样的植入伪锚定节点，其中<span class="math inline">\(v_a\)</span>是锚定节点，<span class="math inline">\(\left\{p_1,p_2\right\}\)</span>是被植入的节点。锚定节点<span class="math inline">\(v_a\)</span>必须满足与节点b的一阶近似，也需要满足与伪锚定节点的一阶近似。因此，<span class="math inline">\(\left\{p_1,p_2 \right\}\)</span>应该包含在<span class="math inline">\(v_a\)</span>的上下文中，更新<span class="math inline">\(\vec u_a\)</span>变为：</p><p><img src="../images/ua更新.png"></p><p>与未植入假锚点的情况相比，<span class="math inline">\(v_a\)</span>的embedding将会如同图2中所示的那样从a转移到a'，其中转移的<span class="math inline">\(\Delta \vec u_a\)</span>由上面两个式子相减：</p><p><img src="../images/ua变化.png"></p><p>由上面的公式，为了保持锚点a和p1，p2之间的一级接近性，<span class="math inline">\(\vec u_a\)</span>将会接近<span class="math inline">\(\vec u_{p_1}\)</span>和<span class="math inline">\(\vec u_{p_2}\)</span>。锚定节点<span class="math inline">\(v_a\)</span>嵌入的转移也会影响锚定节点<span class="math inline">\(v_a\)</span>的一阶邻居节点<span class="math inline">\(v_b\)</span>。基于图2中的结构以及公式3中的更新规则，<span class="math inline">\(v_b\)</span>的转移被定义为：</p><p><img src="../images/vb转移.png"></p><p>同样的，<span class="math inline">\(v_c\)</span>的转移可以表示为：</p><p><img src="../images/vc转移.png"></p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/植入伪锚定节点嵌入的移动.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图2 植入伪锚定节点嵌入的移动</div></center><p>A图表示的是经过植入后的网络结构，B图表示的是植入伪锚定节点之前的embedding分布，C图是植入伪锚定节点之后的embedding分布。</p><p>一般来说，由伪锚点引起的拉力效应会通过锚点的高阶邻域传播出去。随着近似的阶次的上升，移动的数量将相应地减少。因此，远离锚点的节点将被移得更少。在此基础上，我们可以得出结论，伪锚点对相应的锚点节点和相邻节点有较大的影响 在他们附近。由于锚点周围的节点被伪锚点拉走，因此高阶邻居的嵌入将分布更均匀，因此更容易区分。</p><p>随着植入伪锚的效果和潜在的好处的解释，剩下的关键问题是如何正确地首先放置伪锚，然后在学习过程中进行更新过程。不难注意到，不正确地更新伪锚点（例如，将它们移动到“模糊区域”）将导致不希望的嵌入结果(例如，所有节点e 嵌入在一个“过紧密”的集群中)，进而对对齐任务造成负面影响。为此，我们试图确定植入的伪锚在学习专业中的正确位置 过程。具体来说，我们介绍了一种元学习方法来控制伪锚点的更新方向，如下一节所述。</p><h2 id="伪锚定节点的微调">伪锚定节点的微调</h2><p>为了使得植入的伪锚定节点得到适当的控制，提出了元学习的策略，包含以下两步。首先是确保伪锚点的更新方向远离“模糊区域”。第二种是避免植入的伪锚在锚周围造成的“过度接近”嵌入。为了实现这些目标，我们首先使用一个基于元学习的算法，从一些包含丰富标记锚点的支持数据集中学习一些关于更新的先验知识。然后利用先验知识对每个嵌入学习epoch的伪锚点进行微调。通过微调和嵌入学习步骤的交错迭代，我们期望以适当控制的方式更新伪锚点，从而产生更均匀的分布的嵌入空间中提供了证明。下面，我们将提供该算法的细节。</p><p>给定一个特殊的anchor用户<span class="math inline">\(v_a\)</span>，令<span class="math inline">\(P_a=\left\{p_a^0,p_a^1,...,p_a^n\right\}\)</span>为与<span class="math inline">\(v_a\)</span>对应的植入的伪锚定节点。对于一个特定的伪锚定节点<span class="math inline">\(p_a^i\)</span>，我们定义它的更新方向为：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/伪锚定节点的更新方向.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图4 伪锚定节点的更新方向</div></center><p>其中<span class="math inline">\(W=\left\{w^0,w^1,...,w^n\right\}\)</span>用于控制伪锚点更新方向的可学习参数集，<span class="math inline">\(nei(v_a)\)</span>表示<span class="math inline">\(v_a\)</span>的一阶邻居，<span class="math inline">\(g\)</span>表示激活函数。</p><p>根据图4中的公式，连接到相同的真实的anchor将会有相同的“基方向”<span class="math inline">\(\vec u_a + \sum_{j∈nei(v_a)} \vec u_j\)</span>控制更新的方向。通过对“基方向”的系数<span class="math inline">\(w^i\)</span>设置不同的值并迭代应用，可以得到不同的伪锚更新方向。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="../images/控制方向的更新.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图5 控制方向的更新</div></center><p>如图5所展示的那样，<span class="math inline">\(p_a^1\)</span>和<span class="math inline">\(p_a^2\)</span>是植入到相同的anchor <span class="math inline">\(v_a\)</span>的伪锚定节点，利用相应的参数<span class="math inline">\(w^1\)</span>和<span class="math inline">\(w^2\)</span>应用“基方向”两次，确定更新方向。我们可以看到的是，虽然对于更新<span class="math inline">\(p_a^1\)</span>和<span class="math inline">\(p_a^2\)</span>的两个迭代方向是一样的，但是由于<span class="math inline">\(w^1\)</span>和<span class="math inline">\(w^2\)</span>控制的不同的更新步长将会对不同的伪锚定节点产生不同的更新方向。</p><p>当标记的锚点不足时，学习这样的W是具有挑战性的，这在许多情况下通常是正确的。因此我们尝试利用来自其他网络中的数据，其中的anchors可以被轻松的获得为学习W的数据集<span class="math inline">\(S=\left\{S_1,S_2,...,S_k\right\}\)</span>，相应的W可以被更新为：<span class="math inline">\(W=W-\eta_1 \bigtriangledown f(U_{S_i})\)</span>，其中<span class="math inline">\(U_{S_i}\)</span>是<span class="math inline">\(S_i\)</span>的嵌入空间，<span class="math inline">\(\eta\)</span>是学习率。</p><p>然后，我们将学习到的W转移到查询集Q（具有较少锚定标签的数据集）。我们根据转移的W（从支持集学习）将目标函数定义为：</p><p><img src="../images/目标函数.png"></p><p>其中<span class="math inline">\(\vec u^n_{p_a},\vec u_j∈U_Q\)</span>。对于初次迭代，我们使用转移的W来初始化<span class="math inline">\(f(U_Q;W)\)</span>中的<span class="math inline">\(\Delta \vec p_a^n(v_a,W)\)</span>。W可以随后被迭代的更新为：<span class="math inline">\(W=W-\eta_2 \bigtriangledown \vec p_a^n(v_a,W)\)</span>。最后，我们得到了伪锚点的更新方向。算法1总结了微调伪锚点的关键步骤。</p><p><img src="../images/算法流程.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;利用伪锚定改进基于嵌入的社会网络对齐模型&quot;&gt;利用伪锚定改进基于嵌入的社会网络对齐模型&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DeepLink</title>
    <link href="http://yoursite.com/2022/05/27/DeepLink/"/>
    <id>http://yoursite.com/2022/05/27/DeepLink/</id>
    <published>2022-05-27T10:16:59.000Z</published>
    <updated>2022-06-01T02:04:35.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deeplink">DeepLink</h1><p><a id="more"></a></p><p>deeplink主要做了以下的事情：</p><p>（1）它对网络进行采样，在保持网络结构的同时生成训练“语料库”。</p><p>（2）网络中的每个节点通过网络嵌入被表示为低维空间中的一个向量；</p><p>（3）然后将锚节点输入深度神经网络，训练非线性变换，使用户跨网络对齐；</p><p>（4）DeepLink采用双学习过程来提高身份链接性能，提高监督训练算法。</p><p>首先在给定的一对网络a和一对网络B之间预先训练两个初步的映射函数，也就是<span class="math inline">\(\Phi(A \to B)\)</span>以及<span class="math inline">\(\Phi^{-1}(B \to A)\)</span>在没有标签（对齐）的锚节点上使用自动映射。然后，用户身份链接可以形式化为一个双重学习游戏：在网络A中的一个铆钉节点的嵌入表示<span class="math inline">\(\vec a\)</span>可以使用<span class="math inline">\(\Phi(A \to B)\)</span>得到一个在B中的对应向量<span class="math inline">\(\vec b&#39;\)</span>。随后向量<span class="math inline">\(\vec b&#39;\)</span>与其真实的向量<span class="math inline">\(\vec b\)</span>相比较，和A被通知<span class="math inline">\(\Phi(A \to B)\)</span>是否是一个高质量的映射，通过使用<span class="math inline">\(\Phi^{-1}(B \to A)\)</span>将<span class="math inline">\(\vec b&#39;\)</span>映射回去得到<span class="math inline">\(\vec a&#39;\)</span>。网络A测量<span class="math inline">\(\vec a\)</span>和<span class="math inline">\(\vec a&#39;\)</span>之间的相似度然后反馈给B。游戏也可以从B中的一个节点开始，并在B空间中嵌入向量。本质上，随着锚定节点的增加，这两个映射函数得到了越来越多的改进。</p><p><img src="/2022/05/27/DeepLink/deepwalk框架图.png"></p><p>经过随机游走采样得到语句<span class="math inline">\(S_{u_i}^r\)</span>之后，r表示第r轮次，deeplink使用skip-gram模型来更新embedding。</p><p><img src="/2022/05/27/DeepLink/skipgram优化方程.png"></p><p>这个公式就是skipgram的优化方程了，网络序列化的一个很重要的概念。w是滑动窗口的大小，条件概率的定义如下：</p><p><img src="/2022/05/27/DeepLink/条件概率公式.png"></p><p>采用负采样后的公式为：</p><p><img src="/2022/05/27/DeepLink/负采样-16538958028732.png"></p><p>在得到两个网络的embedding之后，deeplink通过MLP学习两个网络之间的映射函数，给定一组标记的anchor node pairs <span class="math inline">\((u_i,u_j)\)</span>以及其向量<span class="math inline">\((v(u_i),v(u_j))\)</span>,deeplink学习映射<span class="math inline">\(\Phi(v(u_i))\)</span>通过最小化如下函数：</p><p><img src="/2022/05/27/DeepLink/优化方程.png"></p><p>假设A和B是网络节点的向量矩阵，那么优化方程为：</p><p><img src="/2022/05/27/DeepLink/对齐的优化方程.png"></p><p>我们要学习的就是W和b，W是权重矩阵，b是偏置。</p><p>为了充分利用先验知识的anchor nodes，使用一套dual-learning的机制。假设我们有两个弱映射函数Φ和<span class="math inline">\(\Phi^{-1}\)</span>例如，用部分锚节点进行预训练-它们可以将向量从Gs投射到Gt，反之亦然。然后，我们改进了两个映射函数</p><ul><li>无监督UIL预训练：</li></ul><p>如果我们首先得到在<span class="math inline">\(G^s\)</span>中的anchor node的向量<span class="math inline">\(u_b\)</span>，先把他通过<span class="math inline">\(v&#39;(u_b)=\Phi(v(u_b))\)</span>映射得到<span class="math inline">\(v&#39;(u_b)\)</span>，然后再映射回来通过<span class="math inline">\(\Phi^{-1}(v&#39;(u_b))\)</span>来得到映射<span class="math inline">\(v&#39;&#39;(u_b)\)</span>。请注意，在这个无监督的学习过程中不需要标签，因此标记锚节点和未标记锚节点之间没有差异。这个自动映射的损失是基于<span class="math inline">\(v(u_b)\)</span>和<span class="math inline">\(v&#39;&#39;(u_b)\)</span>之间的差值来计算的。我们使用同样的方法对Gt→Gs模型进行预训练。在这个无监督的预训练之后，我们有两个弱映射函数Φ和<span class="math inline">\(Φ^{-1}\)</span>，它们将在下一步中得到进一步的改进。</p><ul><li>有监督的UIL学习</li></ul><p>利用标记的锚定节点，通过玩双重学习游戏来改进映射函数Φ和<span class="math inline">\(Φ^{-1}\)</span>。具体的，假设h个batches和n个anchor nodes，其中每个batch有<span class="math inline">\(\lfloor n/h \rfloor\)</span>个标记的节点。每个batch组成了一个episode，其中一个anchor node <span class="math inline">\(u_a\)</span>表示一个状态<span class="math inline">\(s_a\)</span>。请注意，在这种情况下的状态转换是确定性的，当前状态的概率为1转移到下一个状态（锚节点），该操作被定义为选择一个锚节点。我们使用<span class="math inline">\(v(u_a)\)</span>和<span class="math inline">\(v&#39;(u_a)\)</span>分别表示<span class="math inline">\(u_a\)</span>在网络<span class="math inline">\(G^s\)</span>和网络<span class="math inline">\(G^t\)</span>中的向量表示。给定一个batch的anchor nodes，两个mapping func需要尽力根据批处理中映射锚定节点的奖励，对齐两个用户潜在空间。</p><p>对于一个从在<span class="math inline">\(G^s\)</span>中的<span class="math inline">\(u_a\)</span>开始的游戏。我们使用<span class="math inline">\(\Phi\)</span>来映射它的向量到<span class="math inline">\(G^t\)</span>的空间中，并且搜索其k个最邻近的向量<span class="math inline">\(S(v&#39;(u_a))=Top(\Phi(v(u_a)))\)</span>，包含Gt中锚定节点最相似的k个嵌入向量。这里，k个向量是真实用户的候选，在更多锚节点上训练，成功链接的概率更高。在<span class="math inline">\(G^t\)</span>中的agent B随后可以计算一个奖励<span class="math inline">\(r^i_{s,t}\)</span>：</p><p><img src="/2022/05/27/DeepLink/奖励.png"></p><p>寻找并且平均topk的<span class="math inline">\(\Phi(v(u_a))\)</span>的原因在于映射函数很难精确地匹配<span class="math inline">\(u_a∈G^t\)</span>(向量<span class="math inline">\(v&#39;(u_a)\)</span>）的实恒等式，然而，它有一个更大的概率在前k最近的k中包含真实的恒等式。</p><p>直观的，我们也可以计算<span class="math inline">\(v&#39;(u_i)\)</span>的映射返回<span class="math inline">\(G^s\)</span>，并且利用映射的二重性来产生第二个奖励<span class="math inline">\(r^a_{(t,s)}\)</span>也就是<span class="math inline">\(\Phi^{-1}(v&#39;(u_i))\)</span>与<span class="math inline">\(v(u_a)\)</span>之间的平均相似度。</p><p><img src="/2022/05/27/DeepLink/奖励1.png"></p><p>因此，动作值<span class="math inline">\(r^a\)</span>对于一个选定的用户<span class="math inline">\(u_a\)</span>来说就是<span class="math inline">\(r^a_{s,t}, r^a_{t,s}\)</span>的线性组合，表明映射函数正确实身份链接的估计概率。特别是，它利用两个映射函数的对偶性来指导锚定节点的训练过程。期望的奖励<span class="math inline">\(E[r_h]\)</span>在第h轮的batch是：</p><p><img src="/2022/05/27/DeepLink/奖励期望.png"></p><p>由于这个游戏的奖励可以被认为是<span class="math inline">\(v&#39;(u_a),v(u_a),\Phi,\Phi^{-1}\)</span>的函数，我们可以在最大化期望奖励的两个映射函数中优化参数W和b，其中<span class="math inline">\(\gamma^h_{s,t}\)</span>以及<span class="math inline">\(\gamma^h_{t,s}\)</span>是使用政策梯度法的贴现率。</p><p>我们也使用同样的方法从另一个方向训练深度Gs→Gt，以缓解过拟合。根据经验，我们发现平均连锁结果是有帮助对齐的 有效地连接两个网络。</p><p>最终本文的deeplink算法为：</p><p><img src="/2022/05/27/DeepLink/deeplink算法.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;deeplink&quot;&gt;DeepLink&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Graph Embedding</title>
    <link href="http://yoursite.com/2022/05/25/Graph-Embedding/"/>
    <id>http://yoursite.com/2022/05/25/Graph-Embedding/</id>
    <published>2022-05-24T16:02:53.000Z</published>
    <updated>2022-05-30T02:06:18.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="networkx库介绍">1. networkx库介绍</h1><p><a id="more"></a></p><p>&lt;! -- more --&gt;</p><h2 id="图数据结构">1.1 图数据结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line">G = nx.Graph()</span><br></pre></td></tr></table></figure><p>这里定义的图G是一组节点（顶点）和已经识别的节点对（边）的集合。节点可以是任意的可哈希的对象，例如文本字符串、图像等。图的初始化的源码解析如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Initialize a graph with edges, name, or graph attributes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        incoming_graph_data : input graph (optional, default: None)</span></span><br><span class="line"><span class="string">            Data to initialize graph. If None (default) an empty</span></span><br><span class="line"><span class="string">            graph is created.  The data can be an edge list, or any</span></span><br><span class="line"><span class="string">            NetworkX graph object.  If the corresponding optional Python</span></span><br><span class="line"><span class="string">            packages are installed the data can also be a NumPy matrix</span></span><br><span class="line"><span class="string">            or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        attr : keyword arguments, optional (default= no attributes)</span></span><br><span class="line"><span class="string">            Attributes to add to graph as key=value pairs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        See Also</span></span><br><span class="line"><span class="string">        --------</span></span><br><span class="line"><span class="string">        convert</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples</span></span><br><span class="line"><span class="string">        --------</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.Graph(name='my graph')</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; e = [(1, 2), (2, 3), (3, 4)]  # list of edges</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.Graph(e)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Arbitrary graph attribute pairs (key=value) may be assigned</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.Graph(e, day="Friday")</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G.graph</span></span><br><span class="line"><span class="string">        &#123;'day': 'Friday'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure><h2 id="从文件中导入图数据">1.2 从文件中导入图数据</h2><p>一般使用最多的函数是read_edgelist,作用是从一个边的集合中来获取一幅图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_edgelist</span><span class="params">(path, comments=<span class="string">"#"</span>, delimiter=None, create_using=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                  nodetype=None, data=True, edgetype=None, encoding=<span class="string">'utf-8'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Read a graph from a list of edges.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    path : file or string</span></span><br><span class="line"><span class="string">       File or filename to read. If a file is provided, it must be</span></span><br><span class="line"><span class="string">       opened in 'rb' mode.</span></span><br><span class="line"><span class="string">       Filenames ending in .gz or .bz2 will be uncompressed.</span></span><br><span class="line"><span class="string">    comments : string, optional</span></span><br><span class="line"><span class="string">       The character used to indicate the start of a comment.</span></span><br><span class="line"><span class="string">    delimiter : string, optional</span></span><br><span class="line"><span class="string">       The string used to separate values.  The default is whitespace.</span></span><br><span class="line"><span class="string">    create_using : NetworkX graph constructor, optional (default=nx.Graph)</span></span><br><span class="line"><span class="string">       Graph type to create. If graph instance, then cleared before populated.</span></span><br><span class="line"><span class="string">    nodetype : int, float, str, Python type, optional</span></span><br><span class="line"><span class="string">       Convert node data from strings to specified type</span></span><br><span class="line"><span class="string">    data : bool or list of (label,type) tuples</span></span><br><span class="line"><span class="string">       Tuples specifying dictionary key names and types for edge data</span></span><br><span class="line"><span class="string">    edgetype : int, float, str, Python type, optional OBSOLETE</span></span><br><span class="line"><span class="string">       Convert edge data from strings to specified type and use as 'weight'</span></span><br><span class="line"><span class="string">    encoding: string, optional</span></span><br><span class="line"><span class="string">       Specify which encoding to use when reading file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    G : graph</span></span><br><span class="line"><span class="string">       A networkx Graph or other type specified with create_using</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; nx.write_edgelist(nx.path_graph(4), "test.edgelist")</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G=nx.read_edgelist("test.edgelist")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fh=open("test.edgelist", 'rb')</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G=nx.read_edgelist(fh)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fh.close()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G=nx.read_edgelist("test.edgelist", nodetype=int)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G=nx.read_edgelist("test.edgelist",create_using=nx.DiGraph)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Edgelist with data in a list:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; textline = '1 2 3'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fh = open('test.edgelist','w')</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d = fh.write(textline)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fh.close()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G = nx.read_edgelist('test.edgelist', nodetype=int, data=(('weight',float),))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(G)</span></span><br><span class="line"><span class="string">    [1, 2]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list(G.edges(data=True))</span></span><br><span class="line"><span class="string">    [(1, 2, &#123;'weight': 3.0&#125;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See parse_edgelist() for more examples of formatting.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    parse_edgelist</span></span><br><span class="line"><span class="string">    write_edgelist</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    Since nodes must be hashable, the function nodetype must return hashable</span></span><br><span class="line"><span class="string">    types (e.g. int, float, str, frozenset - or tuples of those, etc.)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''以下是调用'''</span></span><br><span class="line">self.G = nx.read_edgelist(filename,create_using=nx.DiGraph,nodetype=int)</span><br></pre></td></tr></table></figure><h1 id="网络嵌入方法实现">2. 网络嵌入方法实现</h1><h2 id="deepwalk">2.1 deepwalk</h2><p>随机游走突出一个字随机，以下是该模型的主要算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sequence</span><span class="params">(self, start_node)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    -&gt;用于类型提醒，返回的是列表</span></span><br><span class="line"><span class="string">    对单个节点进行随机游走算法</span></span><br><span class="line"><span class="string">    :param start_node:</span></span><br><span class="line"><span class="string">    :return: 一条随机游走序列</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    walk = [start_node]<span class="comment">#放的是节点的id</span></span><br><span class="line">    <span class="string">'''在邻居中取walk_length的节点，少了的话就取所有'''</span></span><br><span class="line">    <span class="keyword">while</span> len(walk) &lt; self.walk_length:</span><br><span class="line">        current_node = walk[<span class="number">-1</span>]</span><br><span class="line">        neighbors = list(self.g.neighbors(current_node))</span><br><span class="line">        <span class="keyword">if</span> len(neighbors) &gt; <span class="number">0</span>:</span><br><span class="line">            walk.append(random.choice(neighbors))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> walk</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_walk</span><span class="params">(self)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    随机游走算法，采集图中点的序列，超参数walk_length,window_size,大规模图可以并行优化</span></span><br><span class="line"><span class="string">    :return: 二维list，随机游走生成的序列</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    walks = []<span class="comment">#存放的是整个随机游走序列</span></span><br><span class="line">    <span class="keyword">for</span> walk_iter <span class="keyword">in</span> range(self.num_walks):</span><br><span class="line">        print(<span class="string">"当前游走次数：&#123;&#125;"</span>.format(walk_iter + <span class="number">1</span>))</span><br><span class="line">        node_list = list(self.g.nodes())</span><br><span class="line">        random.shuffle(node_list)<span class="comment">#随机打乱节点</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">            walks.append(self.get_sequence(node))</span><br><span class="line">    <span class="keyword">return</span> walks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self)</span>:</span></span><br><span class="line">    t = time.time()</span><br><span class="line">    print(<span class="string">"开始随机游走"</span>)</span><br><span class="line">    sentence = self.random_walk()</span><br><span class="line">    corpus = []</span><br><span class="line">    <span class="comment">#将sentence转换为str类型</span></span><br><span class="line">    <span class="keyword">for</span> idx, each <span class="keyword">in</span> enumerate(sentence):</span><br><span class="line">        corpus.append(list(map(str, sentence[idx])))</span><br><span class="line">    print(<span class="string">"随机游走结束，开始训练！"</span>)</span><br><span class="line">    word2vec = Word2Vec(</span><br><span class="line">        sentences=corpus,</span><br><span class="line">        vector_size=self.dim,</span><br><span class="line">        window=self.window_size,</span><br><span class="line">        min_count=<span class="number">0</span>,</span><br><span class="line">        workers=<span class="number">0</span>,</span><br><span class="line">        sg=<span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> self.g.nodes():</span><br><span class="line">        self.vectors[node] = word2vec.wv[str(node)]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"模型训练完成！算法总共消耗时间：&#123;&#125;秒"</span>.format(round(time.time() - t, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure><h2 id="node2vec">2.2 node2vec</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;networkx库介绍&quot;&gt;1. networkx库介绍&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="研究工作" scheme="http://yoursite.com/tags/%E7%A0%94%E7%A9%B6%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>java基础补充</title>
    <link href="http://yoursite.com/2022/05/22/java%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2022/05/22/java%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/</id>
    <published>2022-05-22T13:11:47.000Z</published>
    <updated>2022-05-30T04:14:13.155Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
    
      <category term="java基础知识" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记</title>
    <link href="http://yoursite.com/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-16T14:01:52.000Z</published>
    <updated>2022-08-16T12:32:35.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法第四版的笔记">0. 算法第四版的笔记</h1><p><strong><em><font face="楷体" size="6" color="#ff00f0">这篇博客是基于《算法第四版》使用Java语言实现书中各种数据结构及算法的。博客本身大部分都是基于书上的讲解摘抄作为笔记，习题只实现了小部分。这里有两个比较不错的动态化的图示的算法演示网站。</font></em></strong></p><p><a id="more"></a></p><p><strong><em><font face="楷体" size="4" color="#ff00f0">网站1：</font></em></strong></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a>:</p><p><strong><em></em></strong></p><p><strong><em><font face="楷体" size="4" color="#ff00f0">网站2：</font></em></strong></p><p>[ <a href="https://link.zhihu.com/?target=http%3A//visualgo.net/">VisuAlgo</a>]</p><p><strong><em></em></strong></p><h1 id="排序">2. 排序</h1><h2 id="选择排序">2.1 选择排序</h2><p>选择排序的思想是：首先找到数组中最小的那个元素，其次，将它和数组中的第一个元素交换位置，然后再在剩下的元素中找到最小的元素，将它与第二个元素进行交换，如此往复，直到整个数组都是有序的。</p><h2 id="冒泡排序">2.2 冒泡排序</h2><p>冒泡排序的思想是：比较列表的相邻的数，如果前面的比后面的要大，那么就交换这两个，一趟排序完成之后，则无序区减少一个数，有序区增加一个数。</p><h2 id="插入排序">2.3 插入排序</h2><p>插入排序是一种最简单的排序方法，它的基本思想就是将一个记录插入到已经排好序的有序列表中，从而一个新的、记录增加1的有序表。</p><h2 id="希尔排序">2.4 希尔排序</h2><p>希尔排序思想来自插入排序，只不过不像插入排序那样只改变相邻的元素，而是交换不相邻的元素。希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组编织在一起组成的一个数组，如果h很大，我们就能够将元素移动到很远的地方，为实现更小的h有序创建方便。</p><p>简单来讲，分组排序就是首先以一定的间隔（通常是数组的一半长度），对组内的元素进行排序，然后不断减半这个间隔h，直到1.</p><h2 id="快速排序">2.5 快速排序</h2><p>快速排序是对冒泡排序的一种改进，通过多次比较和交换来实现排序，流程如下：</p><p>（1）首先设定一个分界值，通过该分界值将数组分为左右两部分。</p><p>（2）将大于或等于分界值的数据集中到数组右边，小于分界值的数值集中到数组的左边。此时，左边部分各个元素都小于分界值，右边元素都大于等于分界值。</p><p>（3）然后，左边和右边的数据可以独立排序，对于左侧的数据，又可以取一个分界值，将该部分数据分为左右两部分，同样在左边放较小的值，右边放置较大的值。右侧的数据可以做类似的处理。</p><p>（4）重复上述步骤，可以看出这是个递归的定义。通过递归将左侧部分排好序之后，再递归排好右侧部分的顺序，当左右两个部分的数据排序完成之后，整个数组排序完成。</p><h2 id="堆排序">2.6 堆排序</h2><p>首先堆是一个完全近似二叉树的结构，并且同时满足堆积的性质，即子结点的键值或者索引总是小于或者大于它的父节点。</p><p>算法流程：</p><ul><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或者小顶堆，大顶堆是节点大于叶子结点的数据，大顶堆用于升序排序</li><li>将堆顶元素与末尾元素交换，将最大元素沉到数组末尾</li><li>重新调整结构，使其满足堆的定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li></ul><h2 id="归并排序">2.7 归并排序</h2><p>归并算法的思想是：采用分治的思想，将已经有序的两个子序列合并得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序。（1）把长度为n的输入序列分为两个长度为n/2的子序列；（2）对这两个子序列分别采用归并排序；（3）将两个排好序的子序列合并成一个最终的排序序列</p><h2 id="桶排序">2.8 桶排序</h2><p>其实基数排序和计数排序都是基于桶排序的思想发展来的。工作原理是将数组分到有限数量的桶子里面，每个桶再分别进行排序（使用别的算法或者递归继续桶排序）。若待排序的记录的关键字在一个明显有限的范围内时，可以设计有限个有序桶，每个桶只能装预置对应的值，顺序输出各桶的值，将得到有序的序列。简单来说，在我们可以确定需要排列的数组范围时，可以生成该数值范围内有限个桶去对应数组中的数，然后我们将扫描的数值放入匹配的桶里的行为，可以看做是分类，在分类完成后，我们需要依次按照桶的顺序输出桶内存放的数值，这样就完成了桶排序。</p><h2 id="基数排序">2.9 基数排序</h2><p>桶排序的一种，非比较排序，多关键字排序。基本操作是：先找出数据中心最大的位数，然后从低位开始排序，收集已排序的数据，直到最高位排序完成。</p><p>算法的流程为：（1）先计算出数据的最大位数；（2）先从低位开始排序，再从高位开始排序，收集已经排序的数据；（3）不断从低位到高位，对数据进行排序，直到最高位已经排好，排序完成。</p><h2 id="计数排序">2.10 计数排序</h2><p>假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k=O(n)，S={S1,S2,..Sk}；则计数排序可以描述如下：</p><p>1、扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；</p><p>2、扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。</p><h2 id="优先队列">2.11 优先队列</h2><p>优先队列是一种抽象数据类型，它表示了一组值和对这些值的操作。优先队列的最重要的方法就是删除最大元素以及插入元素。</p><p>如果我们使用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到其上下节点，父节点和两个子结点各需一个。完全二叉树只用数组而不需要指针就可以表示。二叉堆是一组能够能够用有序的完全二叉树排序的元素，并在数组中安照层级存储（不使用数组的第一个位置）。一颗大小为N的完全二叉树的高度为<span class="math inline">\(\lfloor lg N \rfloor\)</span>。</p><p>对于一个含有N个元素的基于堆的优先队列，插入元素操作只需要不超过<span class="math inline">\((lgN+1)\)</span>次比较，删除最大元素的操作只需要不超过<span class="math inline">\(2lgN\)</span>次操作。</p><h2 id="单调栈">2.12 单调栈</h2><p>单调栈是指栈内的元素，从栈底到栈顶都是单调递增或者单调递减的。如果有新元素的入栈，栈调整过程中，会将所有破坏单调性的元素出栈，并且出栈的元素不会再次入栈。由于每个元素只有一次入栈和出栈的操作，所以单调栈的维护时间复杂度是<span class="math inline">\(O(n)\)</span></p><p>递增栈中可以找到元素左右两侧比自身小的第一个元素。假设从栈底到栈顶是递增的，当有新元素入栈。对于出栈元素来说，找到右侧第一个比自身小的元素。对于新元素来说，等待所有破坏递增顺序的元素出栈后，找到左侧第一个比自身小的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">static</span> Comparable[] arr;<span class="comment">//相当于在当前类内作用域下申请一个全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp_minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(a[j],a[temp_minIndex])) temp_minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            exch(a, i, temp_minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;<span class="comment">//外循环保证大的排序到后面，到后面的就不需要再排序了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(a[j + <span class="number">1</span>], a[j]))</span><br><span class="line">                    exch(a, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        Comparable cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cur = a[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;<span class="comment">//需要一个当前指针和前序的指针</span></span><br><span class="line">            <span class="comment">//前序指针不断向前，把当前值插入到顺序的位置</span></span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; less(cur, arr[preIndex]))&#123;</span><br><span class="line">                arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">                preIndex --;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**函数重载**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存基准数</span></span><br><span class="line">        Comparable base = a[left];</span><br><span class="line">        <span class="comment">//定义变量i指向最左边</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//定义j指向最右边</span></span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当i和j不相遇</span></span><br><span class="line">        <span class="keyword">while</span> (i != j)&#123;</span><br><span class="line">            <span class="comment">//j从右向左检索比基准数小的，如果检索到比基准数小的就停下</span></span><br><span class="line">            <span class="comment">//如果检索比基准数大或者相等即继续检索</span></span><br><span class="line">            <span class="keyword">while</span> (!less(a[j], base) &amp;&amp; i &lt; j) j --;<span class="comment">//一直找到比基准数小的</span></span><br><span class="line">            <span class="comment">//i从左往右检索</span></span><br><span class="line">            <span class="keyword">while</span> (less(a[i], base) &amp;&amp; i &lt; j) i ++;<span class="comment">//一直检索到比基准数大的</span></span><br><span class="line">            <span class="comment">//走到这i找到了，j找到了，交换</span></span><br><span class="line">            exch(a,i,j);<span class="comment">//交换这俩</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * while条件不成立，说明相遇了</span></span><br><span class="line"><span class="comment">         * 相遇了就将基准数和相遇位置的元素</span></span><br><span class="line"><span class="comment">         * 意思就是交换相遇位置的数和开始元素的数</span></span><br><span class="line"><span class="comment">         * 多出来了base这个指针，所以当重合的时候，此时这个指针是没有对应值的，这个值应该用base填充</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//先把相遇位置的元素赋值给基准数位置的元素</span></span><br><span class="line">        a[left] = a[i];</span><br><span class="line">        <span class="comment">//把基准数赋值给相遇的位置的元素</span></span><br><span class="line">        a[i] = base;</span><br><span class="line">        <span class="comment">//此时基准数左边比它小，右边比它大</span></span><br><span class="line">        <span class="comment">//排基准数的左边</span></span><br><span class="line">        quickSort(a, left, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, j + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        <span class="comment">//第一步将无序序列构成一个堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(a, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：将堆顶元素与末尾元素交换，将最大元素沉到数组末端</span></span><br><span class="line">        <span class="comment">//第三步：重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，</span></span><br><span class="line">        <span class="comment">//反复执行调整+交换步骤，直到整个序列有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            exch(a,<span class="number">0</span>, j);</span><br><span class="line">            adjustHeap(a, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个数组调整成大顶堆，完成将以i对应的非叶子节点的数调整成大顶堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 非叶子结点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素进行继续调整，length是在逐渐减少的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        <span class="comment">//j = i * 2 + 1指向的是i节点的左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span> + <span class="number">1</span>; j &lt; length; j = j * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; less(a[j], a[j + <span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">//说明左子节点小于右子节点的值</span></span><br><span class="line">                j ++;<span class="comment">//j指向右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! less(a[j], temp))&#123;</span><br><span class="line">                <span class="comment">//如果子结点大于父节点</span></span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                i = j;<span class="comment">//把较大的赋值给当前的结点，然后让i指向k，继续循环比较</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环结束后，已经将以i为父节点的树的最大值放在了最顶</span></span><br><span class="line">        a[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        arr = mergeSort1(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载保证格式上的相等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable[] mergeSort1(Comparable[] a)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> mid = a.length / <span class="number">2</span>;</span><br><span class="line">        Comparable[] left = Arrays.copyOfRange(a, <span class="number">0</span>, mid);</span><br><span class="line">        Comparable[] right = Arrays.copyOfRange(a, mid, a.length);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort1(left), mergeSort1(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**将两端排好序的数组组合成一个排序数组**/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable[] merge(Comparable[] left, Comparable[] right)&#123;</span><br><span class="line">        Comparable[] res = <span class="keyword">new</span> Comparable[left.length + right.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; res.length; index ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= left.length)</span><br><span class="line">                res[index] = right[j ++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">                res[index] = left[i ++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(right[j], left[i]))</span><br><span class="line">                res[index] = right[j ++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[index] = left[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**这里是对输入的字符串（英文）进行排序的，</span></span><br><span class="line"><span class="comment">         * 只算上小写吧</span></span><br><span class="line"><span class="comment">         * 一共有26个**/</span></span><br><span class="line">        <span class="comment">//创建一个桶数组，下标表示元素，下标的对应值表示这个值出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            bucketArr[(Character) a[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历桶数组，外层循环从桶的第一位开始，内层循环遍历桶数组中下标为i的值出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr[i]; j++) &#123;</span><br><span class="line">                a[index ++] = (<span class="keyword">char</span>) (Integer.valueOf(<span class="string">'a'</span>) + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//执行插入排序，将a[i]插入到a[i - h], a[i - 2 * h], a[i - 3 * h]...中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                    exch(a, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;<span class="comment">//只记录最大的位数</span></span><br><span class="line">        <span class="comment">//先获取数组的最大位数</span></span><br><span class="line">        <span class="keyword">for</span> (Comparable str : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.toString().length() &gt; maxLen)</span><br><span class="line">                maxLen = str.toString().length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//空间换时间，大桶套小桶</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; buckets = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从最后一个字母开始排序，低位开始排</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = maxLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//声明27个桶</span></span><br><span class="line">            buckets = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">27</span>; j++) &#123;</span><br><span class="line">                buckets.add(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排序，主要需要考虑到桶的容量</span></span><br><span class="line">            <span class="keyword">for</span> (Comparable str : a) &#123;<span class="comment">//遍历所有的字符串，分别放入对应的桶内，按照最后一个字母的单词index，再依次往前</span></span><br><span class="line">                buckets.get(getIndex(str.toString(), i)).add(str.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新赋值，每针对一位都需要重新调整</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;String&gt; bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String str : bucket) &#123;</span><br><span class="line">                    a[index ++] = str;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String str, <span class="keyword">int</span> charIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**将字符对应的ASCII码映射到0-26的范围，其中26是其他字符**/</span></span><br><span class="line">        <span class="keyword">if</span> (charIndex &gt;= str.length()) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//第0个桶存非零字母情况</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">26</span>;<span class="comment">//还有非字母项，都丢到最后了</span></span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) str.charAt(charIndex);<span class="comment">//字母转数字</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">64</span> &lt; n &amp;&amp; n &lt; <span class="number">91</span>)</span><br><span class="line">            index = n - <span class="number">64</span>;<span class="comment">//大写字母区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">96</span> &lt; n &amp;&amp; n &lt; <span class="number">123</span>)</span><br><span class="line">            index = n - <span class="number">96</span>;<span class="comment">//小写字母区间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index = <span class="number">26</span>;<span class="comment">//其余非字母的排在最后</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">27</span>];</span><br><span class="line">        <span class="comment">//统计每个值出现的次数，并放到计数数组对应的下标中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            countArr[(Character) a[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次从计数数组中取出，并重新赋给a数组</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (countArr[i] -- &gt; <span class="number">0</span>)</span><br><span class="line">                a[index ++] = (<span class="keyword">char</span>) (Integer.valueOf(<span class="string">'a'</span>) + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] =t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在单行中打印数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStr</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(<span class="keyword">int</span> caseIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (caseIndex &lt; <span class="number">9</span> || caseIndex == <span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入待排序的字符串: "</span>);</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            arr = <span class="keyword">new</span> Comparable[s.length()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                arr[i] = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (caseIndex == <span class="number">9</span>)&#123;</span><br><span class="line">            <span class="comment">//基数排序，可以测试一下其排序用在字符串上</span></span><br><span class="line">            System.out.println(<span class="string">"请输入要排序的字符串：（以空格分隔）"</span>);</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            arr = s.split(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"选择排序的方式：\n"</span> +</span><br><span class="line">                <span class="string">"1: 选择排序\n"</span> + <span class="string">"2: 冒泡排序\n"</span> + <span class="string">"3: 插入排序\n"</span> +</span><br><span class="line">                <span class="string">"4: 快速排序\n"</span> + <span class="string">"5: 堆排序\n"</span> + <span class="string">"6: 归并排序\n"</span> +</span><br><span class="line">                <span class="string">"7: 桶排序\n"</span> + <span class="string">"8: 希尔排序\n"</span> + <span class="string">"9: 基数排序\n"</span> + <span class="string">"10: 计数排序\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> sortWay = Integer.parseInt(scanner.nextLine());</span><br><span class="line">        getData(sortWay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (sortWay)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                selectSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                bubbleSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                insertSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                quickSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                heapSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                mergeSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                bucketSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                shellSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                radixSort(arr);</span><br><span class="line">                showStr(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                countSort(arr);</span><br><span class="line">                show(arr);</span><br><span class="line">                System.out.println(<span class="string">"排序完毕"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找">3. 查找</h1><h2 id="符号表">3.1 符号表</h2><p><strong>符号表最主要的目的就是将一个键和一个值关联起来。</strong>用例能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值。</p><p>所有的实现都基于以下的规则：</p><ul><li>每个键只对应一个值（表中不允许存在重复的键）</li><li>当用例代码向表中存入的键值对和表中已有的键（或者关联的值）冲突时，新的值会代替旧的值</li></ul><p>为了方便用例处理表中的所有键值，会在第一行加上implements Iterable<Key>，强制所有实现必须包含iterator()方法来返回一个实现了hasNext()和next()方法的迭代器。</Key></p><ul><li><p>无序链表中的顺序查找</p><p>符号表中使用的数据结构中的一个简单选择就是链表，每个节点存储一个键值对。</p><p>实现的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span> &lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;<span class="comment">//链表首节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value val;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//给定查找的值，返回相关联的值</span></span><br><span class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key))</span><br><span class="line">                <span class="keyword">return</span> x.val;<span class="comment">//命中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//未命中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查找给定的键，找到则更新其值，否则在表中新建节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(x.key))&#123;</span><br><span class="line">                x.val = val;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//命中，更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="keyword">new</span> Node(key, val, first);<span class="comment">//未命中，新建节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于链表的查找是非常低效的，可以使用二分查找的方法，不过二分查找就必须要求查找的时候。下面的算法中最重要的就是rank()函数，这个函数就是来定位给定的值的位置的，正是可以轻松的定位，给其他查找的时候的代码简化了。在N个键的有序数组中进行二分查找最多需要<span class="math inline">\(lg N + 1\)</span>次比较。</p><p>二分查找虽然说减少了比较的次数，但是还是无法减少运行所需的时间。因为它无法改变的事实是：在键是随机排列的情况下，构造一个基于有序数组的符号表所需的访问数组的次数仍然是长度的平方级别，虽然在实际的情况中不是随机的，但是还是很好的符合这个分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span> &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这里的key是继承自comparable对象，所以可以比较大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> values[i];<span class="comment">//根据排序来定位</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>)&#123;</span><br><span class="line">            values[i] = val;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j --)&#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            values[j] = values[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = val;</span><br><span class="line">        N ++;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * assert condition;</span></span><br><span class="line"><span class="comment">         * 这里condition是一个必须为真(true)的表达式。如果表达式的结果为true，那么断言为真，并且无任何行动</span></span><br><span class="line"><span class="comment">         * 如果表达式为false，则断言失败，则会抛出一个AssertionError对象。这个AssertionError继承于Error对象，</span></span><br><span class="line"><span class="comment">         * 而Error继承于Throwable，Error是和Exception并列的一个错误对象，通常用于表达系统级运行错误。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>)&#123;<span class="comment">//定位元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                keys[j] = keys[j + <span class="number">1</span>];</span><br><span class="line">                values[j] = values[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            N --;</span><br><span class="line">            keys[N] = <span class="keyword">null</span>;</span><br><span class="line">            values[N] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">return</span> keys[i];<span class="comment">//取值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N)&#123;</span><br><span class="line">            <span class="keyword">if</span> (keys[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> keys[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回表中小于给定键的键的数量</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi)&#123;<span class="comment">//二分查找，基于有序数组</span></span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[k];<span class="comment">//返回第k个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSorted() &amp;&amp; rankCheck();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys[i].compareTo(keys[i - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rankCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != rank(select(i)))<span class="comment">//检查是否标号对应</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys[i].compareTo(select(rank(keys[i]))) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//检查值是否对应</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下二分查找都比顺序查找快的多，它也是众多实际应用中程序中的最佳选择，对于一个静态表来说，将其在初始化时就排序是值得的。当然，如果一个数据集的插入和查找操作是混合进行的话，那么二分查找就不再适合了。我们需要在构造庞大的符号表的同时能够任意插入或者删除检制度，同时也要能够完成查找操作，而使用二叉查找树就能够将查找和插入的操作的算法复杂度都降为对数级别。</p></li></ul><h2 id="二叉查找树">3.2 二叉查找树</h2><p>在二叉查找树中，每个节点包含了一个键和一个值，键之间也有顺序之分以支持高效的查找。二叉查找树的每个节点都含有一个Comparable的键（以及相关联的值），<strong>且每个节点的值都大于其左子树的任意结点的键而小于右子树的任意结点的键</strong>。</p><p>首先这个地方一直要使用到第一章所提到的队列的实现，这里给出了本书泛型的队列，使用的是链表的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;<span class="comment">//尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;<span class="comment">//只是一个节点类，所以只会定义成员变量</span></span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        Node oldlast = last;</span><br><span class="line">        last = <span class="keyword">new</span> Node();<span class="comment">//压入一个新的结点</span></span><br><span class="line">        last.item = item;</span><br><span class="line">        last.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            first = last;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            oldlast.next = last;</span><br><span class="line">        N ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Item item = first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        N --;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();<span class="comment">//返回的是一个迭代器类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node current = first;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Item item = current.item;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catenation</span><span class="params">(Queue&lt;Item&gt; queue)</span></span>&#123;</span><br><span class="line">        Queue&lt;Item&gt; temp = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        Iterator&lt;Item&gt; iterator = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">            temp.enqueue(iterator.next());</span><br><span class="line">        last.next = temp.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Character&gt; q = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            String str = scanner.nextLine();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                q.enqueue(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&lt;Character&gt; iterator = q.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                System.out.println(iterator.next().charValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现二叉查找树的代码如下，<strong>代码中尤其值得注意的是二叉树的删除和插入结点！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;<span class="comment">//根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value val;<span class="comment">//节点存储的是键值对</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.N = N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过键获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 传入的键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left, key);<span class="comment">//小于就递归左子树查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right, key);<span class="comment">//大于则递归右子树查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往二叉树中添加值，如果键不存在的话，那么就新建一个键，</span></span><br><span class="line"><span class="comment">     * 如果存在的话，就更新它的值。</span></span><br><span class="line"><span class="comment">     * 这样就保证了二叉树中存储的键都是惟一的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.left = put(x.left, key, val);<span class="comment">//选择插入到左子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.right = put(x.right, key, val);<span class="comment">//插入到右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Node x = floor(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据键找到键？</span></span><br><span class="line"><span class="comment">     * 没啥用的感觉</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        Node t = floor(x.right, key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Node x = ceiling(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> floor(x.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        Node t = floor(x.left, key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选出最小的k个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root, k).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = size(x.left);</span><br><span class="line">        <span class="keyword">if</span> (t &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> select(x.left, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &lt; k) &#123;<span class="comment">//已经从左子树筛选到了t个节点，选择右子树</span></span><br><span class="line">            <span class="keyword">return</span> select(x.right, k - t - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回这个键的排名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank(key, x.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + size(x.left) + rank(key, x.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x.right;</span><br><span class="line">        &#125;</span><br><span class="line">        x.left = deleteMin(x.left);</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递归的终止条件就是当前节点的右子树为空</span></span><br><span class="line"><span class="comment">         * 那么当前节点就是最大的</span></span><br><span class="line"><span class="comment">         * x.right = deleteMax(x.right);这句话左边的x滞后于里面的x.right</span></span><br><span class="line"><span class="comment">         * 相当于把最大节点的父节点的右子树置为其左子树</span></span><br><span class="line"><span class="comment">         * 这里的x并没有改变，还是指的根结点，并没有x = x.right;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        x.right = deleteMax(x.right);<span class="comment">//</span></span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;<span class="comment">//返回的是整个树的根结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        root = delete(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.left = delete(x.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.right = delete(x.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//定位到了该结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;<span class="comment">//右子树为空，那么只要返回左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;<span class="comment">//同理</span></span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            Node t = x;</span><br><span class="line">            x = min(t.right);<span class="comment">//寻找到右子树中最小节点，这里需要把要删除节点的右子树中的最小节点作为根结点，保证右子树大于根结点</span></span><br><span class="line">            x.right = deleteMin(t.right);<span class="comment">//删除当前子树的根结点的右子树，然后在赋给上面那个x，也就是最小节点</span></span><br><span class="line">            x.left = t.left;<span class="comment">//当前节点的左结点作为右子树中最小节点的左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做个迭代器</span></span><br><span class="line"><span class="comment">     * 可以指定范围的迭代</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">        keys(root, queue, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmplo = lo.compareTo(x.key);</span><br><span class="line">        <span class="keyword">int</span> cmphi = hi.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            keys(x.left, queue, lo, hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmplo &lt;= <span class="number">0</span> &amp;&amp; cmphi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            queue.enqueue(x.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmphi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            keys(x.right, queue, lo, hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exercise 3.2.6</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(x.left), height(x.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exercise 3.2.32</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node x, Key min, Key max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; x.key.compareTo(min) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; x.key.compareTo(max) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(x.left, min, x.key) &amp;&amp; isBST(x.right, x.key, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exercise 3.2.33</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRankConsistent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != rank(select(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Key key : keys()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!key.equals(select(rank(key)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡查找树">3.3 平衡查找树</h2><p><strong>前面的数据结构和算法中，最坏的情况的性能依旧很糟糕，平衡查找树是一种二分查找树，能够保证无论如何构造它，运行时间都是对数级别的。</strong></p><h3 id="查找树">2-3查找树</h3><p>将一颗标准的二叉查找树中的节点称为2-节点，其含有一个键和两条链接。而现在引入3-节点，它含有两个键和三条链接。2-节点和3-节点中的每条链接都对应着其中保存的键所分割产生的一个区间。</p><p>一颗2-3查找树要么为一颗空树，要么由以下节点组成：</p><ul><li>2-节点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</li><li>3-节点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</li></ul><p><strong>一颗完美二叉树的所有空链接到根结点的距离都应该是相同的。</strong>但是上述的数据结构的表示方式实现大多数的操作并不方便，因为需要处理的情况很多。所以引出下面的红黑树。</p><h3 id="红黑二叉查找树">红黑二叉查找树</h3><p>红黑二叉查找树背后的基本思想是用标准的二叉查找树和一些额外的信息（替换3-节点）来表示2-3树。将树中的链接分为两类：红链接将两个2-节点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。将3-节点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子节点）相连的两个2-节点。如下图所示：</p><p><img src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source_posts\算法笔记\红黑树的红链接.png"></p><p>这种表示的方法的优点是，无序修改就可以直接使用标准二叉查找树的get()方法。（<em>意思就是把2-3树中的3-节点拆分了，拆分得做记号，也就是将较小的那个节点作为较大的结点的左子节点，并且接下去的子结点的划分也要满足平衡二叉树的定义</em>）</p><p>以下摘抄自文章：[https://www.jianshu.com/p/e136ec79235c]</p><p>红黑树满足的性质主要有以下五点：</p><ul><li><p>每个节点要么是黑色要么是红色</p></li><li><p>根结点是黑色</p></li><li><p>每个叶子结点是黑色，而且是空的</p></li><li><p>每个红色节点的两个子结点一定都是黑色的</p></li><li><p>任一节点到每个叶子结点的路径都包含数量相同的黑节点（这个可以推出来，如果一个结点存在黑子节点，那么该结点一定有两个子结点）</p></li><li></li><li><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\简单的红黑树.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">简单的红黑树结构</div></center></li></ul><p>简单的红黑树结构如上图所示，可以看出红黑树不一定是一个完美平衡的二叉查找树。因为其左子树和右子树的高度并不一定是一致的，但是都包含相同数量的黑节点，称之为黑色完美平衡。</p><h3 id="红黑树的自平衡">红黑树的自平衡</h3><ul><li>左旋：以某个节点作为支点（旋转节点），<strong>其右子结点变为旋转的父节点，右子结点的左子节点变为旋转节点的右子结点，左子节点保持不变</strong>。</li><li>右旋：以某个节点作为支点（旋转节点），<strong>其左子节点变为旋转节点的父节点，左子节点的右子结点变为旋转节点的左子节点，右子结点保持不变</strong>。</li><li>变色：节点的颜色由红变黑或者由黑变红。</li></ul><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\红黑树的左旋.webp"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">红黑树的左旋</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\红黑树的右旋.webp"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">红黑树的右旋</div></center><p>左旋只会影响旋转节点和其右子树的结构，把右子树的结点往左子树挪动了。而右旋只会影响旋转节点和其左子树的结构，把左子树的结点往右子树挪动了。所以旋转操作只是局部的，直观上理解就是：当一边子树的结点少了，那么向另外一边子树借一点节点。<strong>红黑树总是通过旋转和变色来达到自平衡</strong>。</p><p>红黑树的查找和二分查找树是一样的，接下里说一下插入和删除。</p><h3 id="红黑树的插入">红黑树的插入</h3><p>插入包含两个工作：一个是插入的位置，另一个是插入后自平衡。插入位置查找跟红黑树的查找没差太多，只是插入的颜色默认是红色的，因为这样的话就保证了我们插入之后的黑色平衡没有被破坏。步骤如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\红黑树插入位置查找.webp"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">红黑树插入位置查找</div></center><p>红黑树的插入主要有以下这么多类：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入结点关系结点.webp"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入结点的关系结点表示</div></center><ul><li><p>红黑树为空树。这个情况最简单了，直接返回一个黑色的根结点即可。</p></li><li><p>当插入的结点key已经存在。这个操作也很简单，直接把插入的结点设置为将要替代结点的颜色，然后更新结点的值。</p></li><li><p>当插入的结点的父节点是黑色的结点。这个也很简单，由于插入的结点是红色的，不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p></li><li><p>插入结点的父节点为红色节点。这种情况就很复杂了。</p><h4 id="叔叔结点存在并且为红结点">4.1 叔叔结点存在并且为红结点。</h4><p>叔叔结点为红色的话，那么祖父节点肯定就是黑色的了。那么此时插入子树的红黑层数的情况是：黑红红。最简单的处理方式就是把其改成：红黑红。</p><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入情景4.1_1.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入情景4.1_1</div></center><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入情景4.1_2.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入情景4.1_2</div></center><p>可以看到，已经把PP节点设置为红色了，如果PP的父节点是黑色，那么无序再做任何处理的操作。但是如果PP的父节点是红色，此时红黑树已经不平衡了，所以还需要把PP当做新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>PP如果为根结点，我们必须将PP设置为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。这也是唯一会增加红黑树黑色结点层数的插入情景。<strong>红黑树的生长是自底向上的，这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</strong></p><h4 id="叔叔结点不存在或者为黑结点并且插入结点的父亲结点是祖父结点的左子结点">4.2 叔叔结点不存在或者为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</h4><p>单纯从插入的角度来看，叔叔结点非红就是叶子结点（也就是空节点）。因为如果叔叔结点为黑结点，而父节点为红结点，那么叔叔结点所在的子树的黑色结点就比父节点所在的子树多了，这不满足红黑树的性质5。</p><h5 id="插入结点是其父节点的左子节点">4.2.1 插入结点是其父节点的左子节点</h5><p>处理为：将P设为黑色，PP设为红色，对PP进行右旋。</p><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入情景4.2.1.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入情景4.2.1</div></center><h5 id="插入结点是其父节点的右子结点">4.4.2 插入结点是其父节点的右子结点</h5><p>处理为：对P进行左旋，将P设置为插入结点，得到4.2.1的情况，然后进行4.2.1的处理。</p><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入情景4.2.2.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入情景4.2.2</div></center><h4 id="插入结点不存在或者为黑结点并且插入结点的父节点是祖父结点的右子结点">4.3 插入结点不存在或者为黑结点，并且插入结点的父节点是祖父结点的右子结点</h4><h5 id="插入结点是其父节点的右子结点-1">4.3.1 插入结点是其父节点的右子结点</h5><p>处理为：将P设为黑色，将PP设为红色，对PP进行左旋</p><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入情景4.3.1.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入情景4.3.1</div></center><h5 id="插入结点是其父节点的左子节点-1">4.3.2 插入结点是其父节点的左子节点</h5><p>处理为：对P进行右旋，将P设置为插入结点，得到情景4.3.1，进行情景4.3.1的处理</p><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\插入情景4.3.2.webp"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">插入情景4.3.2</div></center></li></ul><h2 id="散列表">3.4 散列表</h2><h1 id="图">4. 图</h1><h2 id="无向图">4.1 无向图</h2><p>图的概念在研究工作中已经很透彻了，介绍一些数据结构的概念。</p><ul><li>自环：已一条连接一个顶点和其自身的边。</li><li>平行边：连接同一对顶点的两条边。</li><li>树：一幅无环的连通图。</li><li>森林：互不相连的树组成的集合叫做森林。</li><li>二分图：能够将所有的结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</li></ul><p>算法第四版这本书给出了一些实现图算法的API，比起networkx库给的要简单的多，不过对于学习还是可以的。</p><p>图的表示方法：</p><ul><li>邻接矩阵。使用一个<span class="math inline">\(V \times V\)</span>的布尔矩阵，当顶点v和顶点w之间有相连接的边时，定义v和w的元素值为true，这种不适合大规模的网络。</li><li>边的数组。使用一个Edge类，它含有两个int实例变量。但是这种又实现不了API中的adj()方法，检查所有的连边的结点。</li><li>邻接表数组。使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表。</li></ul><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\邻接表数组.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">邻接表数组</div></center><p>邻接表数组这一数据结构就是把每个顶点的所有相邻结点都保存在该结点对应的元素所指向的一张链表中。要添加一条连接v和w的边，我们将w添加到v的邻接表中，并把v添加到w的邻接表中，这种graph的实现性能有如下的特点：</p><ul><li>使用的空间和V+E成正比</li><li>添加一条边所需的时间为常数</li><li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比，处理每个相邻顶点所需的时间为常数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;<span class="comment">//bag对象，包含一系列的与当前节点相连接的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];<span class="comment">//V个结点对应于V个bag对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(Scanner scanner)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(scanner.nextInt());<span class="comment">//读取V并将图初始化，创建一个大小为V的图</span></span><br><span class="line">        <span class="keyword">int</span> E = scanner.nextInt();<span class="comment">//读取E</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;<span class="comment">//添加一条边</span></span><br><span class="line">            <span class="keyword">int</span> v = scanner.nextInt();<span class="comment">//读取边的一个结点</span></span><br><span class="line">            <span class="keyword">int</span> w = scanner.nextInt();<span class="comment">//读取边的另一个节点</span></span><br><span class="line">            addEdge(v,w);<span class="comment">//添加边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 习题4.1.3：接受一幅图并初始化这个图的一个副本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(G.V());</span><br><span class="line">        E = G.E();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Integer w : G.adj[i]) &#123;</span><br><span class="line">                reverse.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer w : reverse) &#123;</span><br><span class="line">                adj[i].add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">        E ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = V + <span class="string">" verices, "</span> + E + <span class="string">" edges\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            s += i + <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer w : <span class="keyword">this</span>.adj[i]) &#123;</span><br><span class="line">                s += w + <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s += <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个graph的实现使用的是一个由顶点索引的整型表数组。第二个构造函数从输入流中读取一幅图，开头是V，然后是E，再然后是一列整数对，大小在0到V-1之间。</strong></p><h3 id="图的搜索">4.1.1 图的搜索</h3><ul><li>深度优先搜索：是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次</li><li>广度优先搜索：系统地展开并检查图中的所有结点，以寻找结果。</li></ul><p>深度优先搜索和广度优先搜索的示例图如下所示：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\深度优先搜索以及广度有限搜索.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">深度优先搜索与广度有限搜索</div></center><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 深度优先代码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table><pre><code>public DepthFirstSearch(Graph G, int s) {    marked = new boolean[G.V()];    dfs(G, s);}public void dfs(Graph G, int v){    marked[v] = true;//标记为已访问    count ++;    for (Integer w : G.adj(v)) {        if (! marked[w])            dfs(G, w);//以中心节点发散式的去寻找,一直递归的以当前节点为中心节点去往深处走    }}public boolean marked(int w){    return marked[w];}public int count(){    return count;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">利用深度优先搜索查找路径的代码如下所示：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class DepthFirstPaths &#123;</span><br><span class="line">    private boolean[] marked;&#x2F;&#x2F;是否访问过</span><br><span class="line">    private int[] edgeTo;&#x2F;&#x2F;从起点到一个顶点的已知路径上的最后一个顶点</span><br><span class="line">    private final int s;&#x2F;&#x2F;起点</span><br><span class="line"></span><br><span class="line">    public DepthFirstPaths(Graph G, int s) &#123;</span><br><span class="line">        marked &#x3D; new boolean[G.V()];</span><br><span class="line">        edgeTo &#x3D; new int[G.V()];</span><br><span class="line">        this.s &#x3D; s;</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(Graph G, int v)&#123;</span><br><span class="line">        marked[v] &#x3D; true;</span><br><span class="line">        for (Integer w : G.adj(v)) &#123;&#x2F;&#x2F;在图的邻居中查找遍历节点，可以起到回溯的效果</span><br><span class="line">            if (! marked[w])&#123;</span><br><span class="line">                edgeTo[w] &#x3D; v;&#x2F;&#x2F;记录下通到前一个节点的结点 </span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPathTo(int v)&#123;</span><br><span class="line">        return marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterable&lt;Integer&gt; pathTo(int v)&#123;</span><br><span class="line">        if (! hasPathTo(v)) return null;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 栈的后入先出的性质很能展示图的轨迹</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Stack&lt;Integer&gt; path &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        for (int x &#x3D; v; x !&#x3D; s; x &#x3D; edgeTo[x])&#x2F;&#x2F;一遍遍的指向下一个节点，从目的地开始</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广度优先搜索能够解决的问题是：<strong>单源最短路径问题</strong>，给定一个图和一个起点s，要找到s到v的最短路径。<strong>在深度优先搜索中，使用的是后进先出的栈来描述压栈和走迷宫时县探索相邻的通道，从有待搜索的通道中选择最晚遇到过的那条。在广度优先搜索中，使用先入先出的队列来代替栈，按照与起点的距离的顺序来遍历所有的节点。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广度优先搜索代码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        bfs(G, s);<span class="comment">//从源节点开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        queue.enqueue(s);<span class="comment">//将其加入队列</span></span><br><span class="line">        <span class="keyword">while</span> (! queue.isEmpty())&#123;<span class="comment">//遍历当前层的每一个元素</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue();<span class="comment">//抛出一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">                edgeTo[w] = v;<span class="comment">//保存最短路径的最后一条边</span></span><br><span class="line">                marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                queue.enqueue(w);<span class="comment">//将其添加到队列中，是下一层的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 栈的后入先出的性质很能展示图的轨迹</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])<span class="comment">//一遍遍的指向下一个节点，从目的地开始</span></span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先搜索和广度优先搜索的差异仅仅在于从数据结构中获取下一个节点的规则，对于广度优先搜索来说是最早加入的顶点，对于深度优先来说是最晚加入的结点。深度优先就像是一只苍蝇在一个迷宫里面乱逛，广度优先就像是往迷宫里面灌水。</p><p>连通分量的实现：很简单的，看看得了、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CC</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[i])&#123;</span><br><span class="line">                dfs(G, i);</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        id[v] = count;<span class="comment">//表示连通的序列</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="union-find算法">4.1.2 union-find算法</h3><p>理论上union find算法比深度优先搜索算法要慢，因为它不能保证所需的时间是常数，而union find需要。但是在实际应用中，这点差异微不足道，实际上union-find算法其实更快，因为它不需要完整构造并表示一幅图。<strong>我们在完成只需要判断连通性或者需要完成有大量连通性查询和插入操作混合等类似的任务时，倾向于使用union-find算法。而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据类型。</strong>这个地方讲讲union-find算法，其实是在第一章讲的。</p><p>引入一个动态连通性问题，问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，对整数p，q可以被理解为"p和q是相连的"。相连会有以下的性质：</p><ul><li>自反性：p和p是相连的</li><li>对称性：如果p和q是相连的，那么q和p也是相连的</li><li>传递性：如果p和q是相连的，且p和r也是相连的，那么p和r也是相连的</li></ul><p>等价关系将对象分为多个等价类，当且仅当两个对象相连时他们才属于同一个等价类。我们的目标就是编写一个程序来过滤掉序列中所有无意义的整数对（两个整数对都来自同一个等价类中），只有当读取的p和q在所有的已知的整数对中都不能说明他们是相连的时候，才会添加这个整数对。</p><p>本书将对象称为触点，将整数对称为连接，将等价类称为连通分量或者是简称分量。本书的API中实现了union(),find(),connected()和count()方法，分别表示在p和q之间添加连接，找到p所在的分量的标识符，判断p和q是否存在于同一个分量中，以及连通分量的数量。</p><ul><li><p>quick-find算法</p><p>一种方法是保证当且仅当id[p]等于id[q]时p和q才是连通的。在同一个连通分量中的所有触点在id[]中的值必须全部相同。算法比较简单，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;<span class="comment">//连通分量id，触点作为索引，表示触点属于哪个连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;<span class="comment">//初始化，就当做有N个连通分量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;<span class="comment">//整个的连通分量的数目</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;<span class="comment">//判断两个触点是否连接</span></span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//找到p所在的分量的标识符</span></span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**quick-find算法</span></span><br><span class="line"><span class="comment">     * 意思是当我们输入一个连通之后，会打通这个里面所有的连着的</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将p和q归并到相同的分量中</span></span><br><span class="line">        <span class="keyword">int</span> pID = find(p);</span><br><span class="line">        <span class="keyword">int</span> qID = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pID == qID)</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//如果p和q已经在相同的分量中，则不需要求任何行动</span></span><br><span class="line">        <span class="comment">//不存在相同的分量，那么需要将p的分量重命名为q的名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pID)</span><br><span class="line">                id[i] = qID;</span><br><span class="line">        &#125;</span><br><span class="line">        count --;<span class="comment">//要减少一种分量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法中每次调用find()函数需要访问数组一次，而归并两个分量的union()操作需要访问数组在(N+3)到(2N+1)之间。我们至少要<span class="math inline">\((N+3)(N-1)\)</span>次的访问数组，也就是平方的量级，不适用于大量的数据集。</p></li><li><p>quick-union算法</p><p>这个算法相当于上述算法的改进，id[]数组还是以触点作为索引的，但是他的值的含义不一样。每个触点对应的id[]元素都是同一个分量中的另一个触点的名称，当然也可能是他本身，将这种关系称为链接，可以认为(p,q)二元组是一个边。</p><p>在上面的find()算法中，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接达到第三个触点，如此延伸达到最后一个触点，也就是根触点，即链接指向自己的触点。当且仅当分别由两个触点开始的这个过程达到了同一个根触点时他们存在于同一个连通分量中。</p><p>而相应的union算法就变为：我们由p，q的链接分别找到他们的根触点，然后只需将一个触点链接到另一个触点即可将一个分量重命名为另一个分量。</p><p>quick-union算法图解如下：</p><center><p><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\quickunion算法图解.png"> <br></p><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">quick-union算法图解</div><p>&lt;/center</p></center></li></ul><p>​ 代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickUnion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;<span class="comment">//连通分量id，触点作为索引，表示触点属于哪个连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickUnion</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;<span class="comment">//初始化，就当做有N个连通分量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;<span class="comment">//整个的连通分量的数目</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;<span class="comment">//判断两个触点是否连接</span></span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//找到p所在的分量的标识符</span></span><br><span class="line">        <span class="comment">//找出分量的名称</span></span><br><span class="line">        <span class="keyword">while</span> (p != id[p])</span><br><span class="line">            p = id[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**quick-union算法</span></span><br><span class="line"><span class="comment">     * 意思是当我们输入一个连通之后，会打通这个里面所有的连着的</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将p和q的根结点统一</span></span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        id[pRoot] = qRoot;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将结点连接起来的话，quick-union算法是会得到一棵树的，id[]数组用父链接额度形式表示了一篇森林。<strong>无论我们才能够任何触点所对应的结点开始跟随链接，最终都将达到该结点的树的根结点。</strong>而union-find算法在最坏的情况下的时间复杂度也是平方级别的。假如输入的整数对是有序的，0-1,0-2,0-3等等，N-1对的触点更新之后我们的树的高度将会是N-1，退化成了单链表，这就构成了该算法的最坏情况。改正的话需要下面的加权quick-union算法。</p><ul><li><p>加权quick-union算法</p><p>这个算法考虑的是，与其在union()中随意将一棵树连接到另一棵树，我们现在会记录每棵树的大小并总是将较小的树连接到较大的树上。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionUF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;<span class="comment">//父链接数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;<span class="comment">//各个根结点所对应的分量的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//连通分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;<span class="comment">//权重初始化为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p])</span><br><span class="line">            p = id[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将小树的根结点连接到大树的根结点</span></span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt; sz[j])&#123;</span><br><span class="line">            id[i] = j;</span><br><span class="line">            sz[j] += sz[i];<span class="comment">//大树权重为加和的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            sz[i] += sz[j];</span><br><span class="line">        &#125;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于N个触点，加权quick-union算法构造的森林中的任意结点的深度最多为<span class="math inline">\(lgN\)</span>。</p><ul><li><p>路径压缩的加权quick-union算法</p><p>路径压缩的quick-union算法就是在find()方法中添加一个循环来将从p到根结点的路径上的每个触点都连接到根结点。这样我们得到的树将会是一棵几乎完全扁平化的树。<strong>路径压缩的加权quick-union算法是最优的算法。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressedWeightedQU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompressedWeightedQU</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = p;</span><br><span class="line">        <span class="keyword">while</span> (root != id[root])</span><br><span class="line">            root = id[root];</span><br><span class="line">        <span class="keyword">while</span> (id[p] != root)&#123;<span class="comment">//添加循环，将在路径上遇到的所有结点都直接链接到根结点</span></span><br><span class="line">            <span class="keyword">int</span> temp = p;<span class="comment">//临时变量存储当前节点</span></span><br><span class="line">            p = id[p];<span class="comment">//指向下一个节点，因为要把所有的结点指向根结点</span></span><br><span class="line">            id[temp] = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line">        <span class="keyword">if</span> (i == j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt; sz[j])&#123;</span><br><span class="line">            id[i] = j;</span><br><span class="line">            sz[j] += sz[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            sz[i] += sz[j];</span><br><span class="line">        &#125;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有向图">4.2 有向图</h2><p>在有向图中，边是单向的，每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的。有向图中一个顶点的入度为由该顶点指出的边的总数；一个顶点的入度为指向该顶点的边的总数。规定每个顶点都能达到它自己，除此之外，在有向图中由v能到达w并不意味着由w也能达到v。</p><p>这里实现DiGraph的代码如下，其中reverse()方法返回有向图的一个副本，将其所有的边都反转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiGraph</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        E ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> DiGraph <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DiGraph R = <span class="keyword">new</span> DiGraph(V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer w : adj(i)) &#123;</span><br><span class="line">                R.addEdge(w, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图中的可达性">4.2.1 有向图中的可达性</h3><p>单点可达性：给定一幅有向图和一个起点s，回答是否存在一条从s到达给定顶点v的有向路径。多点可达性：给定一幅有向图和顶点的集合，回答是否存在一条从集合中的任意顶点到达给定顶点v的有向路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedDFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span><span class="params">(DiGraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span><span class="params">(DiGraph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (Integer s : sources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[s]) dfs(G, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DiGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DiGraph G = <span class="keyword">new</span> DiGraph(<span class="number">6</span>);</span><br><span class="line">        G.addEdge(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        G.addEdge(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        G.addEdge(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        G.addEdge(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">        G.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        G.addEdge(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        G.addEdge(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        DirectedDFS reachable = <span class="keyword">new</span> DirectedDFS(G, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reachable.marked(i))</span><br><span class="line">                System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的有向图，构建的时候只有一点是不一样的，也就是我们只单方向的把一个结点加入到了adj[]数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;<span class="comment">//添加边，v-&gt;w的连边</span></span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        E ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外在有向图中我们还倾向于寻找是否有有向环以及判断是否有向无环图，这里系统维护的递归调用的栈表示的正是当前正在遍历的有向路径。一旦我们找到了一条有向边<span class="math inline">\(v \to w\)</span>且w已经存在于栈中，就找到了一个环，因为栈表示的是一条从w到v的路径，而<span class="math inline">\(v \to w\)</span>正好补全了这个环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; cycle;<span class="comment">//有向环中的所有顶点，当前正在遍历的有向路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;<span class="comment">//递归调用的栈上的所有顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(DiGraph G)</span></span>&#123;</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[i]) dfs(G, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DiGraph G, <span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//查找的是一条由起点到v的有向路径</span></span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;<span class="comment">//标记递归调用的栈上的所有顶点</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;<span class="comment">//已经访问过</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;<span class="comment">//遍历当前节点的所有邻居</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasCycle()) <span class="keyword">return</span>;<span class="comment">//每次都要检查一下是否有环，有的话直接跳出，避免多次遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (! marked[w])&#123;<span class="comment">//w节点没有访问就记录一条边</span></span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (onStack[w])&#123;<span class="comment">//w存在于递归调用栈上，说明存在于当前的有向路径上</span></span><br><span class="line">                cycle = <span class="keyword">new</span> Stack&lt;Integer&gt;();<span class="comment">//记录当前环，有成环的条件</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != w; x = edgeTo[x]) &#123;</span><br><span class="line">                    cycle.push(x);<span class="comment">//记录v-&gt;w的有向路径</span></span><br><span class="line">                &#125;</span><br><span class="line">                cycle.push(w);</span><br><span class="line">                cycle.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">cycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图中的强连通性">4.2.2 有向图中的强连通性</h3><p>强连通性定义为：<strong>如果两个顶点v和w互相是可达的，则称它们是强连通的。</strong>同样的，强连通也存在如下的性质：</p><ul><li>自反性：任意顶点v和自己都是强连通的</li><li>对称性：如果v和w是强连通的，那么w和v也是强连通的</li><li>传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的</li></ul><p>强连通性将所有的顶点分为了一些等价类，每个等价类都是相互均为强连通的顶点的最大子集组成的，我们将这些子集定义为强连通分量。</p><p>首先这个书给出了一个有向图中基于深度优先搜索的顶点排序，给出了所有顶点的前序排列，后续排列以及逆后序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; pre;<span class="comment">//所有顶点的前序排序</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; post;<span class="comment">//所有顶点的后续排序</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;<span class="comment">//所有顶点的逆后序排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(DiGraph G)</span> </span>&#123;</span><br><span class="line">        pre = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        post = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        reversePost = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[i]) dfs(G, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DiGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        pre.enqueue(v);</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">        post.enqueue(v);<span class="comment">//遍历到没有遍历的情况再插入</span></span><br><span class="line">        reversePost.push(v);<span class="comment">//先进后出实现反转</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">reversePost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reversePost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出的是Kosaraju算法吗，将会完成以下任务：</p><ul><li>在给定的一幅有向图中，使用DepthFirstOrder来计算它的反向图<span class="math inline">\(G^R\)</span>的逆后序排序</li><li>在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有的未被标记的顶点</li><li>在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将他们按照和CC相同的方法识别出来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KosarajuSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;<span class="comment">//已访问过的顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;<span class="comment">//强连通分量的标识符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//强连通分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KosarajuSCC</span><span class="params">(DiGraph G)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];<span class="comment">//可能是有1-V个强连通分量的</span></span><br><span class="line">        DepthFirstOrder order = <span class="keyword">new</span> DepthFirstOrder(G.reverse());</span><br><span class="line">        <span class="keyword">for</span> (Integer s : order.reversePost()) &#123;<span class="comment">//遍历逆后序</span></span><br><span class="line">            <span class="keyword">if</span> (! marked[s])&#123;</span><br><span class="line">                dfs(G, s);<span class="comment">//一直递归去找s，找到了那么就说明有个环了，肯定是强连通分量了</span></span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DiGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        id[v] = count;<span class="comment">//当前节点是属于哪个强连通分量的</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stronglyConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Kosaraju算法的预处理所需的时间和空间与V+E成正比且支持常数时间的有向图强连通性的查询。</strong></p><h2 id="最小生成树">4.3 最小生成树</h2><p>生成树的定义为：图的生成树是它的一棵含有其所有的顶点的无环连通子图。一幅加权图的最小生成树（MST）是它的一棵权值（书中所有边的权值之和）最小的生成树。</p><p>本书做了以下的一些约定：</p><ul><li>只考虑连通图</li><li>边的权重不一定表示距离，可以理解为代价</li><li>边的权重可能是0或者负数</li><li>所有边的权重都各不相同</li></ul><p>树具有两个性质：</p><ul><li>用一条边连接树中的任意两个顶点都会产生一个新的环</li><li>从树中删除一条边将会得到两棵独立的树</li></ul><p>切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p><h3 id="prim算法">4.3.1 Prim算法</h3><p>Prim算法能够得到任意加权连通图的最小生成树。本书使用以下方法表示树中的顶点、边和横切边。</p><ul><li>顶点：使用一个由顶点索引的布尔数组marked[]，如果顶点v在树中，那么marked[v]的值为true</li><li>边：选择使用以下两种数据结构之一：一条队列mst来保存最小生成树的边，或者一个由顶点索引的Edge对象的数组edgeTo[]，其中edgeTo[v]为将v连接到树中的Edge对象。</li><li>横切边：使用一条优先队列MinPQ<Edge>来根据权重比较</Edge></li></ul><p>prim算法的主要流程就是如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\primAlgorithm_1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">primAlgorithm_1</div> <img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\primAlgorithm_2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">primAlgorithm_2</div></center><p><em>prim算法的延迟实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与E成正比，所需的时间与<span class="math inline">\(ElogE\)</span>成正比</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;<span class="comment">//最小生成树的顶点</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;<span class="comment">//最小生成树的边</span></span><br><span class="line">    <span class="keyword">private</span> MinPQ&lt;Edge&gt; pq;<span class="comment">//横切边（包括失效的边），用优先队列来保存所有的横切边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;();</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line"></span><br><span class="line">        visit(G, <span class="number">0</span>);<span class="comment">//先把0结点的所有横切边加入</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Edge e = pq.delMin();<span class="comment">//删除最小的，排序</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v);<span class="comment">//取出删除的边，作为新标红的结点</span></span><br><span class="line">            <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) &#123;<span class="comment">//失效的横切边则跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mst.enqueue(e);</span><br><span class="line">            weight += e.weight();</span><br><span class="line">            <span class="keyword">if</span> (!marked[v]) &#123;</span><br><span class="line">                visit(G, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                visit(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[e.other(v)]) &#123;</span><br><span class="line">                pq.insert(e);<span class="comment">//遍历保存当前访问结点的所有横切边，包含已经失效的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exercise 4.3.31</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入图结构："</span>);</span><br><span class="line">        System.out.println(<span class="string">"节点个数V，边的个数E，边的三元组："</span>);</span><br><span class="line">        EdgeWeightedGraph graph = <span class="keyword">new</span> EdgeWeightedGraph(scanner);</span><br><span class="line">        LazyPrimMST mst = <span class="keyword">new</span> LazyPrimMST(graph);</span><br><span class="line">        <span class="keyword">for</span> (Edge e : mst.edges()) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mst.weight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上述的算法还是可以改进的，可以尝试从优先队列中删除失效的边，这样优先队列就只含有树顶点和非树顶点之间的横切边，但其实还可以删除更多的边。我们感兴趣的边只是连接树顶点和非树顶点中权重最小的边。当我们将顶点v添加到树中时，对于每个非树顶点w产生的变化只可能使得w到最小生成树的距离更近了。我们不需要再优先队列中保存所有从w到树顶点的边，<strong>而只需要保存其中权重最小的那条，在将v添加到树中后检查是否需要更新这条权重最小的边（因为v-w的权重可能更小）。</strong>我们只需要遍历v的邻接链表就可以完成这个任务，只会在优先队列中保存每个非树顶点w的一条边：将它与树中的顶点连接起来的权重最小的那条边。</p><p>将LazyPrimMST中的marked[]和mst[]替换为两个顶点索引的数组edgeTo[]和distTo[]，它们具有以下的性质：</p><ul><li>如果顶点v不在树中但至少有一条边和树相连，那么edgeTo[v]是将v和树连接的最短边，distTo[v]为这条边的权重。</li><li>所有这类顶点v都将保存在一条索引优先队列中，索引v关联的值是edgeTo[v]的边的权重。</li></ul><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\即时的Prim.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">即时的Prim</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\即时的Prim1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">即时的Prim1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\即时的Prim2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">即时的Prim2</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\即时的Prim3.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">即时的Prim3</div></center><p>实现上述步骤的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Edge[] edgeTo;<span class="comment">//距离树最近的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[]distTo;<span class="comment">//distTo[w] = edgeTo[w].weight()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;<span class="comment">//如果v在树中则为true</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;<span class="comment">//有效的横切边</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)&#123;</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;&gt;(G.V());</span><br><span class="line">        distTo[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">        pq.insert(<span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">while</span> (! pq.isEmpty())</span><br><span class="line">            visit(G, pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (marked[w])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.weight() &lt; distTo[w])&#123;</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                distTo[w] = e.weight();</span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w))</span><br><span class="line">                    pq.changeKey(w, distTo[w]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pq.insert(w, distTo[w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Bag&lt;Edge&gt; mst = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; edgeTo.length; i++) &#123;</span><br><span class="line">            mst.add(edgeTo[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exercise 4.3.31</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distTo.length; i++) &#123;</span><br><span class="line">            weight += distTo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入图结构："</span>);</span><br><span class="line">        System.out.println(<span class="string">"节点个数V，边的个数E，边的三元组："</span>);</span><br><span class="line">        EdgeWeightedGraph graph = <span class="keyword">new</span> EdgeWeightedGraph(scanner);</span><br><span class="line">        LazyPrimMST mst = <span class="keyword">new</span> LazyPrimMST(graph);</span><br><span class="line">        <span class="keyword">for</span> (Edge e : mst.edges()) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mst.weight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kruskal算法">4.3.2 Kruskal算法</h3><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\kruskal算法1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">kruskal算法1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\kruskal算法2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">kruskal算法2</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\kruskal算法3.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">kruskal算法3</div></center><p>kruskal算法思想相当简单，kruskal算法构造最小生成树的时候也是一条边一条边地构造，但不同的是它寻找的边会连接一片森林的两棵树。我们从一片由V棵单顶点的树构成的森林开始并不断地将两棵树合并（用可以找到的最短边）直到只剩下一棵树，它就是最小生成树。代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kruskal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">kruskal</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> MinPQ&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G.edges()) &#123;</span><br><span class="line">            pq.insert(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (! pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - <span class="number">1</span>)&#123;</span><br><span class="line">            Edge e = pq.delMin();<span class="comment">//从pq得到权重最小的边和它的顶点</span></span><br><span class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(v, w)) <span class="keyword">continue</span>;<span class="comment">//忽略失效的边</span></span><br><span class="line">            uf.union(v, w);<span class="comment">//合并分量</span></span><br><span class="line">            mst.enqueue(e);<span class="comment">//将边添加到最小生成树中</span></span><br><span class="line">            weight += e.weight();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">(G)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</span><br><span class="line">        <span class="comment">// check total weight</span></span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : mst) &#123;</span><br><span class="line">            total += edge.weight();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(total - weight) &gt; <span class="number">1E-12</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"total weight not equal"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that it is acyclic</span></span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(G.V());</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : mst) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge.either(), w = edge.other(v);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(v, w)) &#123;</span><br><span class="line">                System.err.println(<span class="string">"it is not acyclic"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                uf.union(v, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that it is a spanning tree</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : G.edges()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge.either(), w = edge.other(v);</span><br><span class="line">            <span class="keyword">if</span> (!uf.connected(v, w)) &#123;</span><br><span class="line">                System.err.println(<span class="string">"it is not a spanning tree"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that it is a minimal spanning tree (cut optimality</span></span><br><span class="line">        <span class="comment">// conditions)</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : mst) &#123;</span><br><span class="line">            uf = <span class="keyword">new</span> UF(G.V());</span><br><span class="line">            <span class="keyword">for</span> (Edge e : mst) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = e.either(), w = e.other(v);</span><br><span class="line">                <span class="keyword">if</span> (e != edge) &#123;</span><br><span class="line">                    uf.union(v, w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Edge e : G.edges()) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = e.either(), w = e.other(v);</span><br><span class="line">                <span class="keyword">if</span> (!uf.connected(v, w) &amp;&amp; e.weight() &lt; edge.weight()) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"it is not a minimal spanning tree"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入图结构："</span>);</span><br><span class="line">        System.out.println(<span class="string">"节点个数V，边的个数E，边的三元组："</span>);</span><br><span class="line">        EdgeWeightedGraph graph = <span class="keyword">new</span> EdgeWeightedGraph(scanner);</span><br><span class="line">        kruskal kruskal = <span class="keyword">new</span> kruskal(graph);</span><br><span class="line">        <span class="keyword">for</span> (Edge s : kruskal.edges()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径">4.4 最短路径</h2><h3 id="dijkstra算法">4.4.1 Dijkstra算法</h3><p>最短路径就是<strong>找到从一个顶点到另一个顶点的成本最小的路径</strong>。最短路径的性质如下：</p><ul><li>路径是有向的，最短路径要考虑到各条边的方向</li><li>权重不一定等价于距离</li><li>并不是所有顶点都是可达的</li><li>负权重会使得问题更加复杂</li><li>最短路径一般都是简单的</li><li>最短路径不一定是惟一的</li><li>可能存在平行边或者自环</li></ul><p>本书的重点是单点最短路径问题，其中给出了起点s，计算的结果是一棵最短路径树(SPT)，它包含了顶点s到所有可达的顶点的最短路径。给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。</p><p>首先我们得要有个有向边的集合类，用来构建加权有向图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedEdge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;<span class="comment">//边的起点</span></span><br><span class="line">        <span class="keyword">this</span>.w = w;<span class="comment">//边的终点</span></span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">from</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DirectedEdge&#123;"</span> +</span><br><span class="line">                <span class="string">"v="</span> + v +</span><br><span class="line">                <span class="string">", w="</span> + w +</span><br><span class="line">                <span class="string">", weight="</span> + weight +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据有向边构建的有向图为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDigraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;<span class="comment">//顶点总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;<span class="comment">//边的总数</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;DirectedEdge&gt;[] adj;<span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        V = v;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;DirectedEdge&gt;[]) <span class="keyword">new</span> Bag[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i ++)&#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;DirectedEdge&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span><span class="params">(Scanner scanner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(scanner.nextInt());<span class="comment">//读取V并将图初始化，创建一个大小为V的图</span></span><br><span class="line">        <span class="keyword">int</span> E = scanner.nextInt();<span class="comment">//读取E</span></span><br><span class="line">        <span class="keyword">if</span> (E &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of edges must be nonnegative"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;<span class="comment">//添加一条边</span></span><br><span class="line">            <span class="keyword">int</span> v = scanner.nextInt();<span class="comment">//读取边的一个结点</span></span><br><span class="line">            <span class="keyword">int</span> w = scanner.nextInt();<span class="comment">//读取边的另一个节点</span></span><br><span class="line">            <span class="keyword">double</span> weight = scanner.nextDouble();</span><br><span class="line">            addEdge(<span class="keyword">new</span> DirectedEdge(v, w, weight));<span class="comment">//添加边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(DirectedEdge e)</span></span>&#123;</span><br><span class="line">        adj[e.from()].add(e);</span><br><span class="line">        E ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">edges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Bag&lt;DirectedEdge&gt; bag = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (DirectedEdge e : adj[v]) &#123;</span><br><span class="line">                bag.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"EdgeWeightedDigraph&#123;"</span> +</span><br><span class="line">                <span class="string">"V="</span> + V +</span><br><span class="line">                <span class="string">", E="</span> + E +</span><br><span class="line">                <span class="string">", adj="</span> + Arrays.toString(adj) +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最短路径的数据结构：</p><ul><li>最短路径树中的边。使用一个由顶点索引的DirectedEdge对象的父链接数组edgeTo[]，其中edgeTo[v]的值为树中连接v和它的父节点的边（也是从s到v的最短路径上的最后一条边）。</li><li>到达起点的距离。需要一个由顶点索引的数组distTo[]，其中distTo[v]为从s到v的已知的最短路径的长度。</li></ul><h4 id="边的松弛">4.4.1.1 边的松弛：</h4><p>一开始我们只知道图的边和他们的权重，distTo[]中只有起点对应的元素的值为0，其余元素的值均被初始化为double.POSITIVE_INFINITY.更新的时候会用到松弛技术，定义为：松弛<span class="math inline">\(v \to w\)</span>意味着检查从s到w的最短路径是否先从s到v，然后再从v到w。如果是的话，则根据这个情况更新数据结构的内容。由v到达w的最短路径是distTo[v]与e.weight()之和，如果这个值不小于distTo[w]，称这条边失效了并将它忽略。如果这个值更小，则更新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = e.from, w = e.to();</span><br><span class="line">    <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()))&#123;</span><br><span class="line">        distTo[w] = distTo[v] + e.weight();</span><br><span class="line">        edgeTo[w] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\边的松弛华.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">边的松弛化</div></center><h4 id="顶点的松弛">4.4.1.2 顶点的松弛</h4><p>实现顶点的松弛如下所示，从任意distTo[v]为有限值的顶点v指向任意distT[]为无穷的顶点的边都是有效的。如果v被放松，那么这些由小编都会被添加到edgeTo[]中。某条从起点指出的边将会是第一条被加入edgeTo[]中的边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge e : G.adj(v))&#123;</span><br><span class="line">        <span class="keyword">int</span> w = e.to();</span><br><span class="line">        <span class="keyword">if</span>(distTo[w] &gt; distTo[v] +e.weight())&#123;</span><br><span class="line">            distTo[w] = distTo[v] + e.weight();</span><br><span class="line">            e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\顶点的松弛.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">顶点的松弛</div></center><h4 id="图解和代码">4.4.1.3 图解和代码</h4><p>Dijkstra算法的图解流程主要如下，主要的思想就是在当前遍历到的节点更新其到要查找的权重距离，找出当前最小的，作为新添加的边。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\Dijkstra算法1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Dijkstra算法1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\Dijkstra算法2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Dijkstra算法2</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\Dijkstra算法3.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Dijkstra算法3</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\Dijkstra算法4.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Dijkstra算法4</div></center><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;<span class="comment">//到达的边，存的是连边的两个点，以及权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;<span class="comment">//与选定结点之间的距离</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;<span class="comment">//索引优先队列，保存需要被放松的顶点并确认下一个被放松的结点</span></span><br><span class="line">    <span class="comment">//IndexMinPQ可以将索引和键（优先级）关联起来并可以删除并返回优先级最低的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;&gt;(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)&#123;</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;<span class="comment">//除了跟自身的距离外，将所有的距离都初始化为无穷</span></span><br><span class="line">        pq.insert(s, <span class="number">0.0</span>);<span class="comment">//待松弛的顶点</span></span><br><span class="line">        <span class="keyword">while</span> (! pq.isEmpty())</span><br><span class="line">            relax(G, pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从v出发去改变其邻居的距离</span></span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;<span class="comment">//遍历邻居的连边</span></span><br><span class="line">            <span class="keyword">int</span> w = e.to();<span class="comment">//连边的另一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight())&#123;</span><br><span class="line">                <span class="comment">//如果选定结点到w的距离要大于通过其邻居到达的话，那么就更新</span></span><br><span class="line">                distTo[w] = distTo[v] + e.weight();</span><br><span class="line">                edgeTo[w] = e;<span class="comment">//记录边的时候只会记录上一跳</span></span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w))<span class="comment">//添加到索引优先队列中</span></span><br><span class="line">                    pq.changeKey(w, distTo[w]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pq.insert(w, distTo[w]);<span class="comment">//抛出最小的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPathTo(v))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from()])</span><br><span class="line">            path.push(e);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入图结构："</span>);</span><br><span class="line">        System.out.println(<span class="string">"节点个数V，边的个数E，边的三元组："</span>);</span><br><span class="line">        EdgeWeightedDigraph G = <span class="keyword">new</span> EdgeWeightedDigraph(scanner);</span><br><span class="line">        System.out.println(<span class="string">"请输入要查询的节点："</span>);</span><br><span class="line">        <span class="keyword">int</span> v = scanner.nextInt();</span><br><span class="line">        DijkstraSP sp = <span class="keyword">new</span> DijkstraSP(G, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            System.out.print(v + <span class="string">" to "</span> + i);</span><br><span class="line">            System.out.printf(<span class="string">" (%4.2f): "</span>, sp.distTo(i));</span><br><span class="line">            <span class="keyword">if</span> (sp.hasPathTo(i))&#123;</span><br><span class="line">                <span class="keyword">for</span> (DirectedEdge e : sp.pathTo(i)) &#123;</span><br><span class="line">                    System.out.print(e +<span class="string">"  "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现任意顶点之间的最短路径的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAllPairsSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DijkstraSP[] all;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraAllPairsSP</span><span class="params">(EdgeWeightedDigraph G)</span> </span>&#123;</span><br><span class="line">        all = <span class="keyword">new</span> DijkstraSP[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)&#123;</span><br><span class="line">            all[v] = <span class="keyword">new</span> DijkstraSP(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">path</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> all[s].pathTo(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> all[s].distTo(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-ford算法">4.4.2 Bellman-Ford算法</h3><p>这个算法适用于无环加权图中，它的特点是：</p><ul><li>能够在线性时间内解决单点最短路径问题</li><li>能够处理负权重的边</li><li>能够解决相关的问题</li></ul><h4 id="无环加权图的最短路径树">4.4.2.1 无环加权图的最短路径树</h4><p>在查找无环加权图的最短路径树的时候，可以使用以下的方法。这个方法首先通过深度优先搜索得到顶点的拓扑排序，然后根据这个去遍历节点，并更新使得路径最短，如下面的图所示：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\无环加权有向图最短路径1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">无环加权有向图最短路径1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\无环加权有向图最短路径2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">无环加权有向图最短路径2</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\无环加权有向图最短路径3.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">无环加权有向图最短路径3</div></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcyclicSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcyclicSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        EdgeWeightedTopological top = <span class="keyword">new</span> EdgeWeightedTopological(G);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : top.order()) &#123;</span><br><span class="line">            relax(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.to();</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</span><br><span class="line">                distTo[w] = distTo[v] + e.weight();</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> Stack&lt;DirectedEdge&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from()]) &#123;</span><br><span class="line">            path.push(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入图结构："</span>);</span><br><span class="line">        System.out.println(<span class="string">"节点个数V，边的个数E，边的三元组："</span>);</span><br><span class="line">        EdgeWeightedDigraph G = <span class="keyword">new</span> EdgeWeightedDigraph(scanner);</span><br><span class="line">        System.out.println(<span class="string">"请输入开始的结点："</span>);</span><br><span class="line">        <span class="keyword">int</span> s = scanner.nextInt();</span><br><span class="line">        AcyclicSP sp = <span class="keyword">new</span> AcyclicSP(G, s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" to "</span> + i);</span><br><span class="line">            System.out.printf(<span class="string">" (%4.2): "</span>, sp.distTo(i));</span><br><span class="line">            <span class="keyword">if</span> (sp.hasPathTo(i))&#123;</span><br><span class="line">                <span class="keyword">for</span> (DirectedEdge e : sp.pathTo(i)) &#123;</span><br><span class="line">                    System.out.print(e + <span class="string">"  "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一类问题是考虑在无环加权有向图中寻找最长路径的问题，边的权重可正可负。解决无环加权有向图中的最长路径问题的时间与<span class="math inline">\(E+V\)</span>成正比。</p><h4 id="图解和代码-1">4.4.2.2 图解和代码</h4><p>bellman-ford算法对图进行<span class="math inline">\(V-1\)</span>次的松弛操作，得到所有可能的最短路径。其优于Dijkstra算法的地方在于边的权重可以是负值，实现简单。但是缺点就是时间复杂度高，需要<span class="math inline">\(O(VE)\)</span>。Dijkstra算法关注的是点，而bellman-ford关注的是边。</p><p>算法描述为：</p><ul><li>创建源顶点v到图中所有顶点的距离的集合，为图中的所有顶点指定一个距离值，初始化均为无穷，源顶点的距离为0；</li><li>计算最短路径，执行<span class="math inline">\(V-1\)</span>次遍历<ul><li>对于图中的每条边：如果起点u的距离d加上边的权值w小于终点v的距离d，则更新终点v的距离值d；</li></ul></li><li>检测图中是否有负权边形成了环，遍历图中的所有边，计算u至v的距离，如果对于v存在更小的距离，则说明存在环。</li></ul><p>bellman-ford算法的图解如下：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\bellman-ford算法1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">bellman-ford算法1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\bellman-ford算法2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">bellman-ford算法2</div></center><p>bellman-ford算法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFordSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;<span class="comment">//从起点到某个顶点的路径长度</span></span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;<span class="comment">//从起点到某个顶点的最后一条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onQ;<span class="comment">//该顶点是否存在于队列中</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;<span class="comment">//正在被放松的顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;<span class="comment">//relax()的调用次数</span></span><br><span class="line">    <span class="keyword">private</span> Iterable&lt;DirectedEdge&gt; cycle;<span class="comment">//edgeTo[]中的是否有负权重环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BellmanFordSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        onQ = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)&#123;</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;<span class="comment">//初始化，除了本身外都是无穷</span></span><br><span class="line">        &#125;</span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        queue.enqueue(s);<span class="comment">//将当前的结点放入队列中</span></span><br><span class="line">        onQ[s] = <span class="keyword">true</span>;<span class="comment">//当前节点在队列中</span></span><br><span class="line">        <span class="keyword">while</span> (! queue.isEmpty() &amp;&amp; ! hasNegativeCycle())&#123;<span class="comment">//在没有环并且queue不是empty的情况下</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue();<span class="comment">//排出队列中的元素，先进先出，每次都是更新在当前队列中的所有顶点</span></span><br><span class="line">            onQ[v] = <span class="keyword">false</span>;<span class="comment">//节点置为false</span></span><br><span class="line">            relax(G, v);<span class="comment">//进行松弛</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;<span class="comment">//遍历待松弛节点的所有边，一阶邻居</span></span><br><span class="line">            <span class="keyword">int</span> w = e.to();<span class="comment">//得到可以到达当前节点的点</span></span><br><span class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight())&#123;<span class="comment">//比原来的小就更新了</span></span><br><span class="line">                distTo[w] = distTo[v] + e.weight();</span><br><span class="line">                edgeTo[w] = e;<span class="comment">//edgeTo[]也得更新，表示达到w是要经过e这条边的</span></span><br><span class="line">                <span class="keyword">if</span> (! onQ[w])&#123;<span class="comment">//如果w不在队列中，要么就是被排出来了，要么还没遍历到</span></span><br><span class="line">                    queue.enqueue(w);<span class="comment">//那么就加入</span></span><br><span class="line">                    onQ[w] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cost++ % G.V() == <span class="number">0</span>)&#123;<span class="comment">//调用松弛已经到达了节点的个数的次数</span></span><br><span class="line">                findNegativeCycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPathTo(v))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from()])&#123;</span><br><span class="line">            path.push(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNegativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = edgeTo.length;<span class="comment">//调用了节点个数那么多次的relax，此时有多少个结点在edgeTo里面</span></span><br><span class="line">        EdgeWeightedDigraph spt = <span class="keyword">new</span> EdgeWeightedDigraph(V);<span class="comment">//新建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (edgeTo[v] != <span class="keyword">null</span>)</span><br><span class="line">                spt.addEdge(edgeTo[v]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EdgeWeightedCycleFinder cf = <span class="keyword">new</span> EdgeWeightedCycleFinder(spt);</span><br><span class="line">        cycle = cf.cycle();<span class="comment">//就是判断当前是否存在了环了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;<span class="comment">//没有成环的时候返回为false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">negativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串">5. 字符串</h1><h2 id="字符串排序">5.1 字符串排序</h2><p>字符串的排序主要有两种：</p><ul><li>第一种方法会从右到左检查键中的字符，这种方法一般称为低位优先(LSD)的字符串排序。如果将一个字符串看做一个256进制的数字，那么从右向左检查字符串就等价于先检查数字的最低位。这种方法最适合用于键的长度都相同的字符串排序的应用。</li><li>第二种方法会从左到右检查键中的字符，首先查看的是最高位的字符。这些方法通常称为高位优先(MSD)的字符串排序。高位优先的字符串排序和快速排序类似，因为他们都会将需要排序的数组且分为独立的部分并递归的用相同的方法处理子数组来完成排序。他们的区别在于高位优先的字符串排序算法在切分的时候仅使用键的第一个字符，而快速排序的比较则会涉及键的全部。</li></ul><h3 id="键索引计数法">5.1.1 键索引计数法</h3><p>适用于小整数键的简单排序方法，假设数组<span class="math inline">\(a[]\)</span>中的每个元素都保存了一个名字和一个组号，其中组号在0到R-1之间，以组号为键进行分组排序。</p><ul><li>频率统计：使用int型数组计算每个键出现的频率；</li><li>数据分类：将<span class="math inline">\(count[]\)</span>来计算每个键在排序结果中的起始位置；</li><li>回写：将排序数组<span class="math inline">\(aux[]\)</span>结果复制回原数组；</li><li>命题：键索引计数法排序N个键为0到R-1之间的整数的元素需要访问数组<span class="math inline">\(11N+4R+1\)</span>次；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chapter5.Part5_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIndex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="string">"cac"</span>, <span class="number">2</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">"fnc"</span>, <span class="number">2</span>);</span><br><span class="line">        Student stu3 = <span class="keyword">new</span> Student(<span class="string">"edb"</span>, <span class="number">4</span>);</span><br><span class="line">        Student stu4 = <span class="keyword">new</span> Student(<span class="string">"oel"</span>, <span class="number">0</span>);</span><br><span class="line">        Student stu5 = <span class="keyword">new</span> Student(<span class="string">"akf"</span>, <span class="number">2</span>);</span><br><span class="line">        Student stu6 = <span class="keyword">new</span> Student(<span class="string">"erk"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Student[] stus = &#123; stu1, stu2, stu3, stu4, stu5, stu6 &#125;;</span><br><span class="line">        sort(stus, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            System.out.println(stus[i].toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Student[] a, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        Student[] aux = <span class="keyword">new</span> Student[N];</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步：计算出现的概率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            count[a[i].getKey() + <span class="number">1</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：将概率转换为索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            count[i + <span class="number">1</span>] += count[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：将元素分类</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            aux[count[a[i].getKey()]++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四步：回写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", key="</span> + key +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下索引计数法的四个步骤：</p><p>1.计算频率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    count[a[i].charAt(d) + <span class="number">1</span>]++;</span><br></pre></td></tr></table></figure><p>遍历所有的字符串，d为字符串的第d个字符。也就是统计每个字符的个数。</p><p>2.将频率转换为下标，也就是count数组中后一位总是加上前一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count[r+<span class="number">1</span>] += count[r];</span><br></pre></td></tr></table></figure><p>3.数据分类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    aux[count[a[i].charAt(d)]++]=a[i];</span><br></pre></td></tr></table></figure><p>需要一个辅助数组aux，用来暂时存储排序的数据。把数据放入辅助字符串数组，全部放入时已经形成有序了。</p><h3 id="低位优先的字符串排序">5.1.2 低位优先的字符串排序</h3><p>如果字符串的长度均为W，那就从右向左以每个位置的字符作为键，用索引计数法将字符串排序W遍。低位优先字符串排序从右向左检查字符，要求待排序的字符串长度一致。</p><p>低位优先字符排序和基数排序非常的相似，假设字符串长度为W，首先以最低位W-1为键进行排序，再以W-2位为键进行排序,......，直到以0位为键进行排序，此时排序的结果就是最终的结果。低位优先字符串排序是稳定排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过前W个字符将a[]排序</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        String[] aux = <span class="keyword">new</span> String[N];<span class="comment">//构建一个与原数组等长的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = W - <span class="number">1</span>;d &gt;= <span class="number">0</span>; d--)&#123;<span class="comment">//从低位开始排</span></span><br><span class="line">            <span class="comment">//循环内是一个键索引</span></span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;<span class="comment">//统计频率</span></span><br><span class="line">                count[a[i].charAt(d) + <span class="number">1</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将频率转换为索引，使用count[]来计算每个键在排序结果中的起始位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">                count[r + <span class="number">1</span>] += count[r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将元素分类，将所有的元素移动到一个辅助数组aux[]进行排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                aux[count[a[i].charAt(d)]++] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                a[i] = aux[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="高位优先的字符串排序">5.1.3 高位优先的字符串排序</h3><p>要实现一个通用的字符串排序算法（字符串的长度不一定相同），应该考虑从左向右遍历所有的字符。实现这种思想的一个很自然的方法就是一种递归算法，就是高位优先的字符串排序(MSD)。首先用键索引计数法将所有的字符串按照首字母排序，然后(递归地)再将每个首字母所对应的子数组排序（忽略首字母，因为每一类中的所有字符串的首字母都是相同的）。和快速排序一样，高位优先的字符会分为每个首字母得到一个子数组，而不是像快速排序中那样产生固定的两个或三个划分。</p><p>有个需要注意的情况就是到达字符串末尾的情况，在排序中合理的做法就是将所有的字符都已被检查过的字符串所在的子数组排在所有子数组的前面，这样就不需要递归地将该子数组排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSD</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;<span class="comment">//基数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">15</span>;<span class="comment">//小数组的切换阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] aux;<span class="comment">//数组分类的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将字符串中字符索引转化为数组索引，当指定的位置超过了字符串的末尾时该方法返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d &lt; s.length())</span><br><span class="line">            <span class="keyword">return</span> s.charAt(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> String[N];</span><br><span class="line">        sort(a, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//以第d个字符为键将a[lo]至a[hi]进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo + M)&#123;</span><br><span class="line">            Insertion.sort(a, lo, hi, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="comment">//将所有的返回值加1，得到一个非负的int值并用它作为count[]的索引</span></span><br><span class="line">            count[charAt(a[i], d)+<span class="number">2</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R + <span class="number">1</span>; r++)&#123;</span><br><span class="line">            count[r + <span class="number">1</span>] += count[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= lo; i ++)&#123;</span><br><span class="line">            a[i] = aux[i - lo];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++)&#123;</span><br><span class="line">            sort(a, lo + count[r], lo + count[r + <span class="number">1</span>] - <span class="number">1</span>, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三向字符串快速排序">5.1.4 三向字符串快速排序</h3><p>三向字符串快速排序根据的仍然是根据键的首字母并使用递归方法将其余部分的键排序。它特别适用于较长的含有公共前缀的字符串，并且不需要任何额外的空间。</p><p>具体的做法如下：</p><ul><li>用一个字符作为中间字符，本文默认选择字符串的第一个字符作为中间字符，比它大的转移到字符串数组的末尾，比它小的转移到它的前面。</li><li>这样遍历之后会形成三个小组，里面的字符串开头字母分为小于中间字符，等于中间字符，大于中间字符。对分类的三个字符串数组逐一进行步骤1直到字符串中的字符全部遍历。最后形成的字符串自然有序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3string</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; s.length())</span><br><span class="line">            <span class="keyword">return</span> s.charAt(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, gt = hi;</span><br><span class="line">        <span class="keyword">int</span> v = charAt(a[lo],d);<span class="comment">//取出a[lo]的第d位的字符</span></span><br><span class="line">        <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = charAt(a[i],d);</span><br><span class="line">            <span class="keyword">if</span> (t &lt; v)</span><br><span class="line">                exch(a, lt++, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; v)</span><br><span class="line">                exch(a, gt--, i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t ++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>, d);</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span>)</span><br><span class="line">            sort(a, lt, gt, d + <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词查找树">5.2 单词查找树</h2><p>这里讨论的查找算法一般能够实现以下的性能：</p><ul><li>查找命中所需的时间与被查找的键的长度成正比；</li><li>查找未命中只需查找若干字符。</li></ul><p>和其他的树一样的，单词查找树也是由链接组成的数据结构，这些链接可能为空，也可能指向其他的结点。每个结点都只可能有一个指向它的结点，称为它的父节点，当然根结点是没有的。单词查找树一般都包含大量的空链接，因此在绘制一颗单词查找树时一般会忽略空链接。<strong>值为空的结点在符号表中没有对应的键，它的存在是为了简化单词查找树中的查找操作。</strong></p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\单词查找树的结构.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">单词查找树的结构</div></center><ul><li>单词查找树的查找操作</li></ul><p>从根结点开始，首先经过的是键的首字母对应的链接；在下一个节点中沿着第二个字符所对应的链接继续前进；在第二个节点中沿着第三个字符对应的链接向前，这样知道达到键的最后一个字母所指向的结点或是遇到了一条空链接。这时候会出现三种情况：（1）键的尾字符对应的结点中的值非空，这是一次命中的查找，键所对应的值就是键的尾字符所对应的节点中保存的值。（2）键的尾字符所对应的结点的值为空，这是一次未命中的查找，符号表中不存在被查找的键。（3）查找结束于一条空链接，这也是一次未命中的查找。</p><ul><li>单词查找树的插入操作</li></ul><p>在插入之前要进行一次查找：在单词查找树中沿着被查找的键的所有字符到达树中表示尾字符的结点或者一个空链接。此时会出现两种情况：（1）在到达尾字符之前就遇到了一个空链接。在这种情况下，单词查找树中不存在与键的尾字符对应的节点，因此要为键中还未被检查的每个字符创建一个对应的结点并将键的值保存到最后一个字符的结点中。（2）在遇到空链接之前就到达了键的尾字符，在这种情况下，和关联数组一样，将该结点的值设置为键所对应的值。</p><ul><li>结点的表示</li></ul><p>每个节点都含有R个链接，对应着每个可能出现的字符，字符和键均隐式的保存在数据结构中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;<span class="comment">//新建一个单词查找树节点的结构</span></span><br><span class="line">        <span class="keyword">private</span> Object val;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[R];<span class="comment">//下一串节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span></span>&#123;<span class="comment">//获取键对应的值</span></span><br><span class="line">        <span class="comment">//找到以root为根结点的子单词查找树中与key相关联的值</span></span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);<span class="comment">//d表示的是第d个字符</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value) x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回以x作为根结点的子单词查找树中与key相关联的值</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length())</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);<span class="comment">//找到第d个字符所对应的子单词查找树</span></span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">if</span> (d == key.length())&#123;<span class="comment">//直接改变这个key对应的值即可</span></span><br><span class="line">            x.val = val;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);<span class="comment">//一直往后面添加即可，直到把key的所有字符都添加结束了</span></span><br><span class="line">        x.next[c] = put(x.next[c], key, val, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.val != <span class="keyword">null</span>)</span><br><span class="line">            cnt ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            cnt += size(x.next[c]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keysWithPrefix(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">        collect(get(root, pre, <span class="number">0</span>), pre, q);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String pre, Queue&lt;String&gt; q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (x.val != <span class="keyword">null</span>)</span><br><span class="line">            q.enqueue(pre);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            collect(x.next[c], pre + c, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysThatMatch</span><span class="params">(String pat)</span></span>&#123;<span class="comment">//通配符匹配</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        collect(root, <span class="string">""</span>, pat, q);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String pre, String pat, Queue&lt;String&gt; q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = pre.length();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == pat.length() &amp;&amp; x.val != <span class="keyword">null</span>)</span><br><span class="line">            q.enqueue(pre);</span><br><span class="line">        <span class="keyword">if</span> (d == pat.length())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span> next = pat.charAt(d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">'.'</span> || next == c)</span><br><span class="line">                collect(x.next[c], pre + c, pat, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = search(root, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Node x, String s, <span class="keyword">int</span> d, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        <span class="keyword">if</span> (x.val != <span class="keyword">null</span>)</span><br><span class="line">            length = d;</span><br><span class="line">        <span class="keyword">if</span> (d == s.length())</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(d);</span><br><span class="line">        <span class="keyword">return</span> search(x.next[c], s, d + <span class="number">1</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        root = delete(root, key, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length())</span><br><span class="line">            x.val = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">            x.next[c] = delete(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x.val != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.next[c] != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三相单词查找树">5.2.1 三相单词查找树</h3><p>为了避免R向单词查找树过度的空间消耗，使用另一种叫做三向单词查找树。在三向单词查找树中每个节点都含有一个字符、三条链接和一个值。这三条链接分别表示的是当前字母小于、等于和大于节点字母的所有键。在等价的三向单词查找树中，字符是显式地保存在结点中的，只有在沿着中间连接前进时才会根据字符找到表中的键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        Node left, mid, right;</span><br><span class="line">        Value val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value) x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c)</span><br><span class="line">            <span class="keyword">return</span> get(x.left, key, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c)</span><br><span class="line">            <span class="keyword">return</span> get(x.right, key, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> get(x.mid, key, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x = <span class="keyword">new</span> Node();</span><br><span class="line">            x.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) &#123;</span><br><span class="line">            x.left = put(x.left, key, val, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) &#123;</span><br><span class="line">            x.right = put(x.right, key, val, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            x.mid = put(x.mid, key, val, d + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exercise 5.2.9</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Node x = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; i &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; x.c) &#123;</span><br><span class="line">                x = x.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) &#123;</span><br><span class="line">                x = x.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    length = i;</span><br><span class="line">                &#125;</span><br><span class="line">                x = x.mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keysWithPrefix(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        collect(get(root, pre, <span class="number">0</span>).mid, pre, q);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String pre, Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q.enqueue(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        collect(x.left, pre, q);</span><br><span class="line">        collect(x.right, pre, q);</span><br><span class="line">        collect(x.mid, pre + x.c, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysThatMatch</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        collect(root, <span class="string">""</span>, pat, q);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String pre, String pat, Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = pre.length();</span><br><span class="line">        <span class="keyword">char</span> c = pat.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span> || c &lt; x.c) &#123;</span><br><span class="line">            collect(x.left, pre, pat, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span> || c &gt; x.c) &#123;</span><br><span class="line">            collect(x.right, pre, pat, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span> || c == x.c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> == pat.length() &amp;&amp; x.val != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.enqueue(pre + c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> &lt; pat.length()) &#123;</span><br><span class="line">                collect(x.mid, pre + c, pat, q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子字符串查找">5.3 子字符串查找</h2><p>这个功能在windows中就是ctrl + F实现的功能，给定一个长度为N的文本和一段长度为M的模式字符串，在文本中找到一个和该模式相符的子字符串。</p><h3 id="kmp算法">KMP算法</h3><p>KMP算法的核心就是：利用匹配失败后的信息，尽量减少模式串与主串的匹配次数，以达到快速匹配的目的。</p><p>这本书中讲的有点看不太懂了。。。先来个一维数组的易于理解点的。详见[<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">从头到尾彻底理解KMP（2014年8月22日版）_v_JULY_v的博客-CSDN博客_串的next数组怎么求</a>]。</p><p>现在假设文本串S匹配到了i位置，模式串P匹配到了j位置：</p><ul><li>如果j = -1，或者当前字符字符匹配成功，也就是S[i] == P[j]，都令i++, j++，继续匹配下一个字符；</li><li>如果j != -1，且当前字符匹配失败，也就是S[i] != P[j]，则令i不变，j=next[j]。此举意味着失配时，模式串P相对于文本串S右移j-next位。也就是，当匹配失败的时候，模式串向右移动的位数为：失配字符所在的位置-失配字符对应的next值，即移动的实际位数为: j-next[j]，且此值大于等于1.</li></ul><p>这个next数组的意义就是：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。这里说的前缀就是包含首字母不包含尾字母的所有子串，后缀就是包含尾字母不包含首字母的所有子串。对于模式串aabaaf，前缀有a,aa,aab,aaba,aabaa，后缀有f,af,aaf,baaf,abaaf。[https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md]</p><p><img src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source_posts\算法笔记\KMP字符串匹配.gif"></p><p>这个匹配的过程大概就是说，我一个一个匹配，aabaa都是能匹配上的，但是f这个位置是匹配失败的。这个时候，f前面的字符串就是aabaa，这个字符串它的最长的相同前后缀就是2，也就是aa。我们匹配失败的位置是后缀子串的后面，那么KMP要跳转的位置就是找到与其相同的前缀的后面就好了。<strong>得看图多理解几遍，这地方是为了用之前的信息来找到新的开始的匹配的地点。所以最长的前缀有利于更快的定位。</strong></p><p>那么怎么计算前缀表呢？前缀表的意思就是说最长前缀和后缀相同的一个数值。比方说，还是上面的模式串，a的最长相同前后缀是0（因为前缀不包含最后一个字符但是必须包含首字符，后缀不包含首字符但是包含末尾字符，看的顺序还是从左到右的），aa的最长前后缀为1，aab就是0，aaba就是1，aabaa就是2，aabaaf的最长相同前后缀就是0。那么把这个前缀表当做next数组，就能够实现KMP算法。</p><p>[https://leetcode.cn/problems/implement-strstr/]这个力扣匹配字符串的代码就可以如下的写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">        getNext(next, needle);<span class="comment">//构建前缀表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i))</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(j) == haystack.charAt(i))</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.length())</span><br><span class="line">                <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] next, String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里的i指向前缀的末尾位置，j指向后缀的末尾位置</span></span><br><span class="line">        <span class="comment">//这里的j也是表示最长的前后缀长度</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化默认为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i ++)&#123;<span class="comment">//遍历到第i个字符</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i))<span class="comment">// 没有匹配上，一直等到匹配上，匹配使用j &gt; 0,表示一旦回退到初始位置就没有地方可以继续回退了，所以跳出循环</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];<span class="comment">// 回退到前一个字符的前缀表的值的位置继续匹配</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i))<span class="comment">// 前后缀相同的情况，就把</span></span><br><span class="line">                j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串匹配的过程中，使用指针i来追踪文本，一个指针j来跟踪模式。《算法第四版》中使用一个数组<span class="math inline">\(dfa[][]\)</span>来记录匹配失败时模式指针j应该回退多远。对于每个字符c，在比较了c和pattern.charAt(j)之后，<span class="math inline">\(dfa[c][j]\)</span>表示的是应该和下个文本字符串比较的模式的位置。（也就是说要回退的位置）在查找中，<span class="math inline">\(dfa[txt.charAt(i)][j]\)</span>是在比较了txt.charAt(i)和pat.charAt(j)之后应该和txt.charAt(i + 1)比较的位置。</p><p><strong>一般网上的教程都是用的一维数组来表示回退，本书使用二维应该是还要实现一个查找的功能，所以把字符也给带上了。</strong></p><h2 id="正则表达式">5.4 正则表达式</h2><p>正则表达式是一种强大的字符串查找程序，能够在长度为N的文本字符串中匹配长度为M的复杂模式。在最坏的情况下，它所需要的时间与MN成正比。</p><h3 id="使用正则表达式的描述模式">5.4.1 使用正则表达式的描述模式</h3><ul><li>连接操作：当我们写出AB时，就指定了一种语言{AB}，它含有一个由两个字符组成的字符串，由A和B连接而成。</li><li>或操作：可以在模式中指定多个可能的情况匹配。用|来表示这个操作，比如A|B表示的是{A,B}。连接操作的优先级高于或操作，因此AB|BCD表示的是{AB,BCD}</li><li>闭包操作：闭包操作可以将模式的部分重复任意的次数。模式的闭包是由将模式和自身连接任意多次而得到的所有字符串组成的语言。将<em>标记在需要被重复的模式之后，以表示闭包。闭包的优先级高于连接操作，因此AB</em>指定一个由A和0个或多个B字符串组成。而A*B指定由0个或多个A和一个B的字符串组成。</li><li>括号：改变默认的优先级顺序。</li></ul><h3 id="缩略写法">5.4.2 缩略写法</h3><ul><li>字符集描述符</li></ul><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">记法</th><th style="text-align: center;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">通配符</td><td style="text-align: center;">任意的字符</td><td style="text-align: center;">A.B</td></tr><tr class="even"><td style="text-align: center;">指定的集合</td><td style="text-align: center;">包含在[]中的字符</td><td style="text-align: center;">[AEIOU]*</td></tr><tr class="odd"><td style="text-align: center;">范围集合</td><td style="text-align: center;">包含在[]中，由"."分割</td><td style="text-align: center;">[A-Z] [0-9]</td></tr><tr class="even"><td style="text-align: center;">补集</td><td style="text-align: center;">包含在[]中，首字母为"^"</td><td style="text-align: center;">[^AEIOU]*</td></tr></tbody></table><p>这里需要说明的是，^表示两种意思。</p><p>^hello会匹配hello开头的行。</p><p>[^a-z]表示的是任意一位非小写的字母。</p><ul><li>闭包的简写</li></ul><table><thead><tr class="header"><th style="text-align: center;">选项</th><th style="text-align: center;">记法</th><th style="text-align: center;">举例</th><th style="text-align: center;">原始写法</th><th style="text-align: center;">语言中的字符串</th><th style="text-align: center;">不在语言中</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">至少重复一次</td><td style="text-align: center;">+</td><td style="text-align: center;">(AB)+</td><td style="text-align: center;">(AB)(AB)*</td><td style="text-align: center;">AB ABABAB</td><td style="text-align: center;">∈ BBBAAA</td></tr><tr class="even"><td style="text-align: center;">重复0次或一次</td><td style="text-align: center;">?</td><td style="text-align: center;">(AB)?</td><td style="text-align: center;">∈|AB</td><td style="text-align: center;">∈AB</td><td style="text-align: center;">所有其他字符串</td></tr><tr class="odd"><td style="text-align: center;">重复指定次数</td><td style="text-align: center;">由{}指定次数</td><td style="text-align: center;">(AB){3}</td><td style="text-align: center;">(AB)(AB)(AB)</td><td style="text-align: center;">ABABAB</td><td style="text-align: center;">所有其他字符串</td></tr><tr class="even"><td style="text-align: center;">重复指定范围次数</td><td style="text-align: center;">由{}指定范围</td><td style="text-align: center;">(AB){1-2}</td><td style="text-align: center;">(AB)|(AB)(AB)</td><td style="text-align: center;">AB ABAB</td><td style="text-align: center;">所有其他字符串</td></tr></tbody></table><ul><li>转义序列：这些跟C语言的转义字符一样的。</li></ul><h3 id="非确定有限状态自动机">5.4.3 非确定有限状态自动机</h3><p>正则表达式模式匹配程序的总体结构和KMP算法的总体结构几乎相同：</p><ul><li>构造和给定正则表达式相对应的非确定有限状态机</li><li>模拟NFA在给定文本上的运行轨迹</li></ul><p>kleene定理：<strong>对于任意正则表达式都存在一个与之对应的非确定有限状态机，反之亦然。</strong></p><p>NFA有着以下的特点：</p><ul><li>长度为M的正则表达式中的每个字符所对应的NFA中只有一个对应的状态。NFA的起始状态为0并且含有一个虚拟的接收状态M。</li><li>字母表中的字符所对应的状态都有一条从它指向的边，这条边指向模式中下一个字符所对应的状态。</li><li>元字符"(",")","|"和"*"所对应的状态至少含有一条指出的边。（红色的）</li><li>有些状态有多条指出的边，但一个状态只能有一条指出的黑色边。</li></ul><p><img src="../images/正则表达式NFA.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Chapter1.Part1_3.Bag;</span><br><span class="line"><span class="keyword">import</span> Chapter1.Part1_3.Stack;</span><br><span class="line"><span class="keyword">import</span> Chapter4.Part4_2.DiGraph;</span><br><span class="line"><span class="keyword">import</span> Chapter4.Part4_2.DirectedDFS;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NFA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] re; <span class="comment">//匹配转换</span></span><br><span class="line">    <span class="keyword">private</span> DiGraph G; <span class="comment">//epsilon转换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">//状态数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NFA</span><span class="params">(String regexp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据给定的正则表达式构造NFA</span></span><br><span class="line">        Stack&lt;Integer&gt; ops = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        re = regexp.toCharArray();</span><br><span class="line">        M = re.length;</span><br><span class="line">        G = <span class="keyword">new</span> DiGraph(M + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> lp = i;</span><br><span class="line">            <span class="keyword">if</span> (re[i] == <span class="string">'('</span> || re[i] == <span class="string">'|'</span>)</span><br><span class="line">                ops.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (re[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> or = ops.pop();</span><br><span class="line">                <span class="keyword">if</span> (re[or] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                    lp = ops.pop();</span><br><span class="line">                    G.addEdge(lp, or + <span class="number">1</span>);</span><br><span class="line">                    G.addEdge(or, i);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    lp = or;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; M - <span class="number">1</span> &amp;&amp; re[i + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                G.addEdge(lp, i + <span class="number">1</span>);</span><br><span class="line">                G.addEdge(i + <span class="number">1</span>, lp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (re[i] == <span class="string">'('</span> || re[i] == <span class="string">'*'</span> || re[i] == <span class="string">')'</span>)</span><br><span class="line">                G.addEdge(i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">recognizes</span><span class="params">(String txt)</span></span>&#123;</span><br><span class="line">        Bag&lt;Integer&gt; pc = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        DirectedDFS dfs = <span class="keyword">new</span> DirectedDFS(G, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs.marked(v))</span><br><span class="line">                pc.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; txt.length(); i++) &#123;</span><br><span class="line">            Bag&lt;Integer&gt; match = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Integer v : pc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v &lt; M)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (re[v] == txt.charAt(i) || re[v] == <span class="string">'.'</span>)</span><br><span class="line">                        match.add(v + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pc = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">            dfs = <span class="keyword">new</span> DirectedDFS(G, match);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs.marked(v))</span><br><span class="line">                    pc.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer v : pc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == M)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据压缩">5.5 数据压缩</h2><h3 id="游程编码">5.5.1 游程编码</h3><p>游程编码是一种很简单的无损数据压缩算法，该算法的实现是用当前数据元素及该元素连续出现的次数来取代字符串连续出现的数据部分。例如aaaaaaaaaabbbaxxxxyyyzyx可以表示为：a10b3a1x4y3z1y1x1。但是这样的话又让出现1次的字符的长度变长了。所以当只出现1次的时候就不用带上数字了：a10b3ax4y3zyx。</p><p>这个方法的一种变种就是对位置进行计数，这样字符串就能压缩为：a0b10a13x14y18z21y22x23。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunLength</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!BinaryStdIn.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> cnt = BinaryStdIn.readChar();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                BinaryStdOut.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            b = !b;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b, old = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (! BinaryStdIn.isEmpty())&#123;</span><br><span class="line">            b = BinaryStdIn.readBoolean();</span><br><span class="line">            <span class="keyword">if</span>(b != old)&#123;</span><br><span class="line">                BinaryStdOut.write(cnt);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                old = !old;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">255</span>)&#123;</span><br><span class="line">                    BinaryStdOut.write(cnt);</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    BinaryStdOut.write(cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.write(cnt);</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="霍夫曼编码">5.5.2 霍夫曼编码</h3><p>霍夫曼编码是一种可变字长编码，满足前缀编码，即某个字符的编码都不能是其他字符编码的前缀编码，因此不会造成匹配的多义性。</p><p>假设要压缩go big or go home</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\霍夫曼编码.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">霍夫曼编码</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\霍夫曼编码1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">霍夫曼编码1</div></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Huffman</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">        Byte data; <span class="comment">//存放数据</span></span><br><span class="line">        <span class="keyword">int</span> weight; <span class="comment">//权重</span></span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                    <span class="string">"data="</span> + data +</span><br><span class="line">                    <span class="string">", weight="</span> + weight +</span><br><span class="line">                    <span class="string">", left="</span> + left +</span><br><span class="line">                    <span class="string">", right="</span> + right +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.left.PreOrder();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.right.PreOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)</span><br><span class="line">            root.PreOrder();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"哈夫曼树为空！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过list创建对应的哈夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出权值最小的两个二叉树</span></span><br><span class="line">            Node left = nodes.get(<span class="number">0</span>);</span><br><span class="line">            Node right = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, left.weight + right.weight);</span><br><span class="line">            parent.left = left;</span><br><span class="line">            parent.right = right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除已经删除处理的二叉树</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            <span class="comment">//添加新的二叉树</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回根结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数</span></span><br><span class="line">        HashMap&lt;Byte, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            map.put(b, map.getOrDefault(b, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Byte&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Byte b : set) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(b, map.get(b)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">"ni haishiaof hioaj hofea"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        Node root = createHuffmanTree(nodes);</span><br><span class="line">        PreOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lzw算法">5.5.3 LZW算法</h3><p>LZW算法的基础是维护一张字符串键和（定长）编码的编译表。在符号表中将128个单字符键的值初始化为8位编码，即在每个字符的7位钱添加一个0.为了简单明了，用16进制来表示编码的值，这样ASCII的A的编码即为41，R的编码为52等。将80保留为文件结束的标志并将其余的编码值(81-FF)分配给在输入中遇到的各种子字符串，即从81开始不断为新键赋予更大的编码值。为了压缩数据，只要输入还未结束，就会不断进行以下操作：</p><ul><li>找出未处理的输入在符号表中最长的前缀字符串s</li><li>输出s的8位值</li><li>继续扫描s之后的一个字符c</li><li>在符号表中将s+c（连接s和c）的值设置为下一个编码值</li></ul><p>比方说如果要压缩字符串ABABAB，比方说我们用2表示AB，那么就压缩为AB22，如果用0表示A，1表示B，符号流应该表示为0122。在真正的LZW压缩中，AB都是用他们的ASCII码表示。LZW初始会有一个默认的字典，包含了256个8bit字符，单个字符的记号就是它自身，也就是ASCII码了。在此基础上，编码过程中加入新的记号的映射，从256开始，称为扩展表。</p><p>那么为啥不用222表示，第一个AB也要表示为01，这就是LZW要求压缩后的编码是自解释的。即字典是不会被写入压缩文件的，在解压缩的时候，一开始字典除了默认的0-&gt;A,1-&gt;B之外并没有其他的映射，2-&gt;AB是在解压缩过程中一起加入的。</p><h4 id="编码算法">编码算法</h4><p>编码器从原字符串中不断地读入新的字符，并试图将单个字符或字符串编码为记号。维护两个变量，一个P表示手头已有的，还没有被编码的字符串，一个是C表示当前新读进来的字符。</p><ol type="1"><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时P和C都是空的。</li><li>读入新的字符C，与P合并形成字符串P+C。</li><li>在字典里查找P+C，如果:</li></ol><pre><code>- P+C在字典里，P=P+C。- P+C不在字典里，将P的记号输出；在字典中为P+C建立一个记号映射；更新P=C。</code></pre><ol start="4" type="1"><li>返回步骤2重复，直至读完原字符串中所有字符。</li></ol><p>核心在于第三步，P是当前维护的可以被编码为记号的子串。注意P是可以被编码为记号，但是还并未输出。新的字符C不断被读入并添加到P的尾部，只要P+C仍然能在字典中找到，就不断的增长更新<span class="math inline">\(P=P+C\)</span>，这样就能将一个尽可能长的字符串P编码为一个记号，这就是压缩的实现。当新的P+C无法在字典中找到时，我们没有办法，输出已有的P的编码记号，并为新子串P+C建立字典表项。然后新的P从单字符C开始，重新增长，重复上述步骤。</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\LZW压缩1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">LZW压缩1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\LZW压缩2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">LZW压缩2</div></center><p>编码过程中的3-4步，第7-8步以及8-10步，子串P发生了增长，直到新的P+C无法在字典中找到，则将当前的P输出，P则更新为新单字符C重新开始增长，输出的就是上一个P的对应的键值。</p><p>上面的编码就是0132372</p><h4 id="解码算法">解码算法</h4><p>解码器的输入是压缩后的数据，即记号流。类似于编码，仍然维护两个变量pW和cW，W表示的含义是word。pW表示的是之前刚刚解码的记号，cW表示的是新读进来的记号。</p><ol type="1"><li>初始状态，字典里只有所有的默认项，例如0-&gt;a，1-&gt;b，2-&gt;c。此时pW和cW都是空的。</li><li>读入第一个的符号cW，解码输出。注意第一个cW肯定是能直接解码的，而且一定是单个字符。</li><li>赋值pW=cW。</li><li>读入下一个符号cW。</li><li>在字典里查找cW，如果:<ol type="a"><li>cW在字典里：</li></ol><ol type="1"><li>解码cW，即输出 Str(cW)。</li><li>令P=Str(pW)，C=Str(cW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射。</li></ol><ol start="2" type="a"><li>cW不在字典里:</li></ol><ol type="1"><li>令P=Str(pW)，C=Str(pW)的<strong>第一个字符</strong>。</li><li>在字典中为P+C添加新的记号映射，这个新的记号一定就是cW。</li><li>输出P+C。</li></ol></li><li>返回步骤3重复，直至读完所有记号。</li></ol><p>要将上面得到的编码进行LZW解码的话，需要经过如下的步骤：</p><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\LZW解码1.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">LZW解码1</div></center><center><img style="border-radius: 0.3125em;    box-shadow: 0 1px 3px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/05/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/blog\source\_posts\算法笔记\LZW解码2.png"> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">LZW解码2</div></center><p>首先直接解码最前面的a和b，然后生成3-&gt;ab这一个映射，也就是解码器利用前面已经解出来的字符，如实的还原了编码过程中字典的生成。</p><h1 id="力扣中的典型">6. 力扣中的典型</h1><h2 id="链表">6.1 链表</h2><h3 id="no876.-链表的中间节点">No876. 链表的中间节点</h3><p>这个有两个方法：</p><ul><li>单指针法：</li></ul><p>这需要两次遍历，首先第一遍遍历获得链表的长度len，第二遍从首指针开始移动，直到count计数器到达len / 2 + 1，然后这个值就是链表的中间节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre.next = head;</span><br><span class="line">    ListNode start = pre, end = pre;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(start.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        start = start.next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length/<span class="number">2</span>+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        end = end.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双指针法：</li></ul><p>这个需要使用快慢指针来解决，快慢指针初始都是指向链表的头部，然后慢指针每次移动一格，快指针每次移动两格，当移动到末尾的时候，慢指针指向的就是中间的位置，当跳出循环的时候，fast指针要么是指向空，要么是指向最后一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="no31.-下一个排列">NO31. 下一个排列</h3><p>下一个排列指的是，给定一个数组nums，求nums中的数字的全部排列中比nums当前组成的数字大的那些中最小的那个。</p><p>这个使用的方法是两端扫描，具体做法如下：</p><ul><li>需要将一个左边的较小数和一个右边的较大数交换，以能够让当前排列变大，从而得到下一个排列。</li><li>同时我们需要让这个较小数尽量靠右，而较大数尽可能小。当完成交换后，较大数右边的数需要按照升序排列重新排序，这样可以保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</li></ul><p>比方说对于<span class="math inline">\([4,5,2,6,3,1]\)</span>，我们能找到的符合条件的一对较小数与较大数为2与3，满足较小数尽量靠右，而较大数尽可能小。当我们完成交换后排列变为<span class="math inline">\([4,5,3,6,2,1]\)</span>，此时我们可以重排较小数右边的序列，序列变为<span class="math inline">\([4,5,3,1,2,6]\)</span>。</p><p>算法的具体描述为：</p><ul><li>首先从后向前查找第一个顺序对<span class="math inline">\((i, i+ 1)\)</span>满足<span class="math inline">\(a[i]&lt;a[i+1]\)</span>。这样较小数即为<span class="math inline">\(a[i]\)</span>。此时<span class="math inline">\([i+1,n)\)</span>必然是下降序列。</li><li>如果找到了顺序对，那么在区间<span class="math inline">\([i+1,n)\)</span>中从后向前查找第一个元素j满足<span class="math inline">\(a[i]&lt;a[j]\)</span>，这样较大数即为<span class="math inline">\(a[j]\)</span></li><li>交换<span class="math inline">\(a[i],a[j]\)</span>，此时可以证明区间<span class="math inline">\([i+1,n)\)</span>必为降序。我们可以直接使用双指针反转区间<span class="math inline">\([i+1,n)\)</span>使其变为升序，而无需对该区间进行排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下一个排列就是下一个字典序更大的排列</span></span><br><span class="line"><span class="comment">         * 找出nums的下一个排列</span></span><br><span class="line"><span class="comment">         * 必须原地修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;<span class="comment">//倒数第二个元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])</span><br><span class="line">            i --;<span class="comment">//从后往前遍历，找到前一个大于后一个的数对</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])</span><br><span class="line">                j --;<span class="comment">//从后往前遍历，直到找到小于当前数字的那个数</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;<span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">int</span> left = start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法第四版的笔记&quot;&gt;0. 算法第四版的笔记&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;font face=&quot;楷体&quot; size=&quot;6&quot; color=&quot;#ff00f0&quot;&gt;这篇博客是基于《算法第四版》使用Java语言实现书中各种数据结构及算法的。博客本身大部分都是基于书上的讲解摘抄作为笔记，习题只实现了小部分。这里有两个比较不错的动态化的图示的算法演示网站。&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PERFECT笔记</title>
    <link href="http://yoursite.com/2022/05/06/PERFECT%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/05/06/PERFECT%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-06T10:12:23.000Z</published>
    <updated>2022-05-30T02:06:55.590Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a></p><p>现有的网络对齐的方法主要关注个人用户层面上的对齐，需要具有大量的个人共享的信息。在缺少相关的共享信息的时候，社区的对齐可能会给用户对齐以关键的补充信息。反过来，用户对齐也揭示了更多关于社区对齐的线索。我们引入了联合社交网络对齐问题，目的是跨社交网络同时对齐用户和社区。</p><ul><li>如何同时学习用户和社区的表示方式？</li><li>如何使用户对齐和社区对齐相互受益？</li></ul><p><img src="../images/PERFECT/联合网络对齐.png"></p><p>使用双曲空间和欧式空间来嵌入网络得到：</p><p><img src="../images/PERFECT/嵌入空间对比.png"></p><p>对比欧式空间，双曲空间倾向于呈现输入网络中节点之间的潜在层次结构。我们观察到，该层次特征在社交网络[9]中是常见的，更重要的是，它对用户对齐[2]和有利于社区发现至关重要。</p><p>问题定义：给定一对社交网络<span class="math inline">\(G^s,G^t\)</span>以及anchor set A，要找到所有的anchor users：<span class="math inline">\(\left\{(v_i^s,v_k^t)\right\}\)</span>以及所有的anchor communities：<span class="math inline">\(\left\{(C_p^s,C_q^t)\right\}\)</span>。</p><h2 id="为什么使用双曲空间嵌入">为什么使用双曲空间嵌入</h2><p>与欧几里得空间相比，双曲空间中的嵌入编码了用户之间的潜在层次结构，即中心性较高的用户倾向于居住在更靠近原点的位置。层次特征已被证明对用户对齐[2]和有利于社区发现至关重要。以定量地测量层次特征，引入了$Gromov   -hyperbolicity $，一个几何群论的度量。</p><p>相应的δ−双曲性显示了数据集的潜在层次结构：</p><p><img src="../images/PERFECT/数据集.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷题指南</title>
    <link href="http://yoursite.com/2022/05/03/%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2022/05/03/%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</id>
    <published>2022-05-02T17:53:58.000Z</published>
    <updated>2022-05-30T02:07:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="poj刷题顺序">1. POJ刷题顺序</h1><p><a id="more"></a></p><h1 id="初期">初期:</h1><h2 id="一.基本算法">一.基本算法:</h2><p>枚举. (POJ 1753,POJ 2965) 贪心(POJ 1328,POJ 2109,POJ 2586) 递归和分治法. 递推. 构造法.(POJ 3295) 模拟法.(POJ 1068,POJ 2632,POJ 1573,POJ 2993,POJ 2996)</p><h2 id="二.图算法">二.图算法:</h2><p>图的深度优先遍历和广度优先遍历. 最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra) (POJ 1860,POJ 3259,POJ 1062,POJ 2253,POJ 1125,POJ 2240) 最小生成树算法(prim,kruskal) (POJ 1789,POJ 2485,POJ 1258,POJ 3026) 拓扑排序 (POJ 1094) 二分图的最大匹配 (匈牙利算法) (POJ 3041,POJ 3020) 最大流的增广路算法(KM算法). (POJ 1459,POJ 3436)</p><h2 id="三.数据结构.">三.数据结构.</h2><p>串 (POJ 1035,POJ 3080,POJ 1936) 排序(快排、归并排(与逆序数有关)、堆排) (POJ 2388,POJ 2299) 简单并查集的应用. 哈希表和二分查找等高效查找法(数的Hash,串的Hash) (POJ 3349,POJ 3274,POJ 2151,POJ 1840,POJ 2002,POJ 2503) 哈夫曼树(POJ 3253) 堆 trie树(静态建树、动态建树) (POJ 2513)</p><h2 id="四.简单搜索">四.简单搜索</h2><p>深度优先搜索 (POJ 2488,POJ 3083,POJ 3009,POJ 1321,POJ 2251) 广度优先搜索(POJ 3278,POJ 1426,POJ 3126,POJ 3087.POJ 3414) 简单搜索技巧和剪枝(POJ 2531,POJ 1416,POJ 2676,POJ 1129)</p><h2 id="五.动态规划">五.动态规划</h2><p>背包问题. (POJ 1837,POJ 1276) 型如下表的简单DP(可参考lrj的书 page149): E[j]=opt{D+w(i,j)} (POJ 3267,POJ 1836,POJ 1260,POJ 2533) E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列) (POJ 3176,POJ 1080,POJ 1159) C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)</p><h2 id="六.数学">六.数学</h2><p>组合数学:</p><p>加法原理和乘法原理. 排列组合. 递推关系. (POJ 3252,POJ 1850,POJ 1019,POJ 1942) 数论.</p><p>素数与整除问题 进制位. 同余模运算. (POJ 2635, POJ 3292,POJ 1845,POJ 2115) 计算方法.</p><p>二分法求解单调函数相关知识.(POJ 3273,POJ 3258,POJ 1905,POJ 3122)</p><h2 id="七.计算几何学.">七.计算几何学.</h2><p>几何公式. 叉积和点积的运用(如线段相交的判定,点到线段的距离等). (POJ 2031,POJ 1039) 多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交) (POJ 1408,POJ 1584) 凸包. (POJ 2187,POJ 1113)</p><h1 id="中级">中级:</h1><h2 id="一.基本算法-1">一.基本算法:</h2><p>C++的标准模版库的应用. (POJ 3096,POJ 3007) 较为复杂的模拟题的训练(POJ 3393,POJ 1472,POJ 3371,POJ 1027,POJ 2706)</p><h2 id="二.图算法-1">二.图算法:</h2><p>差分约束系统的建立和求解. (POJ 1201,POJ 2983) 最小费用最大流(POJ 2516,POJ 2195) 双连通分量(POJ 2942) 强连通分支及其缩点.(POJ 2186) 图的割边和割点(POJ 3352) 最小割模型、网络流规约(POJ 3308)</p><h2 id="三.数据结构.-1">三.数据结构.</h2><p>线段树. (POJ 2528,POJ 2828,POJ 2777,POJ 2886,POJ 2750) 静态二叉检索树. (POJ 2482,POJ 2352) 树状树组(POJ 1195,POJ 3321) RMQ. (POJ 3264,POJ 3368) 并查集的高级应用. (POJ 1703,POJ 2492) KMP算法. (POJ 1961,POJ 2406)</p><h2 id="四.搜索">四.搜索</h2><p>最优化剪枝和可行性剪枝 搜索的技巧和优化 (POJ 3411,POJ 1724) 记忆化搜索(POJ 3373,POJ 1691)</p><h2 id="五.动态规划-1">五.动态规划</h2><p>较为复杂的动态规划(如动态规划解特别的施行商问题等) (POJ 1191,POJ 1054,POJ 3280,POJ 2029,POJ 2948,POJ 1925,POJ 3034) 记录状态的动态规划. (POJ 3254,POJ 2411,POJ 1185) 树型动态规划(POJ 2057,POJ 1947,POJ 2486,POJ 3140)</p><h2 id="六.数学-1">六.数学</h2><p>组合数学:</p><p>容斥原理. 抽屉原理. 置换群与Polya定理(POJ 1286,POJ 2409,POJ 3270,POJ 1026). 递推关系和母函数. 数学.</p><p>高斯消元法(POJ 2947,POJ 1487,POJ 2065,POJ 1166,POJ 1222) 概率问题. (POJ 3071,POJ 3440) GCD、扩展的欧几里德(中国剩余定理) (POJ 3101) 计算方法.</p><p>0/1分数规划. (POJ 2976) 三分法求解单峰(单谷)的极值. 矩阵法(POJ 3150,POJ 3422,POJ 3070) 迭代逼近(POJ 3301) 随机化算法(POJ 3318,POJ 2454)</p><p>杂题. (POJ 1870,POJ 3296,POJ 3286,POJ 1095)</p><h2 id="七.计算几何学.-1">七.计算几何学.</h2><p>坐标离散化. 扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用). (POJ 1765,POJ 1177,POJ 1151,POJ 3277,POJ 2280,POJ 3004) 多边形的内核(半平面交)(POJ 3130,POJ 3335) 几何工具的综合应用.(POJ 1819,POJ 1066,POJ 2043,POJ 3227,POJ 2165,POJ 3429)</p><h1 id="高级">高级:</h1><h2 id="一.基本算法要求">一.基本算法要求:</h2><p>代码快速写成,精简但不失风格 (POJ 2525,POJ 1684,POJ 1421,POJ 1048,POJ 2050,POJ 3306) 保证正确性和高效性. POJ 3434</p><h2 id="二.图算法-2">二.图算法:</h2><p>度限制最小生成树和第K最短路. (POJ 1639) 最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解) (POJ 3155, POJ 2112,POJ 1966,POJ 3281,POJ 1087,POJ 2289,POJ 3216,POJ 2446 ) 最优比率生成树. (POJ 2728) 最小树形图(POJ 3164) 次小生成树. 无向图、有向图的最小环</p><h2 id="三.数据结构.-2">三.数据结构.</h2><p>trie图的建立和应用. (POJ 2778) LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法 (RMQ+dfs)).(POJ 1330) 双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移 的目的). (POJ 2823) 左偏树(可合并堆). 后缀树(非常有用的数据结构,也是赛区考题的热点). (POJ 3415,POJ 3294)</p><h2 id="四.搜索-1">四.搜索</h2><p>较麻烦的搜索题目训练(POJ 1069,POJ 3322,POJ 1475,POJ 1924,POJ 2049,POJ 3426) 广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储 状态、双向广搜、A<em>算法. (POJ 1768,POJ 1184,POJ 1872,POJ 1324,POJ 2046,POJ 1482) 深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大 、可以考虑双向搜索或者是轮换搜索、IDA</em>算法. (POJ 3131,POJ 2870,POJ 2286)</p><h2 id="五.动态规划-2">五.动态规划</h2><p>需要用数据结构优化的动态规划. (POJ 2754,POJ 3378,POJ 3017) 四边形不等式理论. 较难的状态DP(POJ 3133)</p><h2 id="六.数学-2">六.数学</h2><p>组合数学.</p><p>MoBius反演(POJ 2888,POJ 2154) 偏序关系理论. 博奕论.</p><p>极大极小过程(POJ 3317,POJ 1085) Nim问题.</p><h2 id="七.计算几何学.-2">七.计算几何学.</h2><p>半平面求交(POJ 3384,POJ 2540) 可视图的建立(POJ 2966) 点集最小圆覆盖. 对踵点(POJ 2079)</p><h2 id="八.综合题.">八.综合题.</h2><p>(POJ 3109,POJ 1478,POJ 1462,POJ 2729,POJ 2048,POJ 3336,POJ 3315,POJ 2148,POJ 1263</p><h1 id="hdu刷题指南">2. HDU刷题指南</h1><p>第一阶段：开始入门吧！（15天，53题） 一．输入输出练习（2天，10题） 1000、1089—1096、1001 二．简单操作：（2—4天，12题） 2000—2011、2039 三．英文题试水（3—4天，8题） 1720、1062、2104、1064、2734、1170、1197、2629 四．回归水题（4-6天，24题） 2012—2030、2032、2040、2042、2054、2055 （第一阶段大体结束之后，会由几位学长讲一些数据结构的知识，请同学们务必跟上进度！）</p><p>第二阶段：我要学算法！（12天，31题） 一．字符串我要会处理（2天，6题） 2072、2081、2093、2091、1004、2057 二．简单数学题（4天，12题） 2031、2033、2070、2071、2075、2089、2090、2092、2096—2099 三．要玩就玩汉诺塔（2天,5题） 1995、1996、2064、2077、2175 四．As easy as math（4天，8题） 1108、2138、1713、1722、2136、2504、1717、1125</p><p>第三阶段：acm无底洞啊！（10天，18题） 一．初见dp（2—4天，4题） 2062、1087、1203、1003 二．迷宫之烟雾缭绕（2—4天，3题） 1728、1010、1072 三．数学题做不下去了。（3-5天，8题） 1052、1568、1443、1222、1249、1005、2674、1018 四．龙门客栈，暗藏玄机（2—3天，3题） 1022、1237、1082</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;poj刷题顺序&quot;&gt;1. POJ刷题顺序&lt;/h1&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unsupervised Graph Alignment Alignment with Wasserstein Distance Disciminator笔记</title>
    <link href="http://yoursite.com/2022/04/26/Unsupervised-Graph-Alignment-Alignment-with-Wasserstein-Distance-Disciminator%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/04/26/Unsupervised-Graph-Alignment-Alignment-with-Wasserstein-Distance-Disciminator%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-26T15:36:05.000Z</published>
    <updated>2022-05-30T02:07:18.368Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a></p><p>这篇论文也是最近研究的生成对抗网络解决网络对齐的方法。</p><p>大多数现有的无监督方法都假设相应的节点应该具有相似的局部结构，但这往往不成立。同时，丰富的节点属性往往是可用的，并已被证明可以有效地减轻上述局部拓扑不一致的问题。我们首先开发了一个轻量级的GCN体系结构来捕获局部和全局图模式及其与节点属性的固有相关性。然后证明了在嵌入空间中，得到的最优对齐结果等价于最小化不同图中节点嵌入之间的Wasserstein距离。为此，我们提出了一种新的Wasserstein距离鉴别器来识别候选节点对应对，以更新节点嵌入。</p><p>现在的方法大多数都是基于有监督学习的网络对齐，而现在的大多数的无监督学习任务都是基于结点应该有相似的邻域特性，在实际中太为严格。例如：在不同的图表中，节点的程度可能会迅速变化，用户在Facebook上可能有很多朋友，但在推特上的活跃程度可能会少得多。</p><p>同时，在许多现实世界的图中，节点通常与丰富的侧边信息相关联(也就是节点属性)。这些属性信息与图的结构高度相关，可以用来解决上述局部结构不一致的问题。</p><p>一个简单的解决方案是首先学习节点嵌入，然后找到与学习到的嵌入表示的节点对应关系。这种方法有如下问题：（1）如果我们直接应用GCN来获得节点嵌入，那么不同图的节点嵌入可能不在同一个特征空间中，这不适合于对齐任务。同时，GCN还可能存在过平滑问题，所以就不能有效的捕获全局的图的特征，不适用于对齐任务。（2）将对齐问题简化为基于节点嵌入的相似性矩阵的二部图匹配问题。现在的大多数的算法的复杂度是<span class="math inline">\(O(n^3)\)</span>，很高。（3）节点表示学习和图对齐不是两个独立的任务，而是应该相互补充。更好的节点嵌入可以帮助实现更好的对齐结果，而更好的对齐也可以为嵌入学习提供监督信号。因此，必须在统一的框架。</p><p>这个论文主要回答的问题如下：如何学习适合于对齐任务的有效嵌入内容？如何联合建模嵌入学习和图形对齐？</p><p><span class="math inline">\(G=(v,\varepsilon,X)\)</span>，其中<span class="math inline">\(v=\left\{v_1,v_2,...,v_n\right\}\)</span>，<span class="math inline">\(\xi\)</span>表示边集合，<span class="math inline">\(X∈R^{n \times d}\)</span>表示节点属性矩阵。A表示邻接矩阵。其中这两个网络的节点数量以及特征数量为<span class="math inline">\((n_s,d_s)\)</span>和<span class="math inline">\((n_t,d_t)\)</span></p><ul><li>定义1：（unsupervised graph alignment）给定两个输入的图<span class="math inline">\(G_s=(v_s,\xi_s,X_s)\)</span>以及<span class="math inline">\(G_t=(u_t,\xi_t,X_t)\)</span>，无监督的网络对齐是为了找到节点对<span class="math inline">\(M=\left\{(v_i,u_j)|v_i∈v_S \and u_j ∈ u_t\right\}\)</span>。此外，每个节点最多应该在一个合法的对齐中出现一次。形式上，对于一个合法的M，存在一个部分映射<span class="math inline">\(\pi: v_s \to u_t\)</span>并且一个部分映射<span class="math inline">\(\pi&#39; :u_t \to v_s\)</span>，因此对于任意的<span class="math inline">\((v_i,u_j)∈M\)</span>，我们有<span class="math inline">\(\pi(v_i)=u_j \and \pi&#39;(u_j)=v_i\)</span>。</li></ul><p>我们通常假设<span class="math inline">\(H^{(0)}=X\)</span>，一个两层的GCN架构为：<span class="math inline">\(Z=\widehat A \sigma(\widehat AXW^{(1)})W^{(2)}\)</span>,其中Z是所有的节点的embedding矩阵。给定节点嵌入表示，无监督图对齐问题可以转换为图论中的经典任务，即二部图匹配。</p><ul><li><p>定义2：（network embedding based graph alignment）给定一个节点<span class="math inline">\(v_i\)</span>以及<span class="math inline">\(v_j\)</span>在两个网络中，节点的嵌入为<span class="math inline">\(z_{v_i},z_{u_j}\)</span>，网络对齐的任务是找到：</p><p><img src="../images/wasserstein距离对齐论文/网络对齐任务.png"></p></li></ul><p>如果我们令<span class="math inline">\(c_{i,j}=||z_{v_i}-z_{u_j}||\)</span>,上述的问题等价于节点集为<span class="math inline">\(v_s \or u_t\)</span>以及cost集合<span class="math inline">\(\left\{c_{i,j}|v_i∈v_s,u_j∈u_t\right\}\)</span>的最小化二部图匹配问题。如果是仅使用普通的GCN可能造成的问题有：（1）两个网络的嵌入可能是在不同的空间并且图的全局特征可能不能被很好地刻画；（2）传统的二部图匹配的算法的计算量太大了；（3）节点嵌入可能不适用于对齐任务。</p><p><img src="../images/wasserstein距离对齐论文/模型框架.png"></p><p>传统的GCN只能获取局部的图结构信息，因为第k层的GCN只使用了k阶邻域的信息，随着k的增大，所有节点的embedding将会趋近于一个相似的值。与此同时，全局拓扑模式对于保证准确的对齐也至关重要，特别是当局部结构一致性假设[43]不成立时。最近的研究表明GCN层之间的非线性不是至关重要的，可以简单地去除而不损害学习性能。因此提出了一个轻量级的GCN结构：LGCN，我们移除非线性函数和连接每一层的嵌入：</p><p><img src="../images/wasserstein距离对齐论文/LGCN公式.png"></p><p>由于LGCN避免了层堆叠，因此我们可以将𝐾指定为大量的𝐾来捕获全局拓扑模式。</p><p>由于上述公式除了权重项都能预先计算，稍后将介绍的对抗性训练阶段的计算成本。LGCN的平面结构使模型更容易训练，收敛速度也更快。此外，少量的模型参数将使后期的对抗性训练过程更加稳定。</p><p>考虑到不同的图的属性（包括图的拓扑结构和节点属性）可能会有很大的不同，我们引入了一个额外的变换矩阵T来适应不同图之间的内在差异。<span class="math inline">\(Z_S=Tf_e(A_s,X_s) \ and \ Z_t=f_e(A_t,X_t)\)</span></p><h1 id="wasserstein-distance-discriminator"><strong>Wasserstein Distance Discriminator</strong></h1><p>Wasserstein Distance它是一种广泛用于度量两种概率分布之间差异的度量方法。</p><ul><li>定义3：（Wasserstein Distance）</li></ul><p><img src="../images/wasserstein距离对齐论文/wasserstein距离定义.png"></p><p>𝛾表示一个最优的“质量”运输，它指定了对于每个𝑥，有多少“质量”应该被转移到𝑦，这样P𝑠将变成<span class="math inline">\(P_t\)</span></p><p>从简单的情况出发，令<span class="math inline">\(m=|v_s|=|u_t|\)</span>，我们假设一个完美的从<span class="math inline">\(v_s \to u_t\)</span>的对齐是存在的。它被定义为将V𝑠中的每个节点根据定义2中的最优对应集M与U𝑡中的另一个节点进行匹配的对齐。然后将问题简化为识别给定Z𝑠和Z𝑡的最优集M。我们要最小化在M中的每个节点对<span class="math inline">\((v_i,u_j)\)</span>距离。</p><ul><li>proposition 4：假设<span class="math inline">\(m=|v_s|=|u_t|\)</span>。设P𝑠和P𝑡分别为均匀分布在V𝑠和U𝑡的嵌入上的概率分布。随后我们有等式8：</li></ul><p><img src="../images/wasserstein距离对齐论文/wasserstein距离.png"></p><p>证明：我们首先展示了一个对齐M，它唯一地决定了一个从P𝑠到P𝑡的运输𝛾，因为它可以在等式8中以联合分布的形式表示:</p><p><img src="../images/wasserstein距离对齐论文/分布.png"></p><p>由于<span class="math inline">\(W_1(p_s,p_t)\)</span>表示的最小的转移距离，上面的转移距离至少是<span class="math inline">\(W_1(p_s,p_t)\)</span>，也就是等式8要取小于等于号。要证明等式成立，要做的就是夹逼法证明另一个方向的成立。也就是当<span class="math inline">\(W_1(p_s,p_t)\)</span>达到其最优的时候，所有的在最优的转移<span class="math inline">\(\gamma^*\)</span>中的<span class="math inline">\(p(x=v_i,y=u_j)\)</span>要么是1/m要么是0使得它能够一直生成一个对齐M。<span class="math inline">\(\gamma^*\)</span>决定了一个M。</p><p>为了证明，我们将这个问题转化为一个最小成本的网络流问题<span class="math inline">\((G&#39;,U,C)\)</span>，其中<span class="math inline">\(G&#39;=(V&#39;,\varepsilon&#39;)\)</span>，流量函数<span class="math inline">\(U: \varepsilon&#39; \to R\)</span>以及损失函数<span class="math inline">\(C: \varepsilon&#39; \to R\)</span>。流量网络的构造由以下公式定义：</p><p><img src="../images/wasserstein距离对齐论文/定义.png"></p><p>流量为𝑚的流量在G‘中以U的能力运行，如果我们用将V𝑠和U𝑡之间的每对节点的流量乘以1/𝑚，那么流量就唯一地决定了P𝑠和P之间的传输。由于每个容量𝑈（𝑣，𝑢）和总流量𝑚在这个最小成本流问题中是整数，通过约束的完全单模块化(也称为完整性定理[7,29] 最小代价流问题)，它有一个最优解，在每条边上都有整数流。显然，图中流量等于1的边集等价于M，这意味着总是存在一个M，使𝑊1(P𝑠，P𝑡)最小化。</p><p>然后，我们将命题4推广到一个图中的某些节点在另一个图中可能没有相应的节点的一般情况。</p><ul><li>proposition 5：令<span class="math inline">\(m=|M|\)</span>表示的是<span class="math inline">\(v_s,u_t\)</span>之间对应节点的个数，并且<span class="math inline">\(m ≤ min(|v_s|,|u_t|)\)</span>。对于任意的大小为m的子节点集合<span class="math inline">\(v_s&#39;,u_t&#39;\)</span>，令P‘𝑠和P’𝑡分别是均匀分布在V‘𝑠和U’𝑡嵌入上的相应概率分布。我们随后有：</li></ul><p><img src="../images/wasserstein距离对齐论文/定义1.png"></p><p>证明：与proposition 4类似的，我们将这个问题转化为一个最小的网络流问题：</p><p><img src="../images/wasserstein距离对齐论文/proposition5.png"></p><p>根据约束矩阵[29,32]的完全单模块性，它在每条边上都有一个整数流量的最优解。在这个最优流中，V𝑠中的𝑚个节点和U𝑡中的𝑚个节点将被流连接。设V‘𝑠和U’𝑡是由V𝑠和U𝑡方面的流所选择的节点集,那么V‘𝑠和U’𝑡之间的wasserstein距离（由最优运输计划定义）等价于</p><p><img src="../images/wasserstein距离对齐论文/等价的距离.png"></p><p>另一方面，如果我们假设存在一对子集V‘’𝑆和U‘’𝑡具有更小的wasserstein距离，那么一个更好的解决方案，只包括节点之间的流动 V‘’𝑆和U‘’𝑡，其成本小于最优方案，存在于最小成本网络流问题中。这样的假设显然产生了一个矛盾。</p><p>因此，对于任意的<span class="math inline">\(v_s&#39;&#39;\)</span>以及<span class="math inline">\(u_t&#39;&#39;\)</span>满足<span class="math inline">\(|v_s&#39;&#39;|=m,|u_t&#39;&#39;|=m\)</span>，我们有<span class="math inline">\(W_1(P_s&#39;&#39;,P_t&#39;&#39;)≥W_1(P&#39;_s,P&#39;_t)\)</span>，命题5得证。</p><p>命题5表明，使wasserstein损失最小的节点对是最优的节点对应关系。因此，wasserstein距离反映了匹配的n之间的接近性 结果表明，匹配的最优嵌入表示将使wasserstein距离最小。</p><p><img src="../images/wasserstein距离对齐论文/kantorovich%20rubinstein%20duality.png"></p><p>其中<span class="math inline">\(||f_w||\)</span>是<span class="math inline">\(f_w\)</span>的lipschitz形式，这个等式表示了分离P‘𝑠和P’的最优1-Lipschitz函数𝑓𝑤总是存在的，并且最大的分割是<span class="math inline">\(W_1(P&#39;_s,P&#39;_t)\)</span>.我们使用一个神经网络结构来表示𝑓𝑤，在本文中，它被称为wasserstein距离鉴别器。因此，我们计算了两个不同图中每个节点的𝑓𝑤(z𝑣𝑖)和𝑓𝑤(z𝑢𝑗)。然后，V𝑠中最小化𝑓𝑤(z𝑣𝑖)的节点和U𝑡中最大化𝑓𝑤(z𝑢𝑗)的节点将会 是选定的节点对。选择过程的复杂性将从多项式时间降低到线性时间。</p><p>𝑓𝑤被优化以最大化E𝑥∼P‘𝑠[𝑓𝑤（𝑥）]−E𝑦∼P’𝑡[𝑓𝑤（𝑦）]的预期差异。因此，𝑓𝑤使<span class="math inline">\(-L_{we}\)</span>最小化，从而导致以下损失：</p><p><img src="../images/wasserstein距离对齐论文/LWW损失.png"></p><p>最后，整个优化方案可以表述为一个双人博弈。嵌入学习阶段旨在优化嵌入，以最小化V‘𝑠和U’之间的瓦瑟斯坦距离 ，而对鉴别器进行优化，得到一个更好的wasserstein距离下界。简而言之，这两个阶段在对齐任务的最佳嵌入方面相互补充。</p><p>上述方法的一个问题是，对抗性的损失可能会崩溃为一个平凡的情况，即所有的嵌入向量都成为相同的值。在这种情况下，wasserstein的距离就变成了 0，但这肯定不是我们想要的距离。</p><p>为了解决这个问题，我们使用重构损失来确保嵌入仍然有足够的信息来重新创建输入属性。我们将𝑓𝑟𝑠和𝑓𝑟𝑡定义为两个重构神经网络，每个神经网络都将其图的嵌入作为输入，并返回图的属性作为输出。然后我们将以下损失最小化函数：</p><p><img src="../images/wasserstein距离对齐论文/lossrecon.png"></p><p>最后，我们使用等式（17）来更新嵌入网络中的权值矩阵，其中𝛽是一个平衡两个损失函数的超参数：</p><p><img src="../images/wasserstein距离对齐论文/嵌入的损失函数.png"></p><p>综上所述，在训练过程的每次迭代中，我们的框架首先使用嵌入网络LGCN生成节点嵌入。在此之后，我们的框架将更新了维护者的参数 通过最小化等式中的𝐿ww来实现的ein鉴别器 (15).然后，我们的框架使用瓦瑟斯坦鉴别器，根据算法2生成伪节点对应对。最后，在它的最后 通过最小化等式来更新嵌入网络的参数 (17).我们在算法1中总结了我们的框架的详细训练过程。</p><p><img src="../images/wasserstein距离对齐论文/WALIGN算法.png"></p><p><img src="../images/wasserstein距离对齐论文/候选对算法.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>UAGA笔记</title>
    <link href="http://yoursite.com/2022/04/25/UAGA%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/04/25/UAGA%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-25T10:43:23.000Z</published>
    <updated>2022-05-30T02:07:27.820Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a></p><p>这篇文章提出了一个UAGA（Unsupervised Adversarial Graph Alignment）架构以完全无监督的方式学习不同图的两个嵌入空间之间的交叉图对齐。该框架学习每个图的嵌入空间，然后尝试通过对抗性训练对齐这两个空间，然后进行细化过程。我们进一步将我们的UAGA方法扩展到增量UAGA(iUAGA)，该方法基于伪锚定链接迭代地显示未观察到的用户链接。这可以用来进一步提高嵌入质量和对齐精度。</p><p>文章只使用两个图的结构信息，首先，利用无监督图嵌入方法分别学习源图和目标图的单个特征表示。接下来，它利用对抗性的训练来学习a 从源嵌入空间到目标嵌入空间的线性映射，然后进行细化过程，从得到的共享嵌入空间中得到伪节点对应 并使用来自[17]的封闭形式的解决程序解决方案对映射进行微调。最后，我们将UAGA方法扩展到增量UAGA(iUAGA)，以提高嵌入质量和对齐 性能迭代。</p><p><em>hub问题，即在高维嵌入空间中，一定数量的节点成为许多其他节点的枢纽和最近邻，如果不解决，将使 通过最近的搜索进行的对齐更加困难和不准确。</em></p><ul><li>定义一：(Graph Alignment Problem)给定两个社交网络<span class="math inline">\(G_s=(V_s,E_s)\)</span>以及<span class="math inline">\(G_t=(V_t,E_t)\)</span>，没有先验的anchor links，目的就是要找到隐藏的对齐的节点。</li></ul><p>在本文中，使用deepwalk来学习源网络和目标网络的graph embedding，定义为<span class="math inline">\(Z_s,Z_t∈R^{|V| \times d}\)</span>。</p><p><img src="../images/UAGA/UAGA模型图.png"></p><p>按照流程图，首先用无监督学习的方法学习图的特征表示，然后我们利用领域对抗性训练来学习W的初始代理。接下来，我们利用学习到的W来选择伪锚点链接来进行映射细化。最后，我们利用细化的映射W将所有源节点映射到目标潜在特征空间。我们通过改变空间的度量来提高比图对齐的性能，这将导致在数据密集的区域中分布更多的这些节点。</p><p>在本文中，我们提出学习一个映射，不需要任何形式的跨域监督之间，这样两个不同的嵌入空间可以很好地对齐。</p><p>令<span class="math inline">\(Z_s= \left\{ z_s^1,...,z_s^n\right\}\)</span>以及<span class="math inline">\(Z_t= \left\{ z_t^1,...,z_t^m\right\}\)</span>为源网络和目标网络的嵌入空间。如果我们知道跨网络的节点对齐（比方说<span class="math inline">\(z_s^i,z_t^i\)</span>是对齐的），我们能够学习到一个线性映射<span class="math inline">\(W∈R^{d \times d}\)</span>：</p><p><img src="../images/UAGA/W矩阵.png"></p><p>d是嵌入向量的维度，X和Y是两个对齐的矩阵，<span class="math inline">\(X,Y∈R^{d \times k}\)</span>，是由源网络和目标网络中找到的k个结点形成的。在测试阶段，任意源网络的embedding <span class="math inline">\(z_s^i\)</span>的转换可以被定义为：<span class="math inline">\(arg \max_{z_t^j∈Z_t}cos(Wz_s^i,z_t^j)\)</span>，注意，如果我们有地面-真节点对应，方程（2）可以直接用作监督学习的损失部分。</p><p>所提出的UAGA框架包括两个步骤：学习W的初始代理的领域对抗性训练，然后是利用最佳匹配节点来创建的细化过程 应用方程（2）的伪锚点链接。</p><h1 id="a.-domain-adversarial-training">A. domain-adversarial training</h1><p>在这一步中，我们的目标是要使得映射后的<span class="math inline">\(Z_s,Z_t\)</span>难以区分。（用的是GAN的方法）首先我们定义一个判别器，它旨在区分从<span class="math inline">\(WZ_s={W_{z^1_s}、W^{z^2_s}、..，W_{z^n_s}}\)</span>和<span class="math inline">\(Z_t\)</span>中随机采样的元素。映射W可以看作是生成器，通过使嵌入特征WZs和Zt变得无法区分，来防止鉴别器做出准确的预测。因此，域对抗训练过程是一个双人博弈，其中第一个玩家是训练区分源域和目标域，第二个玩家是同时被训练来混淆鉴别器的生成器。</p><p>给定映射W，鉴别器由<span class="math inline">\(\theta_D\)</span>通过最小化以下目标函数进行优化：</p><p><img src="../images/UAGA/鉴别器优化方程.png"></p><p>前一项表示的含义是：嵌入<span class="math inline">\(z_s^i\)</span>来自源嵌入空间，给定鉴别器，映射W的目的是通过最小化以下目标函数来欺骗鉴别器精确预测嵌入的原始域的能力：</p><p><img src="../images/UAGA/W的优化方程.png"></p><p>为了训练我们的模型，我们遵循标准的生成对抗网(GANs)[30]训练程序，它交替地和迭代地优化鉴别器θD和映射W，使其分别最小化LD和LW。</p><h1 id="b.-the-hubness-problem-and-refinement-procedure">B. the hubness problem and refinement procedure</h1><p>域对抗训练步骤学习一个匹配全局源和目标嵌入空间的映射函数W，而不考虑数据分布背后的复杂的多模结构。换句话说，在我们的无监督场景中，两组节点之间的细粒度的点到点约束（即没有两条边共享一个共同的端点）没有被明确地强制执行。</p><p>为了解决上述挑战，我们提出了一个细化过程，使细粒度的点对点与生成的伪锚定链路的图对齐。细化的优点 我们可以从两个方面得出结论。首先，通过引入额外的监督(伪锚链，我们在领域对抗训练步骤中规避了潜在的模式崩溃问题(这在传统gan中是一个臭名昭著的问题) )，以适用于点对点的对齐。第二，在选择伪锚链接时，我们在确定了相互关系中所谓的hub问题（即点倾向于高维空间中许多点的最近邻）[31] 通过引入一个交叉图相似度缩放(CGSS)方案。</p><p>我们使用在之前的领域对抗性训练步骤中学习到的W作为初始代理，随后构建许多伪造的anchor links，为了获得高质量的伪造的anchor links，我们只保留在<span class="math inline">\(Z_s和Z_t\)</span>中相互是最邻近的邻居的结点。然而，最近邻通常是不对称的：<span class="math inline">\(z_t\)</span>是<span class="math inline">\(z_s\)</span>的k最邻不代表<span class="math inline">\(z_s\)</span>是<span class="math inline">\(z_t\)</span>的k近邻。在嵌入特征空间中，这将导致一种不利于基于最近邻规则对齐节点嵌入的现象：嵌入空间中的一些节点，我们称之为枢纽，ar e更有可能是许多其他节点的最近邻居，但其他节点（称为反集线器）并不是任何节点的最近邻居。</p><p>我们使用CGSS来缓解所谓的hubness问题，我们考虑一个二部邻域图，其中给定锚链的每个节点都连接到另一个图中的K个最近邻。在二部图中，与映射的源节点嵌入关联<span class="math inline">\(Wz_s\)</span>的邻域被表示为<span class="math inline">\(N_T(Wz_s)\)</span>。<span class="math inline">\(N_T(Wz_s)\)</span>所有的K个元素是来自源网络的结点。源嵌入z与目标邻域的平均相似度表示为：（每个节点都连接到目标网络的k个最近邻，就是说在原网络中i和j是k近邻的话，那么在目标网络中他们也是k近邻的话那么就被保留为伪造的anchor links）</p><p><img src="../images/UAGA/邻域平均相似度.png"></p><p>cos表示cos相似度，同理可以定义目标embedding到其源网络邻居的平均相似度。我们使用有效的最近邻算法[32]来计算所有的源节点和目标节点的嵌入。形式上，我们利用这些相似性来定义一个跨域相似性度量CGSS（.，.）在映射的源嵌入和目标嵌入之间，</p><p><img src="../images/UAGA/跨域相似度度量.png"></p><p>CGSS方案的动机是直观的：它增加了与孤立节点嵌入相关的相似性，而减少了位于密集区域的嵌入的相似性。换句话说，我 T鼓励选择位于低密度区域的节点作为伪锚定链接。形式上，映射W通过方法进一步细化：我们应用方程（2） 或链接来细化W。（度越大的结点对于对齐的影响干扰越大）</p><h1 id="c.-orthography-constraints">C. orthography constraints</h1><p>在我们的工作中，我们额外提出了一个简单的更新步骤，使映射矩阵W在训练进行时保持接近一个正交矩阵。正交约束的优势如下：（1）分别保留源特征嵌入和目标特征嵌入的个体特征和质量；（2）随着训练的进行，稳定了学习过程；（3）保持点积以及它们的L2距离。具体来说，我们的模型将通过使用以下更新策略进行迭代和交替更新</p><p><img src="../images/UAGA/W的更新公式.png"></p><p>利用正交约束，方程（2）可以归结为普罗克鲁斯问题，就是一个矩阵的逼近问题，它的解就是<span class="math inline">\(YX^T\)</span>的奇异值分解值：</p><p><img src="../images/UAGA/W奇异值分解.png"></p><p>为了进一步有效地利用伪锚定链接来学习更准确的映射，我们进一步提出了一个增量的UAGA(iUAGA)程序，它逐步选择一组伪锚定链接，然后利用它们通过使用方程（2）来细化映射W。如果满足以下两个条件，我们选择一个伪锚定链路。首先，我们要求跨域相似度（即方程（5））应该超过阈值参数，我们设为 在实验中分别是0.7或0.75。第二个要求是根据CGSS，嵌入特征对是相互最近的邻居。我们假设，除非它们是相互的最近邻，否则成对的关系是不可靠的。这两个要求减少了伪锚定链路的数量，但提高了其精度和最终的对齐性能。伪造的铆钉节点表示为<span class="math inline">\(\left\{\widehat T=(v_s,v_t)|v_s∈V_s,v_t∈V_t\right\}\)</span>。</p><p>另一个问题就是一些存在的边可能因为没有显式的建立或者没有爬取到而并不能观察到，为了解决这个问题，在此基础上，我们的方法提出了通过伪标记许多可靠的锚定链路来逐步弥补交叉图监督的不足，这有助于显示了未被观察到的边缘（图内伪用户链接）。理由是，如果两个节点在一个图中不连接，但它们的对应节点（根据伪锚点链接）在另一个图中链接，那么在中间加一条边是可行的 在现在的图中，</p><p><img src="../images/UAGA/添加边的示例.png"></p><p>通过利用伪标记的用户链接，我们可以进一步提高图的嵌入质量和最终的对齐性能。它背后的原因是扩展的图可以提供 更丰富的结构信息，可用于图形的嵌入和映射。</p><p>形式上给定两个图<span class="math inline">\(G_s,G_t\)</span>，具有伪造的锚定节点<span class="math inline">\(\widehat T\)</span>，<span class="math inline">\(G_s\)</span>的扩展图<span class="math inline">\(\widehat G_s\)</span>可以被表示为：</p><p><img src="../images/UAGA/源网络的扩展图.png"></p><p>算法流程如下：</p><p><img src="../images/UAGA/算法流程.png"></p><p>整个算法的流程就是：首先得到两个图的各自的node embedding，然后进行GAN的参数更新，得到一个对齐矩阵W。然后获取一个伪造的anchor links集合（如果互为k临近的话那么就是符合要求的），随后细化映射W。随后按照公式7扩展源网络和目标网络，最后重置Gs,Gt和T。最后使用公式5来对齐网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CONE-Align笔记</title>
    <link href="http://yoursite.com/2022/04/21/CONE-Align%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/04/21/CONE-Align%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-21T10:15:54.000Z</published>
    <updated>2022-05-30T02:07:35.822Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a></p><p>现有的无监督网络对齐方法可以找到分解节点邻域的次优对齐，即不保持匹配的邻域一致性。为了改进这一点，提出了CONE- Align，用节点嵌入建模网络内接近，并在对齐嵌入子空间后使用它们来匹配跨网络的节点。</p><p>许多的无监督网络对齐方法(FINAL,NETALIGN,REGAL)不能够实现匹配的邻域一致性：在一个图中接近的节点通常与在另一个图中接近的节点不匹配。REGAL使用结点嵌入捕获每个节点在网络中的结构身份，但是相邻的节点可能没有类似的结构角色，这导致了非常不一样的embeddings可能在另一个图中匹配得很远，违反了匹配的邻域一致性。CONE-Align： <strong>CON</strong>sistent <strong>E</strong>mbedding-based Network <strong>Align</strong>ment.我们使用著名的接近保持节点嵌入方法来学习每个图中邻近节点的相似节点嵌入。然而，由于节点在图之间并不接近，所以这些节点满足了 主节点是可转换的，不同图中的节点将被嵌入到不同的子空间中。因此，我们对图的嵌入子空间进行对齐，然后利用嵌入相似度来匹配节点。由于每个图中的相邻节点将有相似的嵌入，因此它们将被匹配 电解到另一个图的相似部分。因此，我们有最好的cone对齐：匹配邻域一致性和交叉图可比性。</p><p>大多数嵌入目标都是在单个图中建模接近性，如deepwalk，node2vec；结构嵌入方法捕获一个节点的结构角色，而不依赖于其与特定节点的接近程度，这种独立性使得嵌入在各个图之间具有可比性，例如struct2vec，xNetMF。</p><p>对于每一幅图，假设结点的个数为n（没有的话就补上），对于每个图<span class="math inline">\(G_i\)</span>，创建一个<span class="math inline">\(Y_i∈R^{n \times d}\)</span>表示结点的embedding matrix。网络对齐是找到一个方程<span class="math inline">\(\pi: V_1 \to V_2\)</span>或者一个矩阵<span class="math inline">\(P\)</span>其中<span class="math inline">\(p_{i,j}\)</span>表示的是在1网络中的结点i和2网络中的结点j的相似度。方程<span class="math inline">\(\pi\)</span>可以从P中找到，例如贪心策略：<span class="math inline">\(\pi(i) = arg \ max \ x_jp_{i,j}\)</span></p><p><span class="math inline">\(N_{G_1(i)}\)</span>表示在网络1中的节点i的邻居，定义i的"mapped neighborhood"在<span class="math inline">\(G_2\)</span>中为：经过<span class="math inline">\(\pi\)</span>映射的那个在<span class="math inline">\(G_2\)</span>中对应结点的邻居。<span class="math inline">\(\widetilde N_{G_2}^{\pi}(i)=\left\{j∈V_2:\exist k ∈ N_{G_1}(i) \ s.t. \pi(k)=j\right\}\)</span>，我们定义匹配邻域一致性MNC（Jaccard系数）</p><p><img src="../images/CONE/匹配邻域一致性.png"></p><p>问题定义：给定两个图：<span class="math inline">\(G_1和G_2\)</span>，没有先验知识，要恢复其对齐<span class="math inline">\(\pi\)</span>与此同时实现更高的MNC。</p><p><img src="../images/CONE/问题定义.png"></p><p>整体框架如下图所示：首先使用结点嵌入模拟图内的结点相似度，然后我们对齐嵌入空间以获得图之间的可比性。然后匹配两个网络中的结点用最相似的节点嵌入。</p><p><img src="../images/CONE/整体框架.png"></p><h2 id="step1node-embedding">1. step1：node embedding</h2><p>对于每个输入的图独自的获得其结点的嵌入<span class="math inline">\(Y_1,Y_2 ∈ R^{n \times d}\)</span>，我们只需要嵌入来保持图内节点的邻近性，每个图中的相邻节点都有相似的嵌入，在使用嵌入相似性时将被近距离映射。这有力地保留了MNC：即使节点由于缺少边[7]而不是邻居，许多节点嵌入算法也可以保持它们共享的任何高阶接近性。</p><h2 id="step2-embedding-space-alignment">2. step2： embedding space alignment</h2><p>由于嵌入目标的不变性，两个图的节点嵌入Y1和Y2可以相对于相互平移、旋转或重新缩放。在步骤2中对齐了两个嵌入子空间，我们解决了两个问题：</p><ol type="1"><li><p>procrustes：如果结点的对应关系已知，我们可以从正交矩阵<span class="math inline">\(O^d\)</span>中找到一个线性的变换Q。Q对齐结点嵌入矩阵的列，例如嵌入空间。可以被定义为解决下述的问题：</p><p><img src="../images/CONE/procrustes问题.png"></p><p>它的解为<span class="math inline">\(Q^*=UV^T\)</span>，其中<span class="math inline">\(U \Sigma V^T\)</span>是<span class="math inline">\(Y_1^TY_2\)</span>的SVD分解。</p></li><li><p>wasserstein：如果嵌入空间变化已知，可以从排列矩阵<span class="math inline">\(P^n\)</span>的集合中求解最优的节点对应关系P。P对齐节点嵌入矩阵的行，也就是结点。可以使用 Sinkhorn algorithm来最小化wasserstein distance：</p><p><img src="../images/CONE/wasserstein.png"></p></li><li><p>wasserstein procrustes：由于我们既不知道对应关系，也不知道转换，所以我们将这些问题结合起来：</p><p><img src="../images/CONE/解决方案.png"></p><p>我们等价的解决了<span class="math inline">\(max_{p∈p^n},max_{Q∈O^d}\)</span>的迹<span class="math inline">\(trace(Q^TY_1^TPY_2)\)</span>，通过一种随机优化方案，交替wasserstein以及procrustes问题。对于第T次迭代，我们使用目前的embedding转换矩阵Q对小批次的每次b个embeddings也就是<span class="math inline">\(Y_{1_t},Y_{2_t}\)</span>来找到一个匹配<span class="math inline">\(P_t\)</span>，使用sinkhorn算法λ正则化系数。我们随后使用wasserstein procrustes距离的梯度来更新Q。算法1如下：</p><p><img src="../images/CONE/alignment-embedding.png"></p></li><li><p>convex initialization：为了初始化上述非凸过程，我们转向了一个经典的凸图匹配公式：</p><p><img src="../images/CONE/凸初始化.png"></p><p>其中<span class="math inline">\(B^n\)</span>是<span class="math inline">\(p^n\)</span>的凸包，我们可以通过Frank-Wolfe algorithm找到全局最小的<span class="math inline">\(P^*\)</span>，经过<span class="math inline">\(n_0\)</span>次迭代，以及sinkhorn算法以<span class="math inline">\(λ_0\)</span>为正则化参数。使用<span class="math inline">\(Y_1和P^*Y_2\)</span>，以及一个初始的Q可以由正交的procrustes公式2生成。</p></li><li><p>complexity consideration：</p></li></ol><h2 id="step-3matching-nodes-with-embeddings">step 3：matching nodes with embeddings</h2><p>在将嵌入与最终的变换Q对齐后，在步骤3中，我们根据欧氏距离将𝐺1中的每个节点与𝐺2中的最近邻进行匹配。我们可以使用缩放修正来减轻“hub度”，即许多节点有相同的最近邻[11]，但我们发现没有必要。在[14]之后，我们使用一个𝑘-d树来进行快速最近邻搜索 h在<span class="math inline">\(Y_1Q\)</span>和<span class="math inline">\(Y_2\)</span>之间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>G-ALIGN代码解析</title>
    <link href="http://yoursite.com/2022/03/31/G-ALIGN%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/03/31/G-ALIGN%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-03-30T21:16:18.000Z</published>
    <updated>2022-05-30T02:07:45.708Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a></p><h1 id="embedding部分">1. embedding部分</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weight</span><span class="params">(modules, activation)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Weight initialization</span></span><br><span class="line"><span class="string">    :param modules: Iterable of modules</span></span><br><span class="line"><span class="string">    :param activation: Activation function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> modules:</span><br><span class="line">        <span class="keyword">if</span> isinstance(m, nn.Linear):<span class="comment">#判断m是否为nn.Linear类型，线性层</span></span><br><span class="line">            <span class="keyword">if</span> activation <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#没有激活函数的话就初始化不加增益</span></span><br><span class="line">                m.weight.data = init.xavier_uniform_(m.weight.data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m.weight.data = init.xavier_uniform_(m.weight.data,gain=nn.init.calculate_gain(activation.lower()))</span><br><span class="line">            <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                m.bias.data = init.constant_(m.bias.data, <span class="number">0.0</span>)</span><br></pre></td></tr></table></figure><p>这里涉及到的是一个权重的初始化的步骤，在神经网络中的初始化步骤很重要。初始化应该既保证输入输出的差异性，又能让model稳定而快速的收敛。描述差异性的方法就是数学中的方差。对于每个神经元的输入z，<span class="math inline">\(z=\sum_{i=1}^nw_ix_i\)</span>，其中n是上一层中的神经元的个数。</p><p>那么两个随机变量的方差的公式为：<span class="math inline">\(Var(w_ix_i)=E[w_i]^2Var(x_i)+E[x_i]^2Var(w_i)+Var(w_i)Var(x_i)\)</span>，可以知道如果<span class="math inline">\(E[x_i]=E[w_i]=0\)</span>，能通过批量归一化满足这一条件，那么就有：</p><p><span class="math inline">\(Var(z)=\sum_{i=1}^nVar(x_i)Var(w_i)\)</span>，如果随机变量独立同分布的话，<span class="math inline">\(Var(z)=nVar(w)Var(x)\)</span>。一般来讲，类别空间相较于样本空间更加稠密，所以反向传播的误差到样本空间将显得微不足道。我们要让样本空间与类别空间的分布差异不要太大，也就是方差尽可能相等。</p><p>Xavier初始化方法就是：</p><p><img src="../images/G-ALIGN源码分析/Xavier初始化.png"></p><p>gain参数就是可选择的缩放的参数，总之以上就是初始化为了让神经网络更加健壮的手段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
