<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris的个人博客</title>
  
  <subtitle>我的代码要为成艺术品</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-11T03:38:06.051Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pytorch总结</title>
    <link href="http://yoursite.com/2021/12/11/pytorch%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/12/11/pytorch%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-10T16:43:24.000Z</published>
    <updated>2021-12-11T03:38:06.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="torch.utils.data">1. torch.utils.data</h1><h2 id="torch.utils.data.dataloader类">1.1 torch.utils.data.DataLoader类</h2><p>是加载数据的核心，返回可迭代数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">torch</span>.<span class="title">utils</span>.<span class="title">data</span>.<span class="title">DataLoader</span><span class="params">(dataset, batch_size=<span class="number">1</span>, shuffle=False, sampler=None, batch_sampler=None, num_workers=<span class="number">0</span>, collate_fn=, pin_memory=False, drop_last=False, timeout=<span class="number">0</span>, worker_init_fn=None)</span></span></span><br><span class="line"><span class="class">'''</span></span><br><span class="line"><span class="class">* <span class="title">dataset</span>：加载的数据集</span></span><br><span class="line"><span class="class">* <span class="title">batch_size</span><span class="params">(int,optional)</span>：每批加载多少个样本</span></span><br><span class="line"><span class="class">* <span class="title">shuffle</span><span class="params">(bool,optional)</span>：默认是<span class="title">false</span>，当设置为<span class="title">true</span>时在每个<span class="title">epoch</span>对数据打乱</span></span><br><span class="line"><span class="class">** <span class="title">sampler</span> <span class="params">(Sampler, optional)</span>:</span> 定义从数据集中提取样本的策略,返回一个样本</span><br><span class="line">* batch_sampler (Sampler, optional): like sampler, but returns a batch of indices at a time 返回一批样本. 与atch_size, shuffle, sampler和 drop_last互斥.</span><br><span class="line">* num_workers (int, optional): 用于加载数据的子进程数。<span class="number">0</span>表示数据将在主进程中加载​​。（默认：<span class="number">0</span>）</span><br><span class="line">* collate_fn (callable, optional): 合并样本列表以形成一个 mini-batch.  <span class="comment">#　callable可调用对象</span></span><br><span class="line">* pin_memory (bool, optional): 如果为 <span class="literal">True</span>, 数据加载器会将张量复制到 CUDA 固定内存中,然后再返回它们.</span><br><span class="line">* drop_last (bool, optional): 设定为 <span class="literal">True</span> 如果数据集大小不能被批量大小整除的时候, 将丢掉最后一个不完整的batch,(默认：<span class="literal">False</span>).</span><br><span class="line">* timeout (numeric, optional): 如果为正值，则为从工作人员收集批次的超时值。应始终是非负的。（默认：<span class="number">0</span>）</span><br><span class="line">* worker_init_fn (callable, optional): If <span class="keyword">not</span> <span class="literal">None</span>, this will be called on each worker subprocess <span class="keyword">with</span> the worker id (an int <span class="keyword">in</span> ``[<span class="number">0</span>, num_workers - <span class="number">1</span>]``) <span class="keyword">as</span> input, after seeding <span class="keyword">and</span> before data loading. (default: <span class="literal">None</span>)．</span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>是一个数据加载器，结合了数据集和取样器，并且可以提供多个线程处理数据集。在训练模型时使用到此函数，用来把训练数据分成多个小组，此函数每次抛出一组数据。直至把所有的数据都抛出。做到一个数据的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">在神经网络中，参数默认是进行随机初始化的。</span></span><br><span class="line"><span class="string">不同的初始化参数往往会导致不同的结果，当得到比较好的结果时我们通常希望这个结果是可以复现的，</span></span><br><span class="line"><span class="string">在pytorch中，通过设置随机数种子也可以达到这么目的。</span></span><br><span class="line"><span class="string">torch.manual_seed(1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br><span class="line">BATCH_SIZE = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">x = torch.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">y = torch.linspace(<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">torch_dataset = Data.TensorDataset(x,y)<span class="comment">#将数据存入到数据库中</span></span><br><span class="line">loader = Data.DataLoader(</span><br><span class="line">    <span class="comment">#从dataset数据库中每次抽出batch_size个数据</span></span><br><span class="line">    dataset=torch_dataset,</span><br><span class="line">    batch_size=BATCH_SIZE,</span><br><span class="line">    shuffle=<span class="literal">True</span>,<span class="comment">#数据打乱</span></span><br><span class="line">    num_workers=<span class="number">2</span>,<span class="comment">#使用两个线程</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_batch</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> step,(batch_x,batch_y) <span class="keyword">in</span> enumerate(loader):</span><br><span class="line">            print(<span class="string">'Epoch:'</span>,epoch,<span class="string">'|Step:'</span>,step,<span class="string">"|batch x:"</span>,</span><br><span class="line">                  batch_x.numpy(),<span class="string">'|batch y:'</span>,batch_y.numpy())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    show_batch()</span><br><span class="line">[In]</span><br><span class="line">Epoch: <span class="number">0</span> |Step: <span class="number">0</span> |batch x: [<span class="number">5.</span> <span class="number">3.</span> <span class="number">1.</span> <span class="number">7.</span> <span class="number">9.</span>] |batch y: [ <span class="number">6.</span>  <span class="number">8.</span> <span class="number">10.</span>  <span class="number">4.</span>  <span class="number">2.</span>]</span><br><span class="line">Epoch: <span class="number">0</span> |Step: <span class="number">1</span> |batch x: [ <span class="number">8.</span> <span class="number">10.</span>  <span class="number">2.</span>  <span class="number">6.</span>  <span class="number">4.</span>] |batch y: [<span class="number">3.</span> <span class="number">1.</span> <span class="number">9.</span> <span class="number">5.</span> <span class="number">7.</span>]</span><br><span class="line">Epoch: <span class="number">1</span> |Step: <span class="number">0</span> |batch x: [<span class="number">5.</span> <span class="number">9.</span> <span class="number">2.</span> <span class="number">6.</span> <span class="number">1.</span>] |batch y: [ <span class="number">6.</span>  <span class="number">2.</span>  <span class="number">9.</span>  <span class="number">5.</span> <span class="number">10.</span>]</span><br><span class="line">Epoch: <span class="number">1</span> |Step: <span class="number">1</span> |batch x: [ <span class="number">3.</span>  <span class="number">4.</span>  <span class="number">7.</span> <span class="number">10.</span>  <span class="number">8.</span>] |batch y: [<span class="number">8.</span> <span class="number">7.</span> <span class="number">4.</span> <span class="number">1.</span> <span class="number">3.</span>]</span><br><span class="line">Epoch: <span class="number">2</span> |Step: <span class="number">0</span> |batch x: [<span class="number">6.</span> <span class="number">9.</span> <span class="number">4.</span> <span class="number">8.</span> <span class="number">7.</span>] |batch y: [<span class="number">5.</span> <span class="number">2.</span> <span class="number">7.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br><span class="line">Epoch: <span class="number">2</span> |Step: <span class="number">1</span> |batch x: [<span class="number">10.</span>  <span class="number">3.</span>  <span class="number">2.</span>  <span class="number">1.</span>  <span class="number">5.</span>] |batch y: [ <span class="number">1.</span>  <span class="number">8.</span>  <span class="number">9.</span> <span class="number">10.</span>  <span class="number">6.</span>]</span><br></pre></td></tr></table></figure><h2 id="torch.utils.data.dataset类">1.2 torch.utils.data.Dataset类</h2><p>创建数据集，有_getitem_(self,index)函数来根据索引序号来获取图片和标签，有len(self)函数来获取数据集的长度。其他的数据集类必须是其子类，要继承它的特性。</p><p>我们如果要自定义自己数据读取的方法，就需要继承torch.utils.data.Dataset，并将其封装到DataLoader中。torch.utils.data.Dataset表示该数据集，继承该类可以重载其中的方法，实现多种数据读取及数据预处理的方式。TensorDataset（）方法可以将tensor数据装载进入称为dataset</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,Dataset</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TensorDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data_tensor,target_tensor)</span>:</span></span><br><span class="line">        self.data_tensor = data_tensor</span><br><span class="line">        self.target_tensor = target_tensor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data_tensor[index],self.target_tensor[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.data_tensor.size(<span class="number">0</span>)</span><br><span class="line">data_tensor = torch.randn(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">target_tensor = torch.rand(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># print(target_tensor)</span></span><br><span class="line"><span class="comment">#将数据封装成dataset</span></span><br><span class="line">tensor_dataset = TensorDataset(data_tensor,target_tensor)</span><br><span class="line">print(len(tensor_dataset))</span><br><span class="line"><span class="comment">#可使用索引调用数据</span></span><br><span class="line">print(<span class="string">'tensor_dataset[0]：'</span>,tensor_dataset[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'len os tensor_dataset：'</span>,len(tensor_dataset))</span><br></pre></td></tr></table></figure><p><img src="/2021/12/11/pytorch%E6%80%BB%E7%BB%93/dataset数据类型.png"></p><p>得到的dataset的数据类型是一个元组，元组的每一个对象都是一个tensor数据类型。</p><h2 id="torch.utils.data.sampler">1.3 torch.utils.data.sampler</h2><p>对于可迭代样式的数据集，数据加载顺序完全由用户定义的可迭代样式控制。这样可以更轻松地实现块读取和动态批处理大小(可以每次生成一个批处理的样本)。</p><p>pytorch中提供了以下的集中不同方式的数据采样：</p><ul><li>sequential sampler（顺序采样）</li><li>random sampler（随机采样）</li><li>subset random sampler（子随机采样）</li><li>weighted random sampler（加权随机采样）</li></ul><p><strong><em>Squential Sampler</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,Dataset,Sampler</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequentialSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line">    <span class="string">r"""Samples elements sequentially, always in the same order.</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        data_source (Dataset): dataset to sample from</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data_source)</span>:</span></span><br><span class="line">        self.data_source = data_source</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(range(len(self.data_source)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data_source)</span><br><span class="line">data = list([<span class="number">17</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">8</span>])</span><br><span class="line">seq_sampler = SequentialSampler(data_source=data)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> seq_sampler:</span><br><span class="line">    print(<span class="string">"index: &#123;&#125;,data: &#123;&#125;"</span>.format(str(index),str(data[index])))</span><br><span class="line"></span><br><span class="line">[output]:</span><br><span class="line">index: <span class="number">0</span>,data: <span class="number">17</span></span><br><span class="line">index: <span class="number">1</span>,data: <span class="number">22</span></span><br><span class="line">index: <span class="number">2</span>,data: <span class="number">3</span></span><br><span class="line">index: <span class="number">3</span>,data: <span class="number">41</span></span><br><span class="line">index: <span class="number">4</span>,data: <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong><em>random sampler</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line"></span><br><span class="line">     <span class="string">r"""Samples elements randomly. If without replacement, then sample from a shuffled dataset.</span></span><br><span class="line"><span class="string">    If with replacement, then user can specify :attr:`num_samples` to draw.</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        data_source (Dataset): dataset to sample from</span></span><br><span class="line"><span class="string">        replacement (bool): samples are drawn with replacement if ``True``, default=``False``</span></span><br><span class="line"><span class="string">        num_samples (int): number of samples to draw, default=`len(dataset)`. This argument</span></span><br><span class="line"><span class="string">            is supposed to be specified only when `replacement` is ``True``.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data_source,replacement=False,num_samples=None)</span>:</span></span><br><span class="line">         self.data_source = data_source</span><br><span class="line">         <span class="comment">#这个参数控制的是否重复采样</span></span><br><span class="line">         self.replacement = replacement</span><br><span class="line">         self._num_samples = num_samples</span><br><span class="line">     <span class="string">''' @property是python的一种装饰器</span></span><br><span class="line"><span class="string">     是用来修饰方法的，可以使用它来创建只读属性</span></span><br><span class="line"><span class="string">    可以与所定义的属性配合使用，这样可以防止属性被修改</span></span><br><span class="line"><span class="string">     '''</span></span><br><span class="line"><span class="meta">     @property</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">num_samples</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">if</span>(self._num_samples <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">             <span class="keyword">return</span> len(self.data_source)</span><br><span class="line">         <span class="keyword">return</span> self._num_samples</span><br><span class="line">     <span class="comment">#返回数据集的长度</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> self.num_samples</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">         n = len(self.data_source)</span><br><span class="line">         <span class="keyword">if</span>(self.replacement):<span class="comment">#生成的随机数可能是重复的</span></span><br><span class="line">             <span class="keyword">return</span> iter(torch.randint(high=n,size=(self.num_samples,),dtype=torch.int64).tolist())</span><br><span class="line">         <span class="keyword">return</span> iter(torch.randperm(n).tolist())</span><br><span class="line">data = list([<span class="number">17</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">8</span>])</span><br><span class="line">ran_sampler = RandomSampler(data_source=data)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> ran_sampler:</span><br><span class="line">    print(<span class="string">"index: &#123;&#125;,data: &#123;&#125;"</span>.format(str(index),str(data[index])))</span><br><span class="line">index: <span class="number">0</span>,data: <span class="number">17</span></span><br><span class="line">index: <span class="number">4</span>,data: <span class="number">8</span></span><br><span class="line">index: <span class="number">3</span>,data: <span class="number">41</span></span><br><span class="line">index: <span class="number">2</span>,data: <span class="number">3</span></span><br><span class="line">index: <span class="number">1</span>,data: <span class="number">22</span></span><br></pre></td></tr></table></figure><p><strong><em>subset random sampler</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetRandomSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line">    <span class="string">r"""Samples elements randomly from a given list of indices, without replacement.</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        indices (sequence): a sequence of indices</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,indices)</span>:</span></span><br><span class="line">        self.indices = indices<span class="comment">#数据集的切片，划分训练集和测试集</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.indices[i] <span class="keyword">for</span> i <span class="keyword">in</span> torch.randperm(len(self.indices)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.indices)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     data = list([<span class="number">17</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">8</span>])</span><br><span class="line">sub_sampler = SubsetRandomSampler(indices=data[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> sub_sampler:</span><br><span class="line">    print(<span class="string">"index: &#123;&#125;,data: &#123;&#125;"</span>.format(str(index),str(data[index])))</span><br></pre></td></tr></table></figure><p><strong><em>weighted random sampler</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedRandomSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line">    <span class="string">r"""Samples elements from ``[0,..,len(weights)-1]`` with given probabilities (weights)."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weights, num_samples, replacement=True)</span>:</span></span><br><span class="line">         <span class="comment"># ...省略类型检查</span></span><br><span class="line">         <span class="comment"># weights用于确定生成索引的权重</span></span><br><span class="line">        self.weights = torch.as_tensor(weights, dtype=torch.double)</span><br><span class="line">        self.num_samples = num_samples</span><br><span class="line">        <span class="comment"># 用于控制是否对数据进行有放回采样</span></span><br><span class="line">        self.replacement = replacement</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 按照加权返回随机索引值</span></span><br><span class="line">        <span class="keyword">return</span> iter(torch.multinomial(self.weights, self.num_samples, self.replacement).tolist())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    weights = torch.Tensor([<span class="number">0</span>, <span class="number">10</span>, <span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">1.1</span>])</span><br><span class="line">    wei_sampler = WeightedRandomSampler(weights=weights, num_samples=<span class="number">6</span>, replacement=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;torch.utils.data&quot;&gt;1. torch.utils.data&lt;/h1&gt;
&lt;h2 id=&quot;torch.utils.data.dataloader类&quot;&gt;1.1 torch.utils.data.DataLoader类&lt;/h2&gt;
&lt;p&gt;是加载数据的核心
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记《ATTENT:Active Attribute Network Alignment》</title>
    <link href="http://yoursite.com/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/"/>
    <id>http://yoursite.com/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/</id>
    <published>2021-12-09T09:59:49.000Z</published>
    <updated>2021-12-09T14:42:17.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要">1. 摘要</h1><a id="more"></a><p>现有的大多数的处理网络用户对齐的方法主要集中在如何最好地利用网络拓扑和属性信息以及利用已知的anchor links。尽管如此，除了少数例外，如何通过积极获得高质量和信息丰富的锚点链接来提高对齐性能还没有得到很好的研究。关于主动网络对齐的稀疏文献引入了循环中的人来标记一些种子节点的对应关系（即锚定链接），从查询潜在匹配的最不确定的节点的角度来看，这些是有用的。<strong><em>然而，内在网络属性信息对对齐结果的直接影响在很大程度上仍然是未知的。</em></strong>在本文中，作者提出了一种主动网络对齐方法(Attent)来确定最佳的查询节点。该方法的关键思想是利用定义在对齐解决方案上的有效的影响函数来评估供查询的候选节点的优度。</p><h1 id="论文介绍">论文介绍</h1><p>网络对齐的对齐准确度是最重要的，因为其对下游的应用有至关重要的作用，如对齐网络中相同的用户。</p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/用户对齐节点选取.png"></p><p>上面的图像就说明了，选取的anchor links是很重要的。如果选择的是节点1和4及其对应的已知锚定节点a和d，那么其余的节点就能根据拓扑的一致性来连接。但是如果选择的是2和5及其对应的节点b和e，那么剩下的节点1，3，4，6就不能被对齐，因为节点1还是可能连接a或者c。（分析一下拓扑结构就可以发现了）</p><p>网络对齐是一种受约束的二次分配的问题，是NP hardness的，网络对齐的应用性通常被对齐精度所约束。对于如何主动获得高质量的锚链路，以进一步提高广泛的网络对齐精度，网络对齐算法尚未得到很好的研究。关于主动网络对齐的稀疏文献通过引入人工注释器来标记给定查询的正确匹配来解决一些锚链接可用时的这个问题。 查询节点的选择是由边际概率分布（即找到真实对齐的确定性）决定的。这种方法是查询具有高不确定性的节点。</p><p>现有的查询策略主要存在三个问题：</p><ul><li>查询对对齐结果的直接影响没有得到很好的研究，因为要查询的节点的选择依赖于对齐的抽样结果</li><li>网络属性信息如何改进主动网络对齐中的查询策略还没有深入研究</li><li>根据特定的采样策略，它可能具有较高的计算复杂度（如TopMatchings）</li></ul><p>本文作者提出了一种基于影响函数的查询策略（Attent），根据查询对网络对齐结果的影响，主动归属网络对齐，向人工注释者建议最佳的查询，以标记正确的对齐。该查询方法的关键思想是利用定义在网络对齐结果上的影响函数来评估要查询的候选节点的优度。具体来说就是，给定了来自归属网络对齐算法的对齐解向量，我们将查询的信息量量化为我们提出的效用函数对有关查询的对齐结果的变化速率。</p><p><strong><em>主动学习：在模型性能达到前提的情况下，尽可能减少标注样本。主动学习包含五个核心部分：未标注样本池、筛选策略、标注者、标注数据集、目标模型。主动学习将上述五个部分组合到一个流程中，直到目标模型达到预设的性能或者不再提供标注数据为止。主动学习也被应用在网络中。比方说基于不确定性，影响被应用于选择一个batch的探寻节点来标注，以此最大化网络分类的性能。</em></strong></p><p>本文的一些符号定义如下：</p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/本文的符号定义.png"></p><p><strong><em>Kronecker product：</em></strong></p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/克罗内克积.png"></p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/克罗内克积1.png"></p><p><strong><em>属性网络对齐</em></strong>：对齐两个网络的关键在于在三个方面的一致性（1）拓扑，（2）节点属性，（3）边属性。从优化的角度来看，归属网络对齐的目的是找到一个表示跨网络节点相似度的解矩阵X∈<span class="math inline">\(R^{n_t\times b}\)</span>，以最小化在上述三个方面中的不一致性 ，通过求解以下方程，得到了解矩阵的向量化，即x=vec(X)</p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/解矩阵向量.png"></p><p><span class="math inline">\(h=mat(H,n_t,n_s)\)</span>,<span class="math inline">\(H∈R^{n_s\times n_s}\)</span>是对齐偏好矩阵，表示跨两个输入网络的首选节点相似性，<span class="math inline">\(α∈(0,1)\)</span>是一个正则化参数，它决定了对齐结果向量x与偏好向量h的距离，<span class="math inline">\(\tilde{W}\)</span>编码拓扑结构，节点属性和边属性一致性的矩阵，<span class="math inline">\(\tilde{W}=D^{-1/2}WD^{-1/2}\)</span>表示<span class="math inline">\(W=N_X(E_X\cdot A_X)N_X\)</span>。用于归一化W的对角线矩阵D被定义为：</p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/对角矩阵D.png"></p><p>由于Kronecker product的特性，<span class="math inline">\(vec(ABC)=(C&#39;\otimes A)vec(B)\)</span>，解向量可以被表示为：</p><p><img src="/2021/12/09/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%8AATTENT-Active-Attribute-Network-Alignment%E3%80%8B/解向量.png"></p><p>Q是经过重构<span class="math inline">\(q=N_XD^{-1/2}x\)</span>在列顺序中定义的一个矩阵。如果节点和变得属性信息缺失了，那么x退化为：</p><p><span class="math inline">\(x=αD_n^{-1/2}A_XD_n^{-1/2}x+(1-α)h\)</span>，其中<span class="math inline">\(D_n=diag([A_s1]\otimes A_t1)\)</span>，1表示的是全1向量。</p><p>对齐偏好矩阵H包含两个输入网络的两个节点相似的先验知识。比方说，对于节点p，q在<span class="math inline">\(G_s\)</span>和<span class="math inline">\(G_t\)</span>中</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;1. 摘要&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Word2Vec总结</title>
    <link href="http://yoursite.com/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-07T12:22:41.000Z</published>
    <updated>2021-12-11T12:55:04.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="word2vec算法简介">1. Word2Vec算法简介</h1><a id="more"></a><p>为什么要进行word embedding？因为对于机器学习的输入来说，只接受数值型的输入，而对于NLP之中的语句，则是人类的特定的字符。所以必须要对其转换为数值类型，降维到一个数学空间中。最原始的方法就是one-hot embedding，但是这种算法复杂度太高，而且可扩展性不强。并且假设所有的词都是独立的，而现实中词与词之间不可能是独立的。</p><p>在NLP中，把x看作是一个句子中的词语，y是词语的上下文，f(x) -&gt; y就是语言模型，用来判断(x,y)是不是符合自然语言的法则。Word2vec就是这个思想，最终并不是要把f训练的多么完美，而是只关心模型参数(神经网络的权重)，并将这些参数，作为输入x的魔种向量化表示，也就是词向量。</p><p>按照下图的观念，我们有： <span class="math display">\[\vec{king} - \vec{man} + \vec{women} = \vec{queen}\]</span> <img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/词向量降维.png"></p><p>所以当我们考虑上下文的时候，比方说"我觉得C++很难"，那么从上下文来推测中间的词汇，就可以学习到中间的词汇可能是"C++",而从中间词汇推上下文，可以学习到"很难"。这两个就分别是word2vec中的CBOW模型以及Skip-gram模型的思想。</p><p>word2vec就是简化版的神经网络，输入是One-hot Vector，隐藏层没有激活函数，也就是线性的单元。输出的维度和输入的维度是一样的，用的是softmax进行分类输出。通过训练可以得到参数。</p><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/word2vec网络图.png"></p><p>Word2vec通过CBOW(Continuous Bag-of-Words)和Skip-Gram两种模型来定义输入或者输出。CBOW模型的训练输入是某一个特征词的上下文相关的词对应的词向量，而输出就是这特定的一个词的词向量。　Skip-Gram模型和CBOW的思路是反着来的，即输入是特定的一个词的词向量，而输出是特定词对应的上下文词向量。CBOW对小型数据库比较合适，而Skip-Gram在大型语料中表现更好。</p><h1 id="cbow模型">2. CBOW模型</h1><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/CBOW模型.png"></p><ul><li>输入层：上下文单词的独热向量，图中的向量空间维度为V，上下文单词个数为C</li><li>隐藏层：所有的独热向量分别乘以共享的权重矩阵<span class="math inline">\(W_{v\times N}\)</span>，那么初始的<span class="math inline">\(x_{1\times v}\)</span>就转换成了<span class="math inline">\(H_{1\times N}\)</span>的向量，一共有C个，将C个hidden layer的向量取平均得到一个1 * N大小的向量，作为hidden layer的值</li><li>输出层：输出层的权重矩阵为<span class="math inline">\(W&#39;_{N\times V}\)</span>，将得到的hidden layer向量与W'相乘，并通过linear layer的softmax，得到一个1 * V的向量，也就是代表各个词的频率了。选取频率最高的作为预测出来的中间词</li><li>与ground truth中的one hot比较，找出lost function的最小值，一般都是用的cross-entropy</li><li>训练完毕之后，输入层每个单词与W相乘得到的结果就是想要的word embedding</li></ul><h1 id="skip-gram模型">3. Skip-Gram模型</h1><p>Skip-Gram模型相当于CBOW模型的相反，是根据给定的input vector来预测上下文。训练skip-gram模型来实现以下为任务：给出一个句子中间的某个单词，观察输入单词旁边的单词并随机选择一个，而训练的神经网络将告诉我们词汇表中每个单词被选作临近单词的概率。所谓的临近单词与算法中设置的窗口大小(window size)有关，一般window size = 5，意思是预测上下文共10个词。</p><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/Skip-Gram模型.png"></p><ul><li>输入层：输入中心词汇<span class="math inline">\(x_k\)</span>，其周围有C个上下文词汇。输入是中心词的one-hot vector，维度是1 * V</li><li>隐藏层：通过预先初始化的权重<span class="math inline">\(W_{V\times N}\)</span>，来得到隐藏层的向量<span class="math inline">\(H_{1\times N}\)</span></li><li>输出层：从hidden layer到output layer做了C次的前向传递，每次的传递都与相同的W’权重矩阵相乘，产生V维的向量y。C由window size决定，故输出总和的大小为C*V</li><li>将这C次所产生的值<span class="math inline">\(y_1\)</span>到<span class="math inline">\(y_c\)</span>通过softmax进行分类，计算的是y的每一个维度的概率值。因此我们可以将y的每一个维度值视为所有相异的词汇与中心词汇的点积，点积越大，概率值就越大</li></ul><h1 id="优化">4. 优化</h1><p>skip-gram模型中包含着一个非常大的W向量，如果一个带有300个特征，含有10000个词汇，那么在隐藏层和输出层将会产生300w的向量维度，所以必须进行优化。</p><h2 id="hierarchical-softmax">4.1 Hierarchical Softmax</h2><p>Hierarchical Softmax是计算softmax的一种高效的方式。其思想是在求概率分布时，不对所有的词的概率求和来做归一化，这样就避免了对所有单词表示更新 。使用两种方式来减少计算量：</p><ul><li>输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用简单的对所有词向量求和取平均的方式。</li><li>从隐藏层到输出的softmax层这里的计算量采用霍夫曼树来代替从隐藏层到输出softmax层的映射。</li></ul><p>softmax回归是对语料库中的每个词语(类)都计算一遍输出概率并进行归一化，在大语料库中无疑是非常复杂的。Hierarchical Softmax就相当于一个哈夫曼树结构，如下所示：</p><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/Hierarchical%20Softmax.jpg"></p><p>每个叶子节点代表语料库中的一个词，于是每个词语都可以被01唯一的编码，并且其编码序列对应一个事件序列，于是我们可以计算条件概率<span class="math inline">\(p(w|Context(w))\)</span></p><p>符号定义：</p><table><colgroup><col style="width: 43%"><col style="width: 56%"></colgroup><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(p^w\)</span></td><td style="text-align: center;">从根节点出发到w对应叶子节点的路径</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(l^w\)</span></td><td style="text-align: center;">路径中包含节点的个数</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(p_1^w,p_2^w,...,p_{l^w}^w\)</span></td><td style="text-align: center;">路径<span class="math inline">\(p^w\)</span>中的各个节点</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(d_2^w,d_3^w,...,d_{l^w}^w∈\left\{0,1\right\}\)</span></td><td style="text-align: center;">词w的编码，<span class="math inline">\(d_j^w\)</span>表示路径<span class="math inline">\(p^w\)</span>第j个节点对应的编码（根节点无编码）</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(θ_1^w,θ_2^w,...,θ_{l^w - 1}^w\)</span></td><td style="text-align: center;">路径<span class="math inline">\(p^w\)</span>中非叶节点对应的参数向量</td></tr></tbody></table><p>于是可以给出w的条件概率： <span class="math display">\[p(w|Context(w)) = \prod_{j=2}^{l^w}p(d_j^w|x_w,θ_{j-1}^w)\]</span> 从根节点到叶子节点经过了<span class="math inline">\(l^w - 1\)</span>个节点，编码从下标2开始(根节点无编码)，对应的参数向量从下标1开始(根节点为1).</p><p>其中每一项为逻辑回归： <span class="math display">\[p\left(d_{j}^{w} \mid \mathbf{x}_{w}, \theta_{j-1}^{w}\right)=\left\{\begin{array}{ll}\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right), &amp; d_{j}^{w}=0 \\ 1-\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right), &amp; d_{j}^{w}=1\end{array}\right.\]</span> 考虑到d只有0和1两种取值，可以用指数形式方便将其写到一起： <span class="math display">\[p\left(d_{j}^{w} \mid \mathbf{x}_{w}, \theta_{j-1}^{w}\right)=\left[\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right]^{1-d_{j}^{w}} \cdot\left[1-\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right]^{d^w}\]</span> 选取目标函数为对数似然： <span class="math display">\[\mathcal{L}=\sum_{w \in \mathcal{C}} \log p(w \mid$ Context $(w))\]</span> 将<span class="math inline">\(p(w|Context(w))\)</span>带入上式，有： <span class="math display">\[\mathcal{L}=\sum_{w \in \mathcal{C}} \log \prod_{j=2}^{l^{w}}\left\{\left[\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right]^{1-d_{j}^{w}} \cdot\left[1-\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right]^{d_{j}^{w}}\right\}=\\\sum_{w \in \mathcal{C}} \sum_{j=2}^{l^{w}}\left\{\left(1-d_{j}^{w}\right) \cdot \log \left[\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right]+d_{j}^{w} \cdot \log \left[1-\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right]\right\}\]</span> 如何最大化对数似然函数呢？分别最大化每一项即可。先求函数对每个变量的偏导数，对每一个样本，带入偏导数表达式得到函数在该维度增长梯度，然后让对应参数加上这个梯度。 <span class="math display">\[\theta_{j-1}^{w}:=\theta_{j-1}^{w}+\eta\left[1-d_{j}^{w}-\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right] \mathbf{x}_{w}\]</span> 由于<span class="math inline">\(θ_{j-1}^w\)</span>和<span class="math inline">\(X_w\)</span>是对称的，所以可以直接得到<span class="math inline">\(X_w\)</span>的更新方程为： <span class="math display">\[\frac{\partial \mathcal{L}(w, j)}{\partial \mathbf{x}_{w}}=\left[1-d_{j}^{w}-\sigma\left(\mathbf{x}_{w}^{\top} \theta_{j-1}^{w}\right)\right] \theta_{j-1}^{w}\]</span> 不过<span class="math inline">\(X_w\)</span>是上下文的词向量的和，不是上下文单个词的词向量。word2vec使用的是直接将<span class="math inline">\(X_w\)</span>的更新量整个应用到每个单词的词向量上去。 <span class="math display">\[\mathbf{v}(\widetilde{w}):=\mathbf{v}(\widetilde{w})+\eta \sum_{j=2}^{l w} \frac{\partial \mathcal{L}(w, j)}{\partial \mathbf{x}_{w}}, \quad \widetilde{w} \in \operatorname{Context}(w)\]</span> 其中，<span class="math inline">\(\mathbf{v}(\widetilde{w})\)</span>表示上下文中某一单词的词向量。</p><h2 id="negative-sampling">4.2 Negative Sampling</h2><p>Hierarchical Softmax用霍夫曼树来代替传统的神经网络，可以提升模型训练的效率。但是如果我们的训练样本的中心词w是一个很生僻的词，那么就得在霍夫曼树中要向下走很久。Negative Sampling就是为了解决这个问题，每次就修改其中的一小部分weight，而不是全部。将随机选择一小部分的negative words来更新对应的权重参数。如果词汇表大小为1w，输入("中","国”)到神经网络时，"中"经过one-hot embedding之后，在输出层期望对应"国"单词的那个神经元节点输出为1，其余9999个都是输出为0。这里的negative word就是这9999个单词。相应的论文中，作者指出对应于小规模的数据集，建议选择5-20个negative words来更新对应的权重参数。</p><p>假设有一个训练样本，中心词是w，周围有2c个词是<span class="math inline">\(context(w)\)</span>。由于这个中心词w和context(x)的确相关存在，因此是一个真正的正例。通过Negative Sampling，我么们得到neg个和w不同的中心词<span class="math inline">\(w_i,i=1,2,...,neg\)</span>，这样的话<span class="math inline">\(context(w)\)</span>和<span class="math inline">\(w_i\)</span>就组成了neg个并不真实存在的负例。利用这个正例和neg个负例，进行二元逻辑回归，得到负采样对应每个词<span class="math inline">\(w_i\)</span>对应的模型参数<span class="math inline">\(θ_i\)</span>和每个词的词向量。</p><p>由于negative sampling没有使用霍夫曼树，每次通过采样neg不同的中心词作负例训练模型，因此整个过程要比Hierarchical Softmax简单。那么是如何进行negative sampling的呢？</p><p>在logistics regression中，<span class="math inline">\(P(context(w_0),w_i)=σ(x_{w_0}^Tθ^{w_i}),y_i=1,i=0\)</span></p><p>负例期望满足：<span class="math inline">\(P(context(w_0),w_i)=1-σ(x_{w_0}^Tθ^{w_i}),y_i=0,i=1,2,...,neg\)</span></p><p>此时模型的似然函数为：<span class="math inline">\(\prod_{i=0}^{n e g} \sigma\left(x_{\omega 0}^{T} \theta^{w_{i}}\right)^{y_{i}}\left(1-\sigma\left(x_{u 0}^{T} \theta^{w_{i}}\right)\right)^{1-y_{i}}\)</span></p><p>取对数似然：<span class="math inline">\(L=\sum_{i=0}^{n e g} y_{i} \log \left(\sigma\left(x_{u 0}^{T} \theta^{w_{i}}\right)\right)+\left(1-y_{i}\right) \log \left(1-\sigma\left(x_{u 0}^{T} \theta^{w_{i}}\right)\right)\)</span></p><p>负采样的方法是根据概率来的，更常出现的单词，更容易被选为negative samples。如果词汇表的大小为V，将长度为1的线段分为V份，每个词对应一个线段，每个词对应的线段长度是不相同的。高频对应的线段长，低频词对应的线段短。每个词的线段长度由下面的式子确定： <span class="math display">\[\operatorname{len}(w)=\frac{\operatorname{count}(w)^{3 / 4}}{\sum_{u \in v o c a b} \operatorname{count}(u)^{3 / 4}}\]</span> 这个3/4次方怎么出来的现在也没搞清楚(很玄学)。</p><p>在采样前，将这段长度为1的线段划分成M等份，这里M&gt;&gt;V，这样可以保证每个词对应的线段都会被划分成对应的小块。而M份中的每一份都会落在某一个词对应的线段上。在采样的时候，我们只需要从M个位置采样出neg位置就行，此时采样到的每个位置对应到的线段所属的词就是负采样到的词。</p><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/负采样.png"></p><h3 id="基于negative-sampling的skip-gram模型">4.2.1 基于Negative Sampling的Skip-Gram模型</h3><p>输入：基于Skip-Gram的语料训练样本，词向量的维度大小M count，Skip-Gram的上下文大小为2c，步长为ŋ，负采样的个数neg。</p><p>输出：词汇表每个词对应的模型参数θ，所有的词向量<span class="math inline">\(x_w\)</span></p><ol type="1"><li><p>随机初始化所有的模型参数θ，所有的词向量w</p></li><li><p>对于每个训练样本<span class="math inline">\((context(w_0),w_0)\)</span>，负采样出neg个负例中心词<span class="math inline">\(w_i,i=1,2,...,neg\)</span></p></li><li><p>进行梯度上升迭代过程，对于训练集中的每个样本<span class="math inline">\((context(w_0),w_0,w_1,...,w_{neg})\)</span>作以下处理：</p><ol type="1"><li><p>for i = 1 to 2c:</p><ol type="1"><li><p>e = 0</p></li><li><p>for j = 0 to neg,计算： <span class="math display">\[f=\sigma\left(x_{w_{0} t}^{T} \theta^{w_{j}}\right)\\g=\left(y_{j}-f\right) \eta\\e=e+g \theta^{w_{j}}\\\theta^{w_{j}}=\theta^{w_{j}}+g x_{w_{0 i}}\]</span></p></li></ol></li><li><p>词向量更新：</p></li></ol><p><span class="math display">\[   x_{w0i}=x{w0i}+e   \]</span></p></li><li><p>如果梯度收敛，则结束梯度迭代，算法结束，否则回到步骤a继续迭代。</p></li></ol><h1 id="代码实现">5. 代码实现</h1><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/word2vec流程.png"></p><p>输入到Embedding层的数据是[batch_size,seq_len]，输出的是[batch_size,seq_len,embedding_dim]。</p><p>将单词转换为词向量：</p><ul><li>提取文章中的所有单词，把所有单词按照频次降序排序(取前49999个，其余所有单词都是归属为others，记作'<UNK>'，一共有50000个单词)</UNK></li><li>对50000个单词使用one-hot embedding</li><li>通过训练生成一个50000*300的矩阵，每一行表示一个词的word vector。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> tud</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">1</span>)</span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">C = <span class="number">3</span>  <span class="comment"># context window</span></span><br><span class="line"><span class="string">'''使用负采样进行训练，窗的大小是3，随机选取15个噪声词'''</span></span><br><span class="line">K = <span class="number">15</span>  <span class="comment"># number of negative samples</span></span><br><span class="line">epochs = <span class="number">2</span></span><br><span class="line"><span class="string">'''训练10000个词的词向量，实际上会选出语料库出现的最多的9999个词</span></span><br><span class="line"><span class="string">还有一个是&lt;UNK&gt;标记其他的所有词</span></span><br><span class="line"><span class="string">每个词的词向量的维度是100</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">MAX_VOCAB_SIZE = <span class="number">10000</span></span><br><span class="line">EMBEDDING_SIZE = <span class="number">100</span></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">lr = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'text8.train.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()  <span class="comment"># 得到文本内容</span></span><br><span class="line"><span class="comment">#将所有的字母全部转换成小写，因为大写和小写的含义都是一样的</span></span><br><span class="line">text = text.lower().split()  <span class="comment"># 分割成单词列表</span></span><br><span class="line"><span class="comment">#找出前MAX_VOCAB_SIZE - 1个出现最多的元素并将其放在字典里面</span></span><br><span class="line">vocab_dict = dict(Counter(text).most_common(MAX_VOCAB_SIZE - <span class="number">1</span>))  <span class="comment"># 得到单词字典表，key是单词，value是次数</span></span><br><span class="line">vocab_dict[<span class="string">'&lt;UNK&gt;'</span>] = len(text) - np.sum(list(vocab_dict.values()))  <span class="comment"># 把不常用的单词都编码为"&lt;UNK&gt;"，词的总个数减去常见词的个数，作为不常见词的词频</span></span><br><span class="line">word2idx = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(vocab_dict.keys())&#125;<span class="comment">#word-id的映射表</span></span><br><span class="line">idx2word = &#123;i: word <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(vocab_dict.keys())&#125;<span class="comment">#id-word的映射表</span></span><br><span class="line">word_counts = np.array([count <span class="keyword">for</span> count <span class="keyword">in</span> vocab_dict.values()], dtype=np.float32)<span class="comment">#统计词频</span></span><br><span class="line">word_freqs = word_counts / np.sum(word_counts)<span class="comment">#将频数改为概率</span></span><br><span class="line">word_freqs = word_freqs ** (<span class="number">3.</span> / <span class="number">4.</span>)<span class="comment">#3/4次方是负采样中使用的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordEmbeddingDataset</span><span class="params">(tud.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text, word2idx, word_freqs)</span>:</span></span><br><span class="line">        <span class="string">''' text: a list of words, all text from the training dataset</span></span><br><span class="line"><span class="string">            word2idx: the dictionary from word to index</span></span><br><span class="line"><span class="string">            word_freqs: the frequency of each word</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        super(WordEmbeddingDataset, self).__init__()  <span class="comment"># #通过父类初始化模型，然后重写两个方法</span></span><br><span class="line">        <span class="string">'''将单词表示为数字，if word not in text，那就是&lt;UNK&gt;'''</span></span><br><span class="line">        self.text_encoded = [word2idx.get(word, word2idx[<span class="string">'&lt;UNK&gt;'</span>]) <span class="keyword">for</span> word <span class="keyword">in</span> text]  <span class="comment"># 把单词数字化表示。如果不在词典中，也表示为unk</span></span><br><span class="line">        self.text_encoded = torch.LongTensor(self.text_encoded)  <span class="comment"># nn.Embedding需要传入LongTensor类型</span></span><br><span class="line">        self.word2idx = word2idx</span><br><span class="line">        self.word_freqs = torch.Tensor(word_freqs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.text_encoded)  <span class="comment"># 返回所有单词的总数，即item的总数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        <span class="string">''' 这个function返回以下数据用于训练</span></span><br><span class="line"><span class="string">            - 中心词</span></span><br><span class="line"><span class="string">            - 这个单词附近的positive word</span></span><br><span class="line"><span class="string">            - 随机采样的K个单词作为negative word</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        center_words = self.text_encoded[idx]  <span class="comment"># 取得中心词</span></span><br><span class="line">        pos_indices = list(range(idx - C, idx)) + list(range(idx + <span class="number">1</span>, idx + C + <span class="number">1</span>))  <span class="comment"># 先取得中心左右各C个词的索引</span></span><br><span class="line">        pos_indices = [i % len(self.text_encoded) <span class="keyword">for</span> i <span class="keyword">in</span> pos_indices]  <span class="comment"># 为了避免索引越界，所以进行取余处理</span></span><br><span class="line">        pos_words = self.text_encoded[pos_indices]  <span class="comment"># tensor(list)</span></span><br><span class="line">        <span class="comment">#shape[0]表示行数，也就是positive words的个数，对于每个positive words都要取样K个words</span></span><br><span class="line">        neg_words = torch.multinomial(self.word_freqs, K * pos_words.shape[<span class="number">0</span>], <span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># torch.multinomial作用是对self.word_freqs做K * pos_words.shape[0]次取值，输出的是self.word_freqs对应的下标</span></span><br><span class="line">        <span class="comment"># True表示取样方式采用有放回的采样，并且self.word_freqs数值越大，取样概率越大</span></span><br><span class="line">        <span class="comment"># 每采样一个正确的单词(positive word)，就采样K个错误的单词(negative word)，pos_words.shape[0]是正确单词数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># while 循环是为了保证 neg_words中不能包含context words</span></span><br><span class="line">        <span class="keyword">while</span> len(set(pos_indices) &amp; set(neg_words)) &gt; <span class="number">0</span>:</span><br><span class="line">            neg_words = torch.multinomial(self.word_freqs, K * pos_words.shape[<span class="number">0</span>], <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> center_words, pos_words, neg_words</span><br><span class="line"></span><br><span class="line"><span class="string">'''获取dataloader'''</span></span><br><span class="line">dataset = WordEmbeddingDataset(text, word2idx, word_freqs)</span><br><span class="line">dataloader = tud.DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmbeddingModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocab_size, embed_size)</span>:</span></span><br><span class="line">        super(EmbeddingModel, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.embed_size = embed_size</span><br><span class="line"></span><br><span class="line">        self.in_embed = nn.Embedding(self.vocab_size, self.embed_size)<span class="comment">#10000*300</span></span><br><span class="line">        self.out_embed = nn.Embedding(self.vocab_size, self.embed_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input_labels, pos_labels, neg_labels)</span>:</span></span><br><span class="line">        <span class="string">''' input_labels: center words, [batch_size]</span></span><br><span class="line"><span class="string">            pos_labels: positive words, [batch_size, (window_size * 2)]</span></span><br><span class="line"><span class="string">            neg_labels：negative words, [batch_size, (window_size * 2 * K)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            return: loss, [batch_size]</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        input_embedding = self.in_embed(input_labels)  <span class="comment"># [batch_size, embed_size]</span></span><br><span class="line">        pos_embedding = self.out_embed(pos_labels)  <span class="comment"># [batch_size, (window * 2), embed_size]</span></span><br><span class="line">        neg_embedding = self.out_embed(neg_labels)  <span class="comment"># [batch_size, (window * 2 * K), embed_size]</span></span><br><span class="line"></span><br><span class="line">        input_embedding = input_embedding.unsqueeze(<span class="number">2</span>)  <span class="comment"># [batch_size, embed_size, 1]，在维度2上增加一个维度1</span></span><br><span class="line"></span><br><span class="line">        pos_dot = torch.bmm(pos_embedding, input_embedding)  <span class="comment"># [batch_size, (window * 2), 1]，计算pos_embedding, input_embedding矩阵乘法</span></span><br><span class="line">        pos_dot = pos_dot.squeeze(<span class="number">2</span>)  <span class="comment"># [batch_size, (window * 2)]</span></span><br><span class="line"></span><br><span class="line">        neg_dot = torch.bmm(neg_embedding, -input_embedding)  <span class="comment"># [batch_size, (window * 2 * K), 1]</span></span><br><span class="line">        neg_dot = neg_dot.squeeze(<span class="number">2</span>)  <span class="comment"># batch_size, (window * 2 * K)]</span></span><br><span class="line"></span><br><span class="line">        log_pos = F.logsigmoid(pos_dot).sum(<span class="number">1</span>)  <span class="comment"># .sum()结果只为一个数，.sum(1)结果是一维的张量，压缩到一维</span></span><br><span class="line">        log_neg = F.logsigmoid(neg_dot).sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        loss = log_pos + log_neg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -loss</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_embedding</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.in_embed.weight.detach().numpy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = EmbeddingModel(MAX_VOCAB_SIZE, EMBEDDING_SIZE)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i, (input_labels, pos_labels, neg_labels) <span class="keyword">in</span> enumerate(dataloader):</span><br><span class="line">        input_labels = input_labels.long()</span><br><span class="line">        pos_labels = pos_labels.long()</span><br><span class="line">        neg_labels = neg_labels.long()</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss = model(input_labels, pos_labels, neg_labels).mean()</span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'epoch'</span>, e, <span class="string">'iteration'</span>, i, loss.item())</span><br><span class="line">            torch.save(model.state_dict(), <span class="string">"embedding-&#123;&#125;.th"</span>.format(EMBEDDING_SIZE))</span><br><span class="line"></span><br><span class="line">embedding_weights = model.input_embedding()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_nearest</span><span class="params">(word)</span>:</span></span><br><span class="line">    index = word2idx[word]</span><br><span class="line">    embedding = embedding_weights[index]</span><br><span class="line">    cos_dis = np.array([scipy.spatial.distance.cosine(e, embedding) <span class="keyword">for</span> e <span class="keyword">in</span> embedding_weights])</span><br><span class="line">    <span class="keyword">return</span> [idx2word[i] <span class="keyword">for</span> i <span class="keyword">in</span> cos_dis.argsort()[:<span class="number">10</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> [<span class="string">"two"</span>, <span class="string">"america"</span>, <span class="string">"computer"</span>]:</span><br><span class="line">    print(word, find_nearest(word))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;word2vec算法简介&quot;&gt;1. Word2Vec算法简介&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点.md</title>
    <link href="http://yoursite.com/2021/12/04/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-md/"/>
    <id>http://yoursite.com/2021/12/04/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-md/</id>
    <published>2021-12-04T14:13:44.000Z</published>
    <updated>2021-12-07T03:05:27.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库基本概念">1.数据库基本概念</h1><a id="more"></a><ul><li><p>DQL：数据查询语言（凡是带有select关键字的都是查询语句）</p></li><li><p>DML：数据操作语言（凡是对表当中的数据进行增删改的都是DML） insert 增 delete 删 update 改</p></li><li><p>DDL：数据定义语言，凡是带有create、drop、alter的都是DDL DDL主要操作的是表的结构，不是表中的数据，与DML不同</p></li><li><p>TCL：事务控制语言，包括：事务提交（commit）；事务回滚（rollback）</p></li><li><p>DCL：数据控制语言（例如：授权grant、撤销权限revoke）</p></li><li><p>在所有的数据库中，单引号是字符串的标准，但是MySQL中可以使用''来定义字符串，不过一般建议用''定义字符串</p></li></ul><h1 id="mysql基本操作">2.MySQL基本操作</h1><ul><li><p>起别名：mysql&gt; select deptno,dname as deptname from dept;（只会改变显示的结果而不会改变原本表中的结果）</p></li><li><p>条件查询：mysql&gt; select empno,ename from emp where sal &gt; 800; 查询在某个值之间的值：mysql&gt; select empno,ename,sal from emp where sal between 2450 and 3000;</p></li><li><p>and的优先级比or更高，如果不确定优先级，加小括号就好了</p></li><li><p>模糊查询：like，支持%或下划线匹配，%匹配任意字符，下划线只匹配一个字符 eg.找出名字中含有o的：select ename from emp where ename like '%o%'; 找出名字以T结尾的：select ename from emp where ename like '%T'; 找出名字第二个字母是A的：select ename from emp where ename like '_A%'; 找出名字第三个字母是'R'的</p></li></ul><p>找出名字中含有'_'的（要使用转义字符）：select name from emp where name like '%_%';</p><ul><li><p>排序：</p><ol type="1"><li>查询所有员工工资，排序（升序）：mysql&gt; select ename,sal from emp order by sal;</li><li>查询所有员工工资，排序（降序）：mysql&gt; select ename,sal from emp order by sal desc;</li><li>查询员工的名字和薪资，如果工资一样，按照名字首字母的升序排列：select ename,sal from emp order by sal asc,ename asc;</li><li>数据处理函数（单行处理函数） 单行处理函数的特点：一个输入对应一个输出 多行处理函数：多个输入对应一个输出</li></ol><p>单行处理函数常见的： lower：转成小写：mysql&gt; select lower(ename) from emp; upper：转成大写 str_to_date：将字符串转换为日期 date_format：格式化日期 format：设置千分位 round：四舍五入 rand()：生成随机数 ifnull：将null转换成一个具体值 substr:截取字符串：select ename from emp where substr(ename,1,1) = 'A';（选取开头是A的名字） concat：字符串拼接：mysql&gt; select concat(empno,ename) from emp;</p><p>分组函数（多行处理函数）： 多行处理函数：输入多行，最终输出一行 count：计数 sum：求和 avg：平均值。计算工资的平均值mysql&gt; select avg(sal) from emp; max：最大值 min：最小值 注意：分组函数在使用的时候必须先进行分组，然后才能使用。如果没有对数据进行分组，整张表默认为一组。</p><p>注意事项： 1. 分组函数会自动处理null，不用处理null 2. count(具体字段)：表示统计该字段下所有不为null的元素的总和 count(*)：统计表当中的总行数（只要有一行数据存在不为空就++） 3. 分组函数不能直接使用在where语句中 4. 所有的分组函数可以组合起来一起使用</p><ul><li>分组查询 在实际的应用中，可能有这样的需求，需要先进行分组，然后对每一分组进行操作，这时候就要进行分组查询。 语法为：select ... from ... group by ... 为什么分组函数不能用在where后面：因为分组函数在使用的时候，必须先分组后才能使用，where执行的时候，还没有分组，所以where后面不能出现分组函数。</li></ul><p>关键字的执行顺序： 1.from 2.where 3.group by 4.select 5.order by</p><p>结论：在一条select语句中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其他的一律不能跟。</p><p>找出每个部门的最高薪资：mysql&gt; select deptno,max(sal) from emp group by deptno;</p><p>mysql&gt; select job,deptno,max(sal) from emp group by job,deptno;</p><ul><li>找出每个部门的最高薪资，并且薪资大于3000：mysql&gt; select deptno,max(sal) from emp group by deptno having max(sal) &gt; 3000; 使用的是having语句，当分组完之后还需要过滤的话就需要saving语句，saving必须与group by一起使用，且不能代替where语句。</li></ul><p>优化策略：where和having，优先选择where，where实在完成不了的话，再选择having。</p><ul><li>去除重复数据：使用关键字（distinct） mysql&gt; select distinct job,deptno from emp;</li></ul><p>distinct出现在job，deptno两个字段之前，表示两个字段联合起来去重。mysql&gt; select distinct job,deptno from emp;</p><ul><li>连接查询 从一张表中单独查询，称为单表查询。emp表和sept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询。</li></ul><p>表连接的分类：</p><ol type="1"><li>内连接： 等值连接 非等值连接 自连接</li><li>外连接 左外连接（左连接） 右外连接（右连接）</li></ol><p>笛卡尔积：当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表的条数的总和。这种现象称为笛卡尔积现象。</p><p>避免笛卡尔积现象：连接时加条件，满足条件的被筛选出来</p><p>mysql&gt; select ename,dname from emp,dept where emp.deptno = dept.deptno; 最终的查询结果数是14条，但是匹配的过程中，匹配的次数并没有减少，只不过是进行了四选一。</p><p>内连接之等值连接： 查询每个员工所在部门名称，显示员工名1和部门名，条件是：e.deptno = d..deptno;</p><p>SQL99的语法和之前的不太一样： mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;</p><ul><li>对比：</li></ul><ol type="1"><li>mysql&gt; select ename,dname from emp,dept where emp.deptno = dept.deptno;//这是SQL92，结构不清晰，表的连接条件和后期进一步筛选的条件都放到了一起，都放到了where后面。</li><li>mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;//表的连接条件是独立的，连接之后，如果还需要进一步筛选，可以再往后继续添加where</li></ol><ul><li><p>SQL99的语法：select ... from a join b on a连接b的条件 where 筛选条件</p></li><li><p>内连接之非等值连接 有下表： +-------+--------+-----------+------+------------+---------+---------+--------+ | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | +-------+--------+-----------+------+------------+---------+---------+--------+ | 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 | | 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 | | 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 | | 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 | | 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 | | 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 | | 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 | | 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 | | 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 | | 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 | | 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 | | 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 | | 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 | | 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 | +-------+--------+-----------+------+------------+---------+---------+--------+</p></li></ul><p>薪资等级表： +-------+-------+-------+ | GRADE | LOSAL | HISAL | +-------+-------+-------+ | 1 | 700 | 1200 | | 2 | 1201 | 1400 | | 3 | 1401 | 2000 | | 4 | 2001 | 3000 | | 5 | 3001 | 9999 | +-------+-------+-------+ 找出每个员工的薪资等级，要求显示员工名、薪资、薪资与等级。 mysql&gt; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</p><ul><li><p>内连接之自连接 查询员工的上级领导，要求显示员工名和对应的领导名。 对应的技巧就是将一张表看成两张表。 mysql&gt; select a.ename as '员工名',b.ename as '领导名' from emp a join emp b on a.mgr = b.empno; +-----------+-----------+ | 员工名 | 领导名 | +-----------+-----------+ | SMITH | FORD | | ALLEN | BLAKE | | WARD | BLAKE | | JONES | KING | | MARTIN | BLAKE | | BLAKE | KING | | CLARK | KING | | SCOTT | JONES | | TURNER | BLAKE | | ADAMS | SCOTT | | JAMES | BLAKE | | FORD | JONES | | MILLER | CLARK | +-----------+-----------+</p></li><li><p>外连接 员工表： +-------+--------+-----------+------+------------+---------+---------+--------+ | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | +-------+--------+-----------+------+------------+---------+---------+--------+ | 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 | | 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 | | 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 | | 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 | | 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 | | 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 | | 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 | | 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 | | 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 | | 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 | | 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 | | 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 | | 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 | | 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 | +-------+--------+-----------+------+------------+---------+---------+--------+</p></li></ul><p>部门表： +--------+------------+----------+ | DEPTNO | DNAME | LOC | +--------+------------+----------+ | 10 | ACCOUNTING | NEW YORK | | 20 | RESEARCH | DALLAS | | 30 | SALES | CHICAGO | | 40 | OPERATIONS | BOSTON | +--------+------------+----------+</p><p>找出每个员工对应的岗位：mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno; +--------+------------+ | ename | dname | +--------+------------+ | SMITH | RESEARCH | | ALLEN | SALES | | WARD | SALES | | JONES | RESEARCH | | MARTIN | SALES | | BLAKE | SALES | | CLARK | ACCOUNTING | | SCOTT | RESEARCH | | KING | ACCOUNTING | | TURNER | SALES | | ADAMS | RESEARCH | | JAMES | SALES | | FORD | RESEARCH | | MILLER | ACCOUNTING | +--------+------------+ 内连接的特点：完成能够匹配上这个连接的才显示出来</p><p>外连接查询：mysql&gt; select e.ename,d.dname from emp e right (outer) join dept d on e.deptno = d.deptno;（右外连接，right表示将join关键字右边的表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表）outer关键字可以省略 在外连接中，两张表连接产生了主次关系。外连接的查询结果条数&gt;=内连接的查询结果条数 +--------+------------+ | ename | dname | +--------+------------+ | MILLER | ACCOUNTING | | KING | ACCOUNTING | | CLARK | ACCOUNTING | | FORD | RESEARCH | | ADAMS | RESEARCH | | SCOTT | RESEARCH | | JONES | RESEARCH | | SMITH | RESEARCH | | JAMES | SALES | | TURNER | SALES | | BLAKE | SALES | | MARTIN | SALES | | WARD | SALES | | ALLEN | SALES | | NULL | OPERATIONS | +--------+------------+</p><ul><li>三张表和四张表的连接方式</li></ul><p>语法：select ... from a join b on a和b的连接条件 join c on a和c的连接条件 join d on a和d的连接条件（一条SQL中内连接和外连接可以混合，都可以出现） eg.找出每个员工的部门名称及工资等级，要求显示员工名、部门名、薪资、薪资等级</p><p>新用到的表如下： +-------+-------+-------+ | GRADE | LOSAL | HISAL | +-------+-------+-------+ | 1 | 700 | 1200 | | 2 | 1201 | 1400 | | 3 | 1401 | 2000 | | 4 | 2001 | 3000 | | 5 | 3001 | 9999 | +-------+-------+-------+</p><p>实现：mysql&gt; select e.ename,e.sal,d.dname,s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal; +--------+---------+------------+-------+ | ename | sal | dname | grade | +--------+---------+------------+-------+ | SMITH | 800.00 | RESEARCH | 1 | | ALLEN | 1600.00 | SALES | 3 | | WARD | 1250.00 | SALES | 2 | | JONES | 2975.00 | RESEARCH | 4 | | MARTIN | 1250.00 | SALES | 2 | | BLAKE | 2850.00 | SALES | 4 | | CLARK | 2450.00 | ACCOUNTING | 4 | | SCOTT | 3000.00 | RESEARCH | 4 | | KING | 5000.00 | ACCOUNTING | 5 | | TURNER | 1500.00 | SALES | 3 | | ADAMS | 1100.00 | RESEARCH | 1 | | JAMES | 950.00 | SALES | 1 | | FORD | 3000.00 | RESEARCH | 4 | | MILLER | 1300.00 | ACCOUNTING | 2 | +--------+---------+------------+-------+</p><p>eg.找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级。 mysql&gt; select e.ename,e.sal,d.dname,s.grade,l.ename from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp l on e.mgr = l.empno;</p><p>+--------+---------+------------+-------+-------+ | ename | sal | dname | grade | ename | +--------+---------+------------+-------+-------+ | SMITH | 800.00 | RESEARCH | 1 | FORD | | ALLEN | 1600.00 | SALES | 3 | BLAKE | | WARD | 1250.00 | SALES | 2 | BLAKE | | JONES | 2975.00 | RESEARCH | 4 | KING | | MARTIN | 1250.00 | SALES | 2 | BLAKE | | BLAKE | 2850.00 | SALES | 4 | KING | | CLARK | 2450.00 | ACCOUNTING | 4 | KING | | SCOTT | 3000.00 | RESEARCH | 4 | JONES | | KING | 5000.00 | ACCOUNTING | 5 | NULL | | TURNER | 1500.00 | SALES | 3 | BLAKE | | ADAMS | 1100.00 | RESEARCH | 1 | SCOTT | | JAMES | 950.00 | SALES | 1 | BLAKE | | FORD | 3000.00 | RESEARCH | 4 | JONES | | MILLER | 1300.00 | ACCOUNTING | 2 | CLARK | +--------+---------+------------+-------+-------+</p><ul><li>子查询 select语句中嵌套select，被嵌套的select语句称为子查询。</li></ul><ol type="1"><li>where子句中的子查询 eg.找出比最低工资高的员工姓名和工资 由于where子句中不能直接使用分组函数，所以使用嵌套 mysql&gt; select ename,sal from emp where sal &gt; (select min(sal) from emp);</li></ol><p>结果为： +--------+---------+ | ename | sal | +--------+---------+ | ALLEN | 1600.00 | | WARD | 1250.00 | | JONES | 2975.00 | | MARTIN | 1250.00 | | BLAKE | 2850.00 | | CLARK | 2450.00 | | SCOTT | 3000.00 | | KING | 5000.00 | | TURNER | 1500.00 | | ADAMS | 1100.00 | | JAMES | 950.00 | | FORD | 3000.00 | | MILLER | 1300.00 | +--------+---------+</p><ol start="2" type="1"><li>from子句中的子查询 注意：from后面的子查询，可以将子查询的查询结果当作一张临时表。 eg.找出每个岗位的平均工资的薪资等级 实现：mysql&gt; select t.*,s.grade from (select job,avg(sal) as avgsal from emp group by job) t join salgrade s on t.avgsal between s.losal and s.hisal;</li></ol><p>结果： +-----------+-------------+-------+ | job | avgsal | grade | +-----------+-------------+-------+ | CLERK | 1037.500000 | 1 | | SALESMAN | 1400.000000 | 2 | | MANAGER | 2758.333333 | 4 | | ANALYST | 3000.000000 | 4 | | PRESIDENT | 5000.000000 | 5 | +-----------+-------------+-------+ (select job,avg(sal) as avgsal from emp group by job)相当于一个新的表avgsal，是临时的表。</p><ul><li><p>select后面出现的子查询 eg.找出每个员工的部门名称，要求显示员工名，部门名 实现：mysql&gt; select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; 结果： +--------+------------+ | ename | dname | +--------+------------+ | SMITH | RESEARCH | | ALLEN | SALES | | WARD | SALES | | JONES | RESEARCH | | MARTIN | SALES | | BLAKE | SALES | | CLARK | ACCOUNTING | | SCOTT | RESEARCH | | KING | ACCOUNTING | | TURNER | SALES | | ADAMS | RESEARCH | | JAMES | SALES | | FORD | RESEARCH | | MILLER | ACCOUNTING | +--------+------------+</p></li><li><p>union合并查询结果集 eg.查询工作岗位是MANAGER和SALESMAN的员工 方法1：select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN'; 方法2：select ename,job from emp where job in('MANAGER','SALESMAN'); 方法3：select ename,job from emp where job = 'MANAGER' union select ename,job from emp where job = 'SALESMAN'; （这里的方法3的效率最高） 结果： +--------+----------+ | ename | job | +--------+----------+ | JONES | MANAGER | | BLAKE | MANAGER | | CLARK | MANAGER | | ALLEN | SALESMAN | | WARD | SALESMAN | | MARTIN | SALESMAN | | TURNER | SALESMAN | +--------+----------+ union在进行结果合并时，要求两个结果集的列数相等。</p></li><li><p>limit的作用 将查询结果的一部分取出来，通常使用在分页查询中。 eg.按照工资降序，取出排名在前5名的员工 实现：mysql&gt; select ename,sal from emp order by sal desc limit 5; 结果： +-------+---------+ | ename | sal | +-------+---------+ | KING | 5000.00 | | SCOTT | 3000.00 | | FORD | 3000.00 | | JONES | 2975.00 | | BLAKE | 2850.00 | +-------+---------+</p></li></ul><p>完整用法：limit startIndex,length MySQL中的limit在order by之后执行。</p><ul><li><p>分页 limit (pageNo - 1) * pageSize,pageSize;</p></li><li><p>DQL语句的总结 select ... from ... where ... group by ... having ... order by ... limit ...</p></li></ul></li></ul><h1 id="数据库基本操作2ddl">3. 数据库基本操作2（DDL）</h1><ul><li><p>表的创建 语法格式：create table 表名(字段1 数据类型， 字段2 数据类型， 字段3 数据类型); 表名建议以t_或者tbl_开始，可读性强。；见名知义</p></li><li><p>MySQL数据类型 varchar：可变长度的字符串，比较智能，节省空间，会根据实际的数据长度动态分配空间。 char：定长字符串，固定长度空间去存储数据数据。速度快，使用不当可能会造成空间的浪费。 int： longint：长整型 float： double： date：短日期类型 datetime：长日期类型 clob：字符大对象，最多可以存储4G的字符串，超过255个字符的都要采用CLOB大对象来存储。 blob：二进制大对象，专门用来存储图片、声音、视频等流媒体数据。插入数据时，要使用IO流。</p></li><li><p>创建表例子 mysql&gt; create table t_student(no int, name varchar(32), sex char(1), age int(3), email varchar(255));</p></li></ul><p>删除表：drop table if exists t_student;</p><ul><li>插入数据（DML） 语法：insert into 表名（字段1，字段2，字段3） values（值1，值2，值3）; 注意：字段名和值要一一对应<br>eg. mysql&gt; insert into t_student(no,name,sex,age,email) values(1,'zhangsan','m',19,'zhangsan@gmail.com');</li></ul><p>如果没有在创建的时候指定的话，默认值是null。 前面的字段名省略的话，等于都写上了，所以值也都要写上。</p><ul><li>insert插入日期 数字格式化：format 千分位显示：mysql&gt; select ename,format(sal,'$999,999') as sal from emp; 结果： +--------+-------+ | ename | sal | +--------+-------+ | SMITH | 800 | | ALLEN | 1,600 | | WARD | 1,250 | | JONES | 2,975 | | MARTIN | 1,250 | | BLAKE | 2,850 | | CLARK | 2,450 | | SCOTT | 3,000 | | KING | 5,000 | | TURNER | 1,500 | | ADAMS | 1,100 | | JAMES | 950 | | FORD | 3,000 | | MILLER | 1,300 | +--------+-------+</li></ul><ol type="1"><li><p>str_to_date：将字符串varchar类型转化为date类型 格式：str_to_date('字符串日期','日期格式') mysql日期格式： %Y 年，%m 月，%d 日，%h 时，%i 分，%s 秒</p></li><li><p>data_format：将data类型转换为varchar类型 格式：data_format(日期类型数据,'日期格式')</p></li></ol><p>*** 数据库的命名规范：所有的标识符都是全部小写，单词和单词之间用下划线分割。</p><p>mysql&gt; insert into t_user(id,name,birth) values(1,'zhangsan',str_to_date('01-10-1990','%d-%m-%Y'));</p><p>结果： +------+----------+------------+ | id | name | birth | +------+----------+------------+ | 1 | zhangsan | 1990-10-01 | +------+----------+------------+</p><p>str_to_date函数可以把字符串varchar转换成日期，通常使用在insert里面，如果提供的日期字符串时%Y-%m-%d的格式，那么就不需要用该函数也可以达到一样的效果。</p><p>mysql&gt; select id,name,date_format(birth,'%m/%d%Y') as birthday from t_user;</p><p>结果： +------+----------+-----------+ | id | name | birthday | +------+----------+-----------+ | 1 | zhangsan | 10/011990 | | 2 | lisi | 12/251991 | +------+----------+-----------+</p><p>mysql&gt; select * from t_user; +------+----------+------------+ | id | name | birth | +------+----------+------------+ | 1 | zhangsan | 1990-10-01 | | 2 | lisi | 1991-12-25 | +------+----------+------------+ 上述的SQL语句其实是对数据进行了默认的数据类型转换，转换成为了varchar类型，且遵从的格式是：%Y-%d-%m</p><ul><li>date和datetime两个类型的区别 date是短日期：只包括年月日信息。 datetime：包括年月日时分秒信息。</li></ul><p>短日期默认格式：%Y-%m-%d 长日期默认格式：%Y-%m-%d %h:%i:%s</p><p>eg.mysql&gt; insert into t_user1 values(1,'zhangsan','1999-10-1 15:23:10'); 结果： +------+----------+------------+---------------------+ | id | name | birth | create_time | +------+----------+------------+---------------------+ | 1 | zhangsan | 1999-10-01 | 2000-02-04 13:23:10 | +------+----------+------------+---------------------+</p><p>mysql获取当前时间：now()，获取的时间是datetime类型的</p><ul><li>修改（update DML语句） update 表名 set 字段名1=值1，字段名2=值2，字段名3=值3... where 条件</li></ul><p>eg. mysql&gt; update t_user1 set name = 'jack', birth = '2000-10-11' where id = 2;</p><ul><li>删除delete（DML） 语法：delete from 表名 where 条件; 没有条件的话，整张表的数据会全部删除。</li></ul><p>eg. delete from t_user where id=2;</p><ul><li><p>一次插入多条数据 insert into t_user1(id,name,birth,create_time) values(3,'zs','1999-10-8',now()),(4,'zs','1999-10-8',now()),(3,'zs','1999-10-8',now());</p></li><li><p>快速创建一张表 mysql&gt; create table emp2 as select * from t_user1;（完成的是表的快速复制） 查询部分结果保留为一张表： create table mytable as select empno,ename from emp where job = 'MANAGER';</p></li></ul><p>将查询到的结果插入到另一张表中：mysql&gt; insert into dept_bak select * from dept;</p><ul><li>删除大表 delete from dept_bak; delete删除数据的时候，只是删除了数据，而这个数据在硬盘上的存储空间不会被删除，就相当于回收站的功能，缺点是删除效率比较低，优点是，支持回滚，后悔可以恢复。</li></ul><p>另一种删除数据的方法：truncate。删除的效率比较高，表被一次截断，物理删除。这种删除不支持回滚。 用法：truncate table dept_bak；（属于DDL操作）</p><p>删除表的操作：drop table 表名;//这不是删除表中的数据，而是把表删除。</p><ul><li><p>对表结构的增删改 很少进行表结构的修改，因为修改表结构成本较高。不需要写道程序中。</p></li><li><p>约束 约束的作用是为了保证表中的数据有效。 约束的分类：</p><ol type="1"><li>非空约束（not null）</li><li>唯一性约束（unique）</li><li>主键约束（primary key）（简称PK）</li><li>外键约束（foreign key）（简称FK）</li><li>检查约束（check）（MySQL不支持，Oracle支持）</li></ol></li><li><p>非空约束：not null 非空约束not null约束的字段不能为null，创建的时候可以加</p><p>create table t_vip(id int,name varchar(255) not null);</p></li><li><p>唯一性约束</p></li></ul><p>如何创建两个联合起来唯一的？ create table t_vip( id int, name varchar(255), email varchar(255), unique(name,email)//表级约束 ) unique有表级约束而not null 没有</p><ul><li>主键约束 在MySQL中，如果一个字段同时被not null约束的话，该字段自动变为主键字段。（Oracle中不一样） 主键值是每一行记录的唯一标识，主键值是每一行记录的身份证号。</li></ul><p>create table t_vip( id int primary key, name varchar(255) );</p><p>表级约束主要是用来给多个字段联合起来添加约束。 联合起来做主键： mysql&gt; create table t_vip(id int,name varchar(255), email varchar(255), primary key(id,name));</p><p>在实际开发中不建议使用复合主键，复合主键比较复杂。 一张表，主键约束只能添加一个。 主键值建议使用：int，bigint，char等类型，不建议使用：varchar类型。主键值一般都是数字，一般是定长的。</p><p>主键的分类：自然主键和业务主键。 自然主键：主键值是一个自然数，和业务没关系。 业务主键：主键值和业务紧密关联，例如拿银行卡账号作主键值。</p><p>实际开发中使用自然主键的多，因为主键只需要做到不重复即可，不需要有意义。当业务发生变化时，可能会影响到主键值，所以业务主键不建议使用。</p><p>自增给自动维护一个主键值： <em>cr</em>eate table t_vip2(<em> </em>id int primary key auto_increment,<em> </em>name varchar(255)<em> </em>);<em> </em>insert into t_vip2(name) values('zhangsan');<em> </em>insert into t_vip2(name) values('zhangsan');<em> </em>insert into t_vip2(name) values('zhangsan');<em> </em>insert into t_vip2(name) values('zhangsan');<em> </em>insert into t_vip2(name) values('zhangsan');<em> insert into t_vip2(name) values('zhangsan');</em> 创建的表如下： +----+----------+ | id | name | +----+----------+ | 1 | zhangsan | | 2 | zhangsan | | 3 | zhangsan | | 4 | zhangsan | | 5 | zhangsan | | 6 | zhangsan | +----+----------+</p><ul><li><p>外键约束（very important）FK 外键约束就是为了减少数据的冗余度，有一张t_class作为父表（用作约束），t_student是子表（施加约束）。 删除表的顺序：先删除子表，再删除父表 创建表的顺序：先创建父表，再创建子表 删除数据的顺序：先删除子表数据，再删除父表数据 插入数据的顺序：先插入父表，再插入子表</p><p>create table t_class( classno int primary key, classname varchar(255) ); create table t_student( no int primary key auto_increment, name varchar(255), cno int, foreign key(cno) references t_class(classno) );</p></li></ul><h1 id="数据库了解内容">数据库了解内容</h1><ul><li>存储引擎 存储引擎是MySQL中的特有的一个术语，实际上存储引擎是一个表，表存储数据的方式不同。</li></ul><p>怎么给表添加指定的存储引擎？ show create table t_student; 可以在建表的时候，可以在最后的后面使用ENGINE来指定存储引擎，CHARSET表示这张表的字符编码方式。MySQL的默认存储引擎是innodb。 MySQL支持九大存储引擎。</p><ul><li>不同的存储引擎</li></ul><ol type="1"><li>MYISAM存储引擎 使用三个文件表示表： 格式文件：存储表结构的定义(mytable.frm) 数据文件：存储表行的内容(mytable.MYD) 索引文件：存储表上的索引(mytable.MYI)</li></ol><p>可被转换为压缩、只读表来节省空间。对于一张表来说，只要加有主键或者unique类型的，都会被自动加以索引。</p><ol start="2" type="1"><li>InnoDB存储引擎 是MySQL默认存储引擎，同时也是一个重量级的存储引擎。InnoDB支持事务，支持数据库崩溃后自动恢复机制。InnoDB存储引擎最主要的特点是：非常安全。</li></ol><p>管理的表具有以下特征： - 每个InnoDB表在数据库目录中以.frm格式文件表示 - InnoDB表空间tablespace被用于存储表的内容 - 提供一组用来记录事务性活动的日志文件 - 用COMMIT(提交)、SAVEPOINT及ROLLBACK支持事务处理 - 提供全ACID兼容 - 在MySQL服务器崩溃后自动恢复 - 多版本和行级锁定 - 支持外键及引用的完整性，包括级联删除和更新 效率不是很高，也不能压缩，不能转换为只读，不能很好的节省存储空间。</p><ol start="3" type="1"><li>MEMORY存储引擎 使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定。MEMORY存储引擎管理的表具有以下特征：<ul><li>在数据库目录内，每个表都是以.frm格式文件存储。</li><li>表级锁机制</li><li>不能包含TEXT或BLOB字段 优点：查询效率是最高的，不需要和硬盘进行交互 缺点：不安全，关机之后数据消失，因为数据和索引都是在内存中</li></ul></li></ol><h1 id="事务">4. 事务</h1><p>一个事务其实就是一个完整的业务逻辑。只有DML语句（insert、delete、update）才和事务有关系。因为只有以上的三条语句是数据库表中的增删改的，一旦涉及到数据的增删改就必须考虑到安全问题。正是因为做某件事的时候，需要多条DML语句共同联合在一起才能完成，所以需要事务的存在。本质上，一个事务就是多条DML语句同时成功或者同时失败。</p><p>事务是如何做到同时成功或者同时失败的？前文讲到，InnoDB提供了一组用来记录事务性活动的日志文件。在事务的执行过程中，，每一条DML的操作都会记录到日志文件中，在事务的执行过程中，既可以提交事务，也可以回滚事务。</p><ul><li>提交事务：清空事务性活动的日志文件将数据全部彻底持久化到数据库表中，提交事务标志着事务的结束，并且是一种全部成功的标志</li><li>回滚事务：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件。回滚事务标志着事务的结束，并且是一种全部失败的结束。</li></ul><p>在MySQL中，提交事务：commit语句，回滚事务：rollback（回滚永远只是回滚到上一次的提交点）。MySQL默认情况下是支持自动提交事务的，每执行一条DML语句，则提交一次。将MySQL自动提交关闭的方法是：start transaction</p><p>MySQL中的自动提交其实是不符合开发习惯的，为了保证数据的安全，必须要求同时成功之后再提交，不能执行一条就提交一条。</p><h2 id="事务的4个特性">4.1 事务的4个特性</h2><p>A： 原子性</p><p>说明事务时最小的工作单元，不可再分</p><p>C：一致性</p><p>所有的事务要求，在同一个事务当中，所有的操作必须同时成功或者同时失败，以保证数据的一致性。</p><p>I：隔离性</p><p>A事务和B事务之间有一定的距离。</p><p>D：持久性</p><p>事务最终结束的一个保障，就相当于将没有保存在硬盘上的数据保存在硬盘上。</p><h2 id="事务的隔离级别">4.2 事务的隔离级别</h2><ol type="1"><li><p>读未提交：read uncommitted（最低的隔离级别）</p><p>事务A可以读取到事务B未提交的数据，可能出现脏读的现象。这种隔离级别一般都是理论上的，大多数的数据库的隔离级别都是二档起步的。</p></li><li><p>读已提交：read committed</p><p>事务A只能读取到事务B提交之后的数据。解决了脏读的问题，但是引入了新的问题。</p><ul><li>不可重复读取数据：在事务开启之后，第一次读取到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，独到的数据是4条，3!=4称为不可重复读取。</li></ul><p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实，Oracle数据库默认的隔离级别是：read uncommitted</p></li><li><p>可重复度：repeatable read（提交之后也读不到，永远读取的是刚开启事务时的数据）</p><p>事务A开启之后，不管过去多久，每一次在事务A中读取到的数据都是一致的，即使事务B将数据已经修改了，并且提交，事务A读取的数据还是没有发生改变，这就是可重复读。这种解决了不可重复读取的问题。这是MySQL的默认隔离级别。但是引入了新的问题：</p><ul><li>每次读取到的数据都是幻象，不够真实，出现幻影读。</li></ul></li><li><p>序列换/串行化：serializable（最高的隔离级别）</p><p>最高隔离级别，效率最低，解决了所有的问题，表示事务排队，不能并发。每一次读取到的数据都是最真实的，并且效率是最低的。</p></li></ol><h1 id="索引">5. 索引</h1><p>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</p><p>t_user id(idIndex) name(nameIndex) email(emailIndex) address (emailAddressIndex) ---------------------------------------------------------------------------------- ​ 1 zhangsan... ​ 2 lisi ​ 3 wangwu ​ 4 zhaoliu ​ 5 hanmeimei ​ 6 jack</p><pre><code>select * from t_user where name = &#39;jack&#39;;以上的这条SQL语句会去name字段上扫描，为什么？    因为查询条件是：name=&#39;jack&#39;</code></pre><p>如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。（遵循左小右大的原则存放，采用中序遍历的方式来取数据）</p><h2 id="索引的实现原理">5.1 索引的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设有一张用户表：t_user</span><br><span class="line"></span><br><span class="line">id(PK)name每一行记录在硬盘上都有物理存储编号</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">100zhangsan0x1111</span><br><span class="line">120lisi0x2222</span><br><span class="line">99wangwu0x8888</span><br><span class="line">88zhaoliu0x9999</span><br><span class="line">101jack0x6666</span><br><span class="line">55lucy0x5555</span><br><span class="line">130tom0x7777</span><br></pre></td></tr></table></figure><p>提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。</p><p>提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。</p><p>提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p><p>在MySQL中，主键上以及unique字段上都会自动添加索引，给字段添加索引的条件：</p><p>条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同） 条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。 条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</p><p>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</p><h2 id="索引的创建和删除">5.2 索引的创建和删除</h2><p>创建索引：</p><p>mysql&gt; create index emp_ename_index on emp(ename); 给emp表的ename字段添加索引，起名：emp_ename_index</p><p>删除索引：</p><p>mysql&gt; drop index emp_ename_index on emp; 将emp表上的emp_ename_index索引对象删除。</p><p>索引失效的情况：</p><ul><li><p>select * from emp where ename like '%T';</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ename上即使添加了索引，也不会走索引，为什么？</span><br><span class="line">原因是因为模糊匹配当中以“%”开头了！</span><br><span class="line">尽量避免模糊查询的时候以“%”开始。</span><br><span class="line">这是一种优化的手段&#x2F;策略。</span><br></pre></td></tr></table></figure></li><li><p>使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会实现。所以这就是为什么不建议使用or的原因。</p><p>mysql&gt; explain select * from emp where ename = 'KING' or job = 'MANAGER';</p></li><li><p>使用复合索引的时候，没有使用左侧的列查找，索引失效 什么是复合索引？ 两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。</p><pre><code>  create index emp_job_sal_index on emp(job,sal);  mysql&gt; explain select * from emp where job = &#39;MANAGER&#39;;</code></pre></li><li><p>在where当中索引列参加了运算，索引失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index emp_sal_index on emp(sal);</span><br><span class="line">explain select * from emp where sal &#x3D; 800;</span><br></pre></td></tr></table></figure></li><li><p>在where当中索引列使用了函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp where lower(ename) &#x3D; &#39;smith&#39;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="视图">6. 视图</h1><p>视图view:站在不同的角度去看待同一份数据。</p><p>怎么创建视图对象？怎么删除视图对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">表复制：</span><br><span class="line">mysql&gt; create table dept2 as select * from dept;</span><br><span class="line"></span><br><span class="line">dept2表中的数据：</span><br><span class="line">mysql&gt; select * from dept2;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">创建视图对象：</span><br><span class="line">create view dept2_view as select * from dept2;</span><br><span class="line"></span><br><span class="line">删除视图对象：</span><br><span class="line">drop view dept2_view;</span><br><span class="line"></span><br><span class="line">注意：只有DQL语句才能以view的形式创建。</span><br><span class="line">create view view_name as 这里的语句必须是DQL语句;</span><br></pre></td></tr></table></figure><p>用视图做什么？</p><pre><code>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）//面向视图查询select * from dept2_view; // 面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);// 查询原表数据mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     60 | SALES      | BEIJING  |+--------+------------+----------+// 面向视图删除mysql&gt; delete from dept2_view;// 查询原表数据mysql&gt; select * from dept2;Empty set (0.00 sec)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建视图对象</span><br><span class="line">create view </span><br><span class="line">emp_dept_view</span><br><span class="line">as</span><br><span class="line">select </span><br><span class="line">e.ename,e.sal,d.dname</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno &#x3D; d.deptno;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询视图对象</span><br><span class="line">mysql&gt; select * from emp_dept_view;</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| ename  | sal     | dname      |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| CLARK  | 2450.00 | ACCOUNTING |</span><br><span class="line">| KING   | 5000.00 | ACCOUNTING |</span><br><span class="line">| MILLER | 1300.00 | ACCOUNTING |</span><br><span class="line">| SMITH  |  800.00 | RESEARCH   |</span><br><span class="line">| JONES  | 2975.00 | RESEARCH   |</span><br><span class="line">| SCOTT  | 3000.00 | RESEARCH   |</span><br><span class="line">| ADAMS  | 1100.00 | RESEARCH   |</span><br><span class="line">| FORD   | 3000.00 | RESEARCH   |</span><br><span class="line">| ALLEN  | 1600.00 | SALES      |</span><br><span class="line">| WARD   | 1250.00 | SALES      |</span><br><span class="line">| MARTIN | 1250.00 | SALES      |</span><br><span class="line">| BLAKE  | 2850.00 | SALES      |</span><br><span class="line">| TURNER | 1500.00 | SALES      |</span><br><span class="line">| JAMES  |  950.00 | SALES      |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 面向视图更新</span><br><span class="line">update emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原表数据被更新</span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br></pre></td></tr></table></figure><p>视图对象在实际开发中到底有什么用？《方便，简化开发，利于维护》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create view </span><br><span class="line">emp_dept_view</span><br><span class="line">as</span><br><span class="line">select </span><br><span class="line">e.ename,e.sal,d.dname</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno &#x3D; d.deptno;</span><br></pre></td></tr></table></figure><p>​ 假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？可以把这条复杂的SQL语句以视图对象的形式新建。在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的SQL语句。我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><p>再提醒一下： 视图对应的语句只能是DQL语句。 但是视图对象创建完成之后，可以对视图进行增删改查等操作。</p><p>小插曲： 增删改查，又叫做：CRUD。CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。一般都说CRUD。</p><p>C:Create（增） R:Retrive（查：检索） U:Update（改） D:Delete（删）</p><h1 id="数据库设计范式">7. 数据库设计范式</h1><p>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</p><p>第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。</p><p>第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。</p><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h2 id="第一范式">7.1 第一范式</h2><p>最核心，最重要的范式，所有表的设计都需要满足。必须有主键，并且每一个字段都是原子性不可再分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">学生编号 学生姓名 联系方式</span><br><span class="line">------------------------------------------</span><br><span class="line">1001张三zs@gmail.com,1359999999</span><br><span class="line">1002李四ls@gmail.com,13699999999</span><br><span class="line">1001王五ww@163.net,13488888888</span><br><span class="line"></span><br><span class="line">以上是学生表，满足第一范式吗？</span><br><span class="line">不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话</span><br><span class="line"></span><br><span class="line">学生编号(pk) 学生姓名邮箱地址联系电话</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001张三zs@gmail.com1359999999</span><br><span class="line">1002李四ls@gmail.com13699999999</span><br><span class="line">1003王五ww@163.net13488888888</span><br></pre></td></tr></table></figure><h2 id="第二范式">7.2 第二范式</h2><p>建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学生编号 学生姓名    教师编号    教师姓名</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001张三001王老师</span><br><span class="line">1002李四002赵老师</span><br><span class="line">1003王五001王老师</span><br><span class="line">1001张三002赵老师</span><br></pre></td></tr></table></figure><p>这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生） 这是非常典型的：多对多关系！</p><p>分析以上的表是否满足第一范式？不满足第一范式。</p><p>怎么满足第一范式呢？修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学生编号+教师编号(pk)       学生姓名       教师姓名</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001001张三王老师</span><br><span class="line">1002002李四赵老师</span><br><span class="line">1003001王五王老师</span><br><span class="line">1001002张三赵老师</span><br></pre></td></tr></table></figure><p>学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。产生部分依赖有什么缺点？数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。</p><p>为了让以上的表满足第二范式，你需要这样设计：使用三张表来表示多对多的关系！！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学生表</span><br><span class="line">学生编号(pk)学生名字</span><br><span class="line">1001张三</span><br><span class="line">1002李四</span><br><span class="line">1003王五</span><br></pre></td></tr></table></figure><hr><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">教师表</span><br><span class="line">教师编号(pk)教师姓名</span><br><span class="line">--------------------------------------</span><br><span class="line">001王老师</span><br><span class="line">002赵老师</span><br><span class="line"></span><br><span class="line">学生教师关系表</span><br><span class="line">id(pk)学生编号(fk)教师编号(fk)</span><br><span class="line">------------------------------------------------------</span><br><span class="line">11001001</span><br><span class="line">21002002</span><br><span class="line">31003001</span><br><span class="line">41001002</span><br></pre></td></tr></table></figure><h2 id="第三范式">7.3 第三范式</h2><p>第三范式建立在第二范式的基础之上要求所有非主键字典必须直接依赖主键，不要产生传递依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学生编号（PK） 学生姓名 班级编号  班级名称</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">1001张三01一年一班</span><br><span class="line">1002李四02一年二班</span><br><span class="line">1003王五03一年三班</span><br><span class="line">1004赵六03一年三班</span><br></pre></td></tr></table></figure><p>以上表的设计是描述：班级和学生的关系。很显然是1对多关系！ 一个教室中有多个学生。</p><p>分析以上表是否满足第一范式？满足第一范式，有主键。</p><p>分析以上表是否满足第二范式？满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。</p><p>分析以上表是否满足第三范式？第三范式要求：不要产生传递依赖！一年一班依赖01，01依赖1001，产生了传递依赖。不符合第三范式的要求。产生了数据的冗余。</p><p>那么应该怎么设计一对多呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">班级表：一</span><br><span class="line">班级编号(pk)班级名称</span><br><span class="line">----------------------------------------</span><br><span class="line">01一年一班</span><br><span class="line">02一年二班</span><br><span class="line">03一年三班</span><br><span class="line"></span><br><span class="line">学生表：多</span><br><span class="line"></span><br><span class="line">学生编号（PK）       学生姓名     班级编号(fk)</span><br><span class="line">-------------------------------------------</span><br><span class="line">1001张三01</span><br><span class="line">1002李四02</span><br><span class="line">1003王五03</span><br><span class="line">1004赵六03</span><br><span class="line"></span><br><span class="line">背口诀：</span><br><span class="line">一对多，两张表，多的表加外键！！！！！！！！！！！！</span><br></pre></td></tr></table></figure><h2 id="表的设计总结">7.4 表的设计总结</h2><p>一对多：一对多，两张表，多的表加外键！！！！！！！！！！！！</p><p>多对多：多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</p><p>一对一：一对一放到一张表中不就行了吗？为啥还要拆分表？在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。 一对一怎么设计？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">没有拆分表之前：一张表</span><br><span class="line">t_user</span><br><span class="line">idlogin_namelogin_pwdreal_nameemailaddress........</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">1zhangsan123张三zhangsan@xxx</span><br><span class="line">2lisi123李四lisi@xxx</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">这种庞大的表建议拆分为两张：</span><br><span class="line">t_login 登录信息表</span><br><span class="line">id(pk)login_namelogin_pwd</span><br><span class="line">---------------------------------</span><br><span class="line">1zhangsan123</span><br><span class="line">2lisi123</span><br><span class="line"></span><br><span class="line">t_user 用户详细信息表</span><br><span class="line">id(pk)real_nameemailaddress........login_id(fk+unique)</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">100张三zhangsan@xxx1</span><br><span class="line">200李四lisi@xxx2</span><br></pre></td></tr></table></figure><pre><code>            口诀：一对一，外键唯一！！！！！！！！！！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库基本概念&quot;&gt;1.数据库基本概念&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>RNN and LSTM</title>
    <link href="http://yoursite.com/2021/10/18/RNN-and-LSTM/"/>
    <id>http://yoursite.com/2021/10/18/RNN-and-LSTM/</id>
    <published>2021-10-17T19:50:50.000Z</published>
    <updated>2021-10-19T08:53:23.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rnn与lstm">RNN与LSTM</h1><h2 id="rnn模型">RNN模型</h2><a id="more"></a><p>RNN模型的结构图如下所示： <img src="/images/RNN模型.png" alt="avatar"> RNN其实是一个单元的重复使用，经常用在与时间序列相关的场景中。这是一种sequential-tosequential的模型。 由网络图可知，每个单元的状态表示为S_t = f(U<em>X_t + W</em>S_(t-1))，f代表的是激活函数。最后输出的是概率预测，使用的是softmax函数。 <img src="/images/经典的RNN.png" alt="avatar"></p><p>其中U和W都是权重关系，前者称为状态-状态权重，后者称为状态-输入权重. 标准的RNN网络有以下的特点： 1. 权值共享：图中的W全部是相同的，U和V也都一样 2. 每一个输入值都只与它本身的那条路线建立权连接，不会和别的神经元连接。</p><p>RNN的模型表示： <img src="/images/RNN完整图.png" alt="avatar"> x表示输入，h表示隐层单元，o表示输出，L为损失函数，y为训练集标签。右上角的t表示t时刻的状态。隐层单元在t时刻不仅仅由此时刻的输入决定，还受t时刻之前的时刻的影响。U、W、V是权值，权值共享。 对于t时刻： <img src="/images/隐层时刻t.png" alt="avatar"> 其中fai()是激活函数，一般在RNN里面会选择tanh函数，b为偏置。 t时刻的输出为： <img src="/images/t时刻输出.png" alt="avatar"> 最终的预测模型为： <img src="/images/RNN预测.png" alt="avatar"> 其中σ为激活函数，通常用于分类，为softmmax</p><h3 id="rnn的训练">RNN的训练</h3><p>BPTT(back-propagation through time)算法是常用训练RNN的方法，核心思想和BP算法相似。需要寻优的参数有三个，分别是U、V、W。W和V的更新都要追溯到历史数据，参数V相对简单只需要关注目前状态，先更新V： <img src="/images/V参数更新.png" alt="avatar"> RNN的损失也是会随着时间累加的，所以不能只求t时刻的偏导。 <img src="/images/V参数更新所有.png" alt="avatar"> W和U的更新要涉及到历史数据，其偏导求解相对复杂，假设只有三个时刻，那么在第三个时刻L对W的偏导数为： <img src="/images/L对W的偏导.png" alt="avatar"> 相应的，L在第三个时刻对U的偏导为： <img src="/images/L对U的偏导.png" alt="avatar"> 在某个时刻对W或是U的偏导，需要追溯这个时刻之前的所有时刻的信息，那么这个求导的工作将会非常的复杂。但是有规律可循，可以写出L在t时刻对W和U偏导数的通式： <img src="/images/RNN求导简化.png" alt="avatar"> 整体的偏导公式就是将其按时刻再一一加起来。 激活函数是嵌套在求导里面的，如果把激活函数放进去，拿出中间累乘的部分： <img src="/images/梯度消失和梯度爆炸.png" alt="avatar"> 累乘会导致激活函数导数的累乘，进而会导致梯度消失和梯度爆炸的现象发生。</p><p>但是RNN具有以下的局限性： * 当时间间隔不断增大的时候，RNN会丧失学习到连接如此远的信息的能力。理论上RNN可以处理长期依赖的关系，人们可以仔细挑选参数来解决这类问题中的最初形式，但是在实践中，RNN肯定不能成功的学习到这些知识。RNN会受到短时记忆的影响。如果一条序列足够长，那它们将很难从将信息从较早的时间步传送到后面的时间步。 因此如果正在1尝试处理一段文本进行预测，RNN可能从一开始就会遗漏重要的信息，在反向传播期间，RNN可能会面临梯度消失的问题。因为梯度用于更新神经网络的权重值，梯度会随着时间的推移不断下降减少，当梯度变得非常小的时候，就不会再学习。在递归的神经网络中，获得小梯度更新的层会停止学习，通常是较早的层。由于这些层不学习，RNN可以忘记它在较长的序列中看到的内容，因此具有短时记忆。而梯度爆炸则是因为计算的难度越来越复杂导致。</p><h2 id="lstm模型">LSTM模型</h2><p>LSTM(Long short-term memory)长短期记忆网络是RNN的一种变体，通过巧妙的门控制将加法运算带入到网络中，缓解了RNN的问题。LSTM模型图如下所示： <img src="/images/LSTM模型图.png" alt="avatar"> 图形的具体含义如下： <img src="/images/具体含义.png" alt="avatar"> * 黄色的矩形是学习得到的神经网络层 * 粉色的圆形表示一些基本操作，如加法乘法 * 黑色的单箭头表示向量的传输 * 两个箭头合成一个表示向量的连接 * 一个箭头分开表示向量的复制</p><h3 id="lstm的核心思想">LSTM的核心思想</h3><p>LSTM的关键就是细胞状态1，水平线在图上方贯穿运行。细胞状态类似于传送带，直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。 <img src="/images/LSTM流传.png" alt="avatar"> LSTM有通过精心设计的称作“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息有选择的通过的方法，它们包含一个sigmoid神经曾和一个pointwise乘法操作。 <img src="/images/门函数.png" alt="avatar"> sigmoid输出0-1之间的数值，描述每个部分有多少量可以通过，0代表不允许通过，1代表允许1任何通过，LSTM有三个门，来保护和控制细胞状态。 #### 什么信息会被丢弃？ 这个地方要用到第一个门：遗忘门。该门会读取前一个隐藏层的h_t-1和当前输入x_t，输出一个在0-1之间的数值给每个细胞状态C_t-1中的数字。1表示“完全保留”，0表示“完全舍弃”。 <img src="/images/LSTM丢弃层.png" alt="avatar"> 首先，怎么做到遗忘？ “遗忘”可以理解为“之前的内容记住多少”，其精髓在于只能输出(0,1)小数的sigmoid函数和粉色圆圈的乘法，LSTM网络通过学习决定让网络记住以前百分之多少的内容。 其次，为啥要遗忘还要接受新的xt？ 因为决定记住什么遗忘什么，其中新的输入肯定要产生影响。</p><h4 id="什么新的消息会被存放在细胞状态中">什么新的消息会被存放在细胞状态中？</h4><p>这个就叫做“输入门”，包含两个部分：（1）sigmoid层称“输入门层”决定什么值将被更新。（2）tanh层创建一个新的候选值向量，Ct，会被加入到状态中。 <img src="/images/输入门.png" alt="avatar"> 现在将要更新新旧细胞状态，Ct-1更新为Ct。把旧状态与ft相乘，丢弃掉我们确定需要丢弃的信息。接着加上it*Ct，这就是新的候选值，根据我们决定更新每个每个状态的程度进行变化。sigmoid函数选择更新内容，tanh函数创建更新候选。 <img src="/images/输入门.png" alt="avatar"> 最终，需要确定输出什么值，这个输出将会基于细胞状态，但是也是一个过滤后的版本。首先，运行一个sigmoid层来确定细胞状态的哪个部分会被输出出去。接着，把细胞状态通过tanh进行处理(得到一个-1到1之间的值) <img src="/images/输出门.png" alt="avatar"> 这三个门虽然功能上不同，但在执行任务上的操作时相同的，都是使用sigmoid函数作为选择工具，tanh作为变换工具，这两个函数结合起来实现三个门的功能。</p><h4 id="lstm的变体">LSTM的变体</h4><p><img src="/images/LSTM变体1.png" alt="avatar"> 增加了peephole 另一种变体时通过使用coupled忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。仅仅会当将要输入在当前位置时忘记。我们仅仅输入新的值到那些我们已经忘记旧的信息的那些状态。 <img src="/images/LSTM变体2.png" alt="avatar"> 另一个改动较大的变体是 Gated Recurrent Unit (GRU)，这是由 Cho, et al. (2014) 提出。它将忘记门和输入门合成了一个单一的 更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rnn与lstm&quot;&gt;RNN与LSTM&lt;/h1&gt;
&lt;h2 id=&quot;rnn模型&quot;&gt;RNN模型&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Transformer</title>
    <link href="http://yoursite.com/2021/10/11/Transformer/"/>
    <id>http://yoursite.com/2021/10/11/Transformer/</id>
    <published>2021-10-10T16:54:11.000Z</published>
    <updated>2021-10-10T09:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transformer">Transformer</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;transformer&quot;&gt;Transformer&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络</title>
    <link href="http://yoursite.com/2021/10/06/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2021/10/06/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2021-10-05T21:25:16.000Z</published>
    <updated>2021-10-07T16:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的基本概念">1. 图的基本概念</h1><a id="more"></a><ul><li>连通图：对于一个无向图，如果任意的结点i能够通过一些结点边到达结点j，称之为连通图</li><li>非连通图：对于一个无向图，如果任意的结点i不能够通过一些结点边到达结点j，称之为非连通图</li><li>连通分量：无向图G的一个极大连通子图称为G的一个连通分量。连通图只有一个连通分量，即其自身，非连通图有多个连通分量。</li><li>强连通图：给定有向图G(V,E)，并且给定该图G中的任意两个结点u和v，如果结点u和结点v互相可达，那么就称该有向图G是强连通图。</li><li>弱连通图：若至少有一对结点不满足单向连通，但去掉边的方向后从无向图的观点看是连通图，则D称为弱连通图。</li><li>图直径：图中两两结点的最短路径的最大值。</li></ul><h1 id="graph-embedding">2. Graph Embedding</h1><h2 id="deepwalk算法">2.1 deepwalk算法</h2><p>deepwalk的方法是参考了word2vec的思路的，将一个图作为输入，并产生一个潜在的表示(将图中的每个节点表示为一个向量)作为输出。 对于图结构来说，算法设计要满足以下几个要求： 1.适应性：社交网络是不断变化的，当网络发生变化不能对整个网络重新进行计算 2.社区意识：节点的潜在表示对应着维度空间中的距离，应该表示网络中对应的成员的相似度，以保证网络的同质性 3.低维：当被标记的成员很少时，低维的模型一般表现得更好，并且收敛性和推理速度更快 4.连续性：需要通过图的潜在表示对连续空间中的部分社区成员进行建模。除了提供对社区成员资格的细微视图之外，连续表示还可以使社区之间的决策界限平滑，从而实现更强大的分类</p><p>算法的流程： 1.展示用户行为序列 2.基于这些用户行为序列构建了物品相关图，图中的边是由用户行为产生的 3.采用随机游走的方式随机游走的方式随机选择起始点，产生局部物品序列 4.将这些物品序列当做初始句子进行word2vec建模，生成最终的物品embedding向量</p><p>random walk是从截断的随机游走序列中得到的网络局部信息，并以此来学习节点的向量表示。借助语言模型word2vec中的skip-gram模型来学习节点的向量表示。将网络中的结点作为语言模型中的单词，而结点的序列(随机游走得到)模拟为语言中的句子，作为skip-gram的输入。</p><p>优点： 1.并行性：同时进行多个随机游走 2.适应性：当图变化时，不需要全局重新计算，可以迭代的更新学习模型，适合online learning</p><ul><li>deepwalk算法架构 <img src="/images/DeepWalk.png" alt="avatar"></li></ul><p>SkipGram是一个语言模型，用于最大化句子中出现在窗口w内的单词之间的共现概率。使用独立性假设，最后条件概率为： <img src="/images/SkipGram条件概率.png" alt="avatar"></p><p>对序列中的每个顶点，计算条件概率，即该结点出现的情况下序列中其他节点出现的概率的log值，借助随机梯度下降算法更新该结点的向量表示： <img src="/images/SkipGram更新.png" alt="avatar"></p><h2 id="line算法">2.2 line算法</h2><h3 id="line的原理介绍">Line的原理介绍</h3><p>这里与deepwalk不一样的方法是作者考虑了两个方面：一阶相似性和二阶相似性。 (1) 一阶相似性 一阶相似性就是指图中两个结点有边相连接，边的权重衡量的就是两个结点的相似程度，假设我们定义两个结点的联合概率是: <img src="/images/一阶相似性.png" alt="avatar"> 而又知道其对应的经验概率是： <img src="/images/一阶相似性的经验概率.png" alt="avatar"> 利用KL散度的公式并且忽略掉一些常数之后，可以定义一阶相似性的损失函数为： <img src="/images/一阶相似性的损失函数.png" alt="avatar"></p><ol start="2" type="1"><li>二阶相似性 假如两个结点他们的邻居很相似，我们则称这两个结点二阶相似。定义两个接地那的条件概率是：“ <img src="/images/二阶相似性.png" alt="avatar"> 要对比两个结点的二阶相似性，其实对比的就是两个结点的条件概率分布的相似性。只要能够保证所有结点的条件概率和经验条件概率一致，那么这个embedding就可以很好地保存这两个结点的二阶相似性。 <img src="/images/对比二阶相似性.png" alt="avatar"> 得到二阶的损失函数为： <img src="/images/二阶相似性的损失函数.png" alt="avatar"> 在现实中，一般采用负彩样的方法进行训练，即： <img src="/images/负采样.png" alt="avatar"></li></ol><p>(3)结合一阶相似性和二阶相似性 将一阶相似性训练得到的embedding和二阶相似性训练得到的embedding拼接起来，就是最终的embedding形式。 ### 模型优化 (1) 我们会可以看到不管是一阶还是二阶的时候，损失函数每条边都有个weight，为了加速模型收敛，训练的时候可以对边采取抽样的方式生成训练样本，每条边被抽中的概率为边的权重。 (2) 对于邻居很少的结点，我们可以将结点邻居的邻居作为该结点的邻居，对应的权重为： <img src="/images/邻居很少的结点.png" alt="avatar"> 然后将结点的权重进行排序，取出topN。</p><h2 id="node2vec算法">2.3 node2vec算法</h2><p>要设计的网络表示学习算法的目标必须满足以下两点： 1.同一个社区内的结点表示类似 2.拥有类似结构特征的结点表示相似</p><h3 id="算法流程">算法流程</h3><p>该方法的损失函数是： <img src="/images/node2vec的损失函数.png" alt="avatar"> 为了让结果更容易计算，引入了skip-gram中的两个假设： 1. 条件独立，即采样每个邻居是相互独立的，所以如果要计算采样所有邻居的概率只需要将采样每个邻居的概率相乘就好了，公式化表达就是： <img src="/images/采样所有邻居的概率.png" alt="avatar"> 2. 特征空间的对称性。假设一条边连接了a和b，那么映射到特征空间时，a对b的影响和b对a的影响是一样的。用一个模型来表示一个(结点，邻居)对： <img src="/images/结点邻居对.png" alt="avatar"> 将上面的三个公式结合起来得到最终的优化结果： <img src="/images/node2vec优化结果.png" alt="avatar"> 注意： 1.Zu直接计算特别费时，本文使用的是负采样的方式 2.Ns(u)未必是u的直接邻居，只是用s方法采样得到的邻居，跟具体的采样方法有关</p><p>复杂网络处理的任务其实离不开两种特性，一种是同质性也就是社区，另一种是结构相似性。结构相似的两个点未必相连，可以是相距很远的两个结点。深度优先游走(DFS)和广度优先游走(BFS)是两种随机游走的方式。BFS倾向于在结点的初始结点的周围游走，可以反映出一个结点的邻居的微观特性；而DFS一般会跑的离初始结点越来越远，可以反映出一个结点邻居的宏观特性。 node2vec的随机游走产生的方式是： <img src="/images/node2vec随机游走.png" alt="avatar"> 对于一个随机游走，如果已经采样了(t,v)，也就是说现在停留在结点v上，那么下一个要采样的结点是哪个？作者定义了一个概率分布，也就是一个结点到它不同邻居结点的转移概率： <img src="/images/node2vec随机游走转移概率.png" alt="avatar"></p><ul><li>如果t和x相等，那么采样x的概率系数是1/p</li><li>如果t和x相连，那么采样x的概率系数是1</li><li>如果t和x不相连，那么采样x的概率系数是1/q</li></ul><p>参数p、q的意义分别如下： 返回概率p： * 如果p &gt; max(q,1)，那么采样会尽量不往回走，对应上图的情况，就是下一个节点不太可能是上一个访问的结点t * 如果p &lt; min(q,1)，那么采样会更倾向于返回上一个结点，这样会一直在起始点周围某些结点来回转来转去。 出入参数： * 如果q &gt; 1，那么游走会倾向于在起始点周围的结点之间跑，可以反映一个结点的BFS特征。 * 如果q &lt; 1，那么游走会倾向于往远处跑，反映出DFS特性。 当 p = 1 , q = 1 时，游走方式就等同于DeepWalk中的随机游走。 q是用来控制模型是DFS还是BFS</p><h3 id="node2vec算法流程">node2vec算法流程</h3><figure><img src="/images/node2vec算法.png" alt="avatar"><figcaption aria-hidden="true">avatar</figcaption></figure><ol type="1"><li>根据p、q和之前的公式计算一个结点到它邻居的转移概率</li><li>将这个转移概率加到图G中形成G'</li><li>walks用来存储随机游走，先初始化为空</li><li>外循环r次表示每个节点作为初始结点要生成r个随机游走</li><li>然后对图中每个节点</li><li>生成一条随机游走walk</li><li>将walk添加到walks中保存</li><li>然后使用SGD方法对walks进行训练</li></ol><p>第6步中一条walk的生成方式如下：</p><ol type="1"><li>将初始节点u添加进去</li><li>walk的长度与为l，因此还要再循环添加l-1个结点</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图的基本概念&quot;&gt;1. 图的基本概念&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CNN网络</title>
    <link href="http://yoursite.com/2021/10/01/CNN%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2021/10/01/CNN%E7%BD%91%E7%BB%9C/</id>
    <published>2021-09-30T19:21:38.000Z</published>
    <updated>2021-09-30T12:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li>CNN网络的卷积与数学的卷积是不一样的，CNN的卷积是相关运算</li><li>CNN不用数学的卷积是因为翻转需要增加计算量，而翻转与不翻转并不会改变信息量</li><li>CNN网络中输出矩阵的尺寸是：(N - Kernel_size)/stride + 1</li><li>输入N个通道，输出M个通道，滤波器的数量为M*N</li><li>池化的两个参数：kernel_size和stride</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;CNN网络的卷积与数学的卷积是不一样的，CNN的卷积是相关运算&lt;/li&gt;
&lt;li&gt;CNN不用数学的卷积是因为翻转需要增加计算量，而翻转与不翻转并不会改变信息量&lt;/li&gt;
&lt;li&gt;CNN网络中输出矩阵的尺寸是：(N - Kernel_siz
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tranformer</title>
    <link href="http://yoursite.com/2021/09/30/tranformer/"/>
    <id>http://yoursite.com/2021/09/30/tranformer/</id>
    <published>2021-09-30T08:41:51.000Z</published>
    <updated>2021-09-30T00:41:52.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>有意思的算法题</title>
    <link href="http://yoursite.com/2021/09/09/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/09/09/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2021-09-09T10:47:12.000Z</published>
    <updated>2021-12-06T03:07:06.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-318.最大单词长度乘积">LeetCode 318.最大单词长度乘积</h1><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><h2 id="算法描述">算法描述</h2><p>这里直接用哈希表，分词的话那么会很麻烦，所以这里使用的是移位的思想。首先用一个数组来存储每一个对应的字符串到底出现了哪个单词（这里并不需要记录出现的次数，因为只要找出两个没有公共字母的单词）。这里如何记录是否出现呢？可以用一个26位的二进制数，1表示对应位置的字母出现了。那么如何记录呢？那就是以下的代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">    hash[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随后就可以遍历两两组合，相与为零的二进制数就是不重复的单词。</p><h2 id="完整代码">完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> maxProduct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/01/31/20:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 最大单词长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String[] words = &#123;<span class="string">"abcw"</span>,<span class="string">"baz"</span>,<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"xtfn"</span>,<span class="string">"abcdef"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = solution.maxProduct(words);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 全是小写字母，可以用一个32为整数表示word中出现的字母，</span></span><br><span class="line"><span class="comment">         * hash[i]存放第i个单词出现过的字母，a对应32位整数的最后一位</span></span><br><span class="line"><span class="comment">         * b对应整数的倒数第二位，以此类推</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用移位1来记录出现了哪一位字符，一共最多32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                hash[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hash[i] &amp; hash[j]) == <span class="number">0</span>)</span><br><span class="line">                    max = Math.max(words[i].length()*words[j].length(),max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode-43.字符串相乘">LeetCode 43.字符串相乘</h1><h2 id="题目描述-1">题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><h2 id="算法描述-1">算法描述</h2><ul><li>如果num1和num2之一是0，则直接将0作为结果返回即可</li><li>如果num1和num2都不是0，则可以通过模拟竖式乘法的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。 <img src="/images/字符串相乘.png" alt="avatar"></li></ul><h2 id="完整代码-1">完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiply;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/05/09/9:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String s = solution.multiply(<span class="string">"222"</span>, <span class="string">"53"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            StringBuffer curr = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                curr.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = x * y + add;</span><br><span class="line">                curr.append(product % <span class="number">10</span>);</span><br><span class="line">                add = product / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">                curr.append(add % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = addStrings(ans, curr.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode-no166.分数到小数">LeetCode No166.分数到小数</h1><h2 id="题目描述-2">题目描述</h2><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 任意一个 。</p><h2 id="算法描述-2">算法描述</h2><p>这里要用到的一个容器就是哈希表，当然哈希表键值对是用来存储除数得到的余数的10倍是否出现过，用的就是长除法的思想。每一次除不下的时候我们要考虑的是补零，若补零之后出现的整数之前出现过在哈希表中，那么可以肯定的是从这一位开始就要产生一个循环。那么这样就可以得到一个循环的结束条件。</p><h2 id="完整代码-2">完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">long</span> a = numerator,b = denominator;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> || a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)</span><br><span class="line">            sb.append(<span class="string">'-'</span>);</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        sb.append(a/b);</span><br><span class="line">        <span class="keyword">if</span> (a % b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        sb.append(<span class="string">'.'</span>);</span><br><span class="line">        HashMap&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((a = (a % b) * <span class="number">10</span>) &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(a))&#123;</span><br><span class="line">            map.put(a,sb.length());</span><br><span class="line">            sb.append(a / b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        <span class="keyword">return</span> sb.insert(map.get(a).intValue(),<span class="string">'('</span>).append(<span class="string">')'</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode-no29.不使用除法运算符计算除法">LeetCode No29.不使用除法运算符计算除法</h1><h2 id="题目描述-3">题目描述</h2><p>不使用除法运算符，进行除法的计算，返回的结果是除数取整的结果</p><h2 id="算法描述-3">算法描述</h2><ul><li>不使用除法运算符，得到整数除法的求余结果</li><li>考虑的是移位法，可以先把一个被除数除以2^n，n的初始值为31</li><li>不断减少n去试探，当某个n满足被除数/2^n&gt;=divisor时</li><li>表示找到了一个足够大的数，这个数*除数是不大于被除数的，所以可以减去2^n个除数</li></ul><h2 id="完整代码-3">完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> divide;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/10/12/8:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> divide = solution.divide(-<span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(divide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不使用除法运算符，得到整数除法的求余结果</span></span><br><span class="line"><span class="comment">         * 考虑的是移位法，可以先把一个被除数除以2^n，n的初始值为31</span></span><br><span class="line"><span class="comment">         * 不断减少n去试探，当某个n满足被除数/2^n&gt;=divisor时</span></span><br><span class="line"><span class="comment">         * 表示找到了一个足够大的数，这个数*除数是不大于被除数的，所以可以减去2^n个除数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> negative;</span><br><span class="line">        negative = (dividend ^ divisor) &lt; <span class="number">0</span>;<span class="comment">//用相与来计算是否符号相异</span></span><br><span class="line">        <span class="keyword">long</span> t = Math.abs((<span class="keyword">long</span>) dividend);</span><br><span class="line">        <span class="keyword">long</span> d = Math.abs((<span class="keyword">long</span>) divisor);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;&gt; i) &gt;= d)&#123;</span><br><span class="line">                <span class="comment">//找出足够大的2^n*divisor</span></span><br><span class="line">                result += <span class="number">1</span> &lt;&lt; i;<span class="comment">//将结果加上2^n</span></span><br><span class="line">                t -= d &lt;&lt; i;<span class="comment">//将被除数减去2^n*divisor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? - result : result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-318.最大单词长度乘积&quot;&gt;LeetCode 318.最大单词长度乘积&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>tensor知识</title>
    <link href="http://yoursite.com/2021/09/07/tensor%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2021/09/07/tensor%E7%9F%A5%E8%AF%86/</id>
    <published>2021-09-07T11:45:29.000Z</published>
    <updated>2021-09-07T03:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="tensor简介">Tensor简介</h1><ol type="1"><li>什么是tensor</li></ol><p>scalar(标量)：一个数值 vector(向量)：一维数组 matrix(矩阵)：二维数组 tensor(张量)：多维数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;tensor简介&quot;&gt;Tensor简介&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;什么是tensor&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;scalar(标量)：一个数值 vector(向量)：一维数组 matrix(矩阵)：
      
    
    </summary>
    
    
    
      <category term="pytorch学习" scheme="http://yoursite.com/tags/pytorch%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常用的十种算法</title>
    <link href="http://yoursite.com/2021/08/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%81%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/08/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%81%E7%A7%8D%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-12T09:48:46.000Z</published>
    <updated>2021-12-06T03:08:16.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的十种算法">常用的十种算法</h1><a id="more"></a><h1 id="二分查找算法">1.二分查找算法</h1><p>二分查找有两种思想：一种是递归的思想，另一种是非递归的思想。</p><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法一：使用递归的方式</span></span><br><span class="line">        <span class="comment">//递归的方式就是首先找到中间位置，如果大于，那么往前找，否则往后找</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch(arr,mid + <span class="number">1</span>,end,target);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch(arr,start,mid - <span class="number">1</span>,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>非递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; arr[mid])&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="分治算法">2.分治算法</h2><p>分治算法的思想是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或者相似的子问题，再把子问题分成更小的子问题...直到最后子问题可以简单地直接求解，原问题的解即为子问题的解的合并。</p><ul><li>分治算法的基本步骤 1.分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 2.解决：将子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 3.将各个子问题的解合并为原问题的解</li></ul><p>eg. 汉诺塔问题 1) 如果是有一个盘，A-&gt;C 如果我们有n&gt;=2的情况，我们总是可以看做是两个盘：1.最下边的盘 2.上面的盘</p><p>1.先把最上面的盘A-&gt;B 2.把最下边的盘A-&gt;C 3.把B塔所有的盘从B-&gt;C</p><p>代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DividedandConquer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/08/12/10:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 分治算法解决汉诺塔问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoTower(<span class="number">5</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//汉诺塔的移动方案</span></span><br><span class="line">    <span class="comment">//使用分治算法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoTower</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span>+a+<span class="string">"-&gt;"</span>+c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有n&gt;=2的情况，我们总是可以看做是两个盘，一个是最下边的盘，加上上面所有的盘</span></span><br><span class="line">            <span class="comment">//1.先把最上面所有的盘A-&gt;B,移动过程用到c</span></span><br><span class="line">            hanoTower(num - <span class="number">1</span>,a,c,b);</span><br><span class="line">            <span class="comment">//2.把最下边的盘A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span>+num+<span class="string">"个盘从"</span>+a+<span class="string">"-&gt;"</span>+c);</span><br><span class="line">            <span class="comment">//把B塔的所有盘B-&gt;C，移动过程中使用到A盘</span></span><br><span class="line">            hanoTower(num - <span class="number">1</span>,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态规划算法">3.动态规划算法</h2><ul><li><p>简要介绍 1.动态规划算法的核心是：将大问题划分为小问题进行解决，进而一步步获取最优解的处理算法 2.动态规划算法与分治算法类似，其基本思想也是将待求解问题分解为若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 3.与分治算法不同的是，适用于用动态规划求解的问题，经分解得到子问题往往不是相互独立的，即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解。 4.动态规划可以通过填表的方式来逐步求解最优解。</p></li><li><p>动态规划解决背包问题 算法主要思想：每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果： (1)v[i][0] = v[0][j] = 0//表示填入表第一行和第一列是0 (2)当w[i] &gt; j时：v[i][j] = v[i - 1][j]//当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略 (3)当j&gt;=w[i]时：v[i][j] = max{v[i - 1][j],v[i - 1][j - w[i]] + v[i]}</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用的十种算法&quot;&gt;常用的十种算法&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性判别分析LDA</title>
    <link href="http://yoursite.com/2021/08/04/%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90LDA/"/>
    <id>http://yoursite.com/2021/08/04/%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90LDA/</id>
    <published>2021-08-03T16:20:41.000Z</published>
    <updated>2021-08-03T08:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lda思想">LDA思想</h1><p>LDA的思想是将数据在低纬度上进行投影，投影后希望每一种数据的投影点尽可能接近，而不同类别的数据中心之间的距离尽可能的大。</p><h1 id="瑞利商rayleigh-quotient与广义瑞利商generalized-rayleigh-quotient">瑞利商(Rayleigh quotient)与广义瑞利商(generalized Rayleigh quotient)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lda思想&quot;&gt;LDA思想&lt;/h1&gt;
&lt;p&gt;LDA的思想是将数据在低纬度上进行投影，投影后希望每一种数据的投影点尽可能接近，而不同类别的数据中心之间的距离尽可能的大。&lt;/p&gt;
&lt;h1 id=&quot;瑞利商rayleigh-quotient与广义瑞利商generaliz
      
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2021/07/20/%E5%9B%BE/"/>
    <id>http://yoursite.com/2021/07/20/%E5%9B%BE/</id>
    <published>2021-07-20T15:39:42.000Z</published>
    <updated>2021-12-06T03:09:24.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的基本介绍">图的基本介绍</h1><a id="more"></a><p>图是一种数据结构，其中结点可以具有零个或者多个相邻元素。两个结点之间的连接称为边，结点也可以称为顶点。线性表局限于直接前驱和一个直接后继的关系，树叶只能有一个直接前驱也就是父节点，当我们需要表示多对多的关系时，就需要图这一数据结构。</p><ul><li><p>图的表示方式：二维数组表示(邻接矩阵)；链表表示(邻接表)。</p></li><li><ol type="1"><li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间的一定损失。</li></ol></li><li><ol start="2" type="1"><li>邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成。</li></ol></li></ul><h1 id="图的遍历">图的遍历</h1><p>图的遍历就是对结点的访问，一个图有很多结点，需要特定的策略来遍历结点，一般有两种方法：(1)深度优先遍历 (2)广度优先遍历</p><h2 id="深度优先遍历思想">(1) 深度优先遍历思想：</h2><ol type="1"><li>深度优先遍历，从初始访问结点开始，初始访问结点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始结点，访问它的第一个邻接节点，可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一个邻接节点。</li><li>我们可以看到，这样的访问策略是有限往纵向挖掘深入，而不是对一个结点的所有邻接节点进行横向访问。</li><li>显然，深度优先搜索是一个递归过程。</li></ol><ul><li>深度优先遍历算法步骤</li></ul><ol type="1"><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接节点w。</li><li>若w存在，则继续执行4，若w不存在，则回到第一步，将从v的下一个节点继续。</li><li>若w未被访问，对w进行深度优先遍历递归(即把w当做另一个v，然后进行步骤123)。</li><li>查找结点v的w邻接节点的下一个邻接节点，转到步骤3.</li></ol><h2 id="广度优先遍历">(2) 广度优先遍历</h2><p>图的广度优先搜索类似于一个分层搜索过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接节点。</p><ul><li>广度优先遍历算法步骤</li></ul><ol type="1"><li>访问初始结点v并标记结点v为已访问</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束</li><li>出队列，取得队头结点u</li><li>查找结点u的第一个邻接节点w</li><li>若结点u的邻接节点w不存在，则转到步骤3，否则循环执行以下三个步骤： 6.1 若结点w尚未被访问，则访问结点w并标记为已访问 6.2 结点w入队列 6.3 查找结点u的继w邻接节点的下一个邻接节点w，转到步骤6</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图的基本介绍&quot;&gt;图的基本介绍&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>多叉树</title>
    <link href="http://yoursite.com/2021/07/07/%E5%A4%9A%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2021/07/07/%E5%A4%9A%E5%8F%89%E6%A0%91/</id>
    <published>2021-07-07T10:06:14.000Z</published>
    <updated>2021-12-06T03:09:38.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树存在的问题">二叉树存在的问题</h1><a id="more"></a><ul><li>二叉树需需要加载到内存，如果二叉树的结点很多就会出现如下问题：</li></ul><ol type="1"><li>在构建二叉树时，需要多次进行I/O操作，结点海量，构建二叉树时，速度有影响</li><li>结点海量，也会造成二叉树的高度很大，会降低操作速度</li></ol><ul><li>多叉树</li></ul><ol type="1"><li>在二叉树中，每个节点有数据项，最多有两个结点。如果允许每个接地那可以有更多的数据项和更多的结点，那就是多叉树。</li><li>多叉树通过重新组织结点，减少树的高度，能对二叉树进行优化。</li><li>B树通过重新组织结点，降低了树的高度</li><li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页(页的大小通常是4K)，这样每个节点只需要一次I/O就可以完全载入</li><li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树广泛用于文件存储系统以及数据库系统中。</li></ol><h1 id="树">2-3树</h1><p>2-3树是最简单的B树结构，具有如下特点： (1) 2-3树的所有结点都在同一层(只要是B树都满足这个条件) (2) 有两个子结点的结点叫做二节点，二节点要么没有子结点要么有两个子结点 (3) 有三个子结点的结点叫做三节点，三节点要么没有子结点要么有三个子结点 (4) 2-3树是由二节点和三节点构成的树</p><ul><li>2-3树的插入规则</li></ul><ol type="1"><li>2-3树的所有叶子结点都在同一层(只要是B树均满足这个条件)</li><li>有两个子结点的结点叫做二节点，二节点要么没有子结点要么有两个子结点</li><li>有三个子结点的结点叫做三节点，三节点要么没有子结点要么有三个子结点</li><li>当按照规则插入一个树到某个节点时，不能满足上述三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后需要满足上面三个条件。</li><li>对于上三节点的子树的值的大小仍遵守二叉排序树的规则。</li></ol><ul><li>B树的说明：</li></ul><ol type="1"><li>B树的阶：结点的最多子结点个数。如2-3树的阶是3</li><li>B-树的搜索，从根结点开始，对结点内的关键字进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整棵树中，即叶子结点和非叶子结点都存放数据</li><li>搜索有可能在非叶子结点结束</li><li>其搜索心梗等价于在关键字全集内做一次二分查找</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉树存在的问题&quot;&gt;二叉树存在的问题&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2021/07/02/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2021/07/02/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-07-01T16:22:09.000Z</published>
    <updated>2021-12-06T03:09:50.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树">平衡二叉树</h1><a id="more"></a><ul><li>平衡二叉树也叫平衡二叉搜索树，AVL树，可以保证查询效率较高。</li><li>主要特点是：是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两颗子树都是一个平衡二叉树。</li></ul><h2 id="创建一颗平衡二叉树的方法">创建一颗平衡二叉树的方法</h2><p>怎么处理？--&gt;进行左旋转(降低右子树的高度) * 创建一个新的结点newNode，值等于当前根结点的值 * 把新节点的左子树设置为当前节点的左子树。newNode.left = left * 把新节点的右子树设置为当前节点的右子树的左子树。newNode,right = right.left * 把当前节点的值换为右子结点的值。value = right.value * 把当前节点的右子树设置为右子树的右子树。right = right.right * 把当前节点的左子树设置为新节点。left = newLeft。</p><p>进行右旋转(降低左子树的高度) * 创建一个新的结点，其值等于当前节点的值newNode * 把新节点的右子树设置为当前节点的右子树(newNode.right = right) * 把新节点的左子树设置为当前节点的左子树的右子树(newNode.left = left.right) * 把当前节点的值换为左子节点的值(value = left.value) * 把当前节点的左子树设置为左子树的左子树(left = left.left) * 把当前节点的右子树设置为新节点(right = newLeft)</p><h1 id="avl树双旋转">AVL树双旋转</h1><ul><li>当符号右旋转的条件时</li><li>如果它的左子树的右子树高度大于它的左子树的高度</li><li>先对当前这个节点的左结点进行左旋转</li><li>再对当前节点进行右旋转的操作即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/07/01/18:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="comment">//添加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"未旋转之前的高度："</span>);</span><br><span class="line">        System.out.println(avlTree.getRoot().height());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建AVL树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当做二叉排序树的根结点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的以node为根结点的二叉排序树的最小节点的值</span></span><br><span class="line"><span class="comment">     * 还要删除这个返回的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环查找左结点就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时target就只向了最小节点\\44\\</span></span><br><span class="line">        <span class="comment">//删除最小节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先去找到要删除的结点targetnode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发现这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetnode的父节点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//叶子结点</span></span><br><span class="line">                <span class="comment">//判断targetnode是父节点的左子节点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value)&#123;</span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value)&#123;</span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//删除的结点是两颗树的结点</span></span><br><span class="line">                <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minVal;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//删除的结点是有一棵子树的结点,排除的是其他的情况</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果targetnode是parent的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value == value)&#123;</span><br><span class="line">                        parent.left = targetNode.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//targetnode是parent的右子结点</span></span><br><span class="line">                        parent.right = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//要删除的结点有右子结点</span></span><br><span class="line">                    <span class="comment">//如果targetnode是parent的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value == value)&#123;</span><br><span class="line">                        parent.left = targetNode.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//如果targetnode是parent的右子结点</span></span><br><span class="line">                        parent.right = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，则直接让root指向node</span></span><br><span class="line">            root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"此二叉树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前节点的高度，以该结点为根结点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(),right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前节点的左子树</span></span><br><span class="line">        newNode.left = left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        <span class="comment">//把当前节点的值替换为右子结点的值</span></span><br><span class="line">        value = right.value;</span><br><span class="line">        <span class="comment">//把当前节点的右子树设置为当前节点的右子树的右子树</span></span><br><span class="line">        right = right.right;</span><br><span class="line">        <span class="comment">//把当前节点的左子节点(左子树)设置为新的结点</span></span><br><span class="line">        left = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        value = left.value;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//找到节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//这时候应该向左子树查找</span></span><br><span class="line">            <span class="comment">//如果左子节点为空则停止查找，而且停止查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不小于。则向右查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value)||(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//找到了父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果查找的值小于当前节点的值,并且当前节点左子节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找不到了,没有父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"value="</span> + value +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点值和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//当前节点的左子节点为空</span></span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子结点添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果右子树的高度-左子树的高度&gt;1，施加一个左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; right .rightHeight() &lt; right.leftHeight())&#123;</span><br><span class="line">                <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight())&#123;</span><br><span class="line">                    <span class="comment">//先对右子结点进行右旋转，再对当前节点进行左旋转</span></span><br><span class="line">                    right.rightRotate();</span><br><span class="line">                    left.leftRotate();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    leftRotate();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当添加完一个结点后如果出现左子树的高度-右子树的高度&gt;1，右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; leftHeight())&#123;</span><br><span class="line">                <span class="comment">//先对当前节点的左结点进行左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前节点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;平衡二叉树&quot;&gt;平衡二叉树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://yoursite.com/2021/06/26/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2021/06/26/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</id>
    <published>2021-06-25T20:29:18.000Z</published>
    <updated>2021-12-06T03:10:04.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树">二叉排序树</h1><a id="more"></a><p>二叉排序树：BST(Binary Sort Tree)，对于二叉排序树的任何一个非叶子结点，要求左子节点的值比当前节点的值小，右子结点的值比当前节点的大。如果有相同的值，可以将该结点放在左子节点或者右子结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BinarySortTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/25/20:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="comment">//for循环添加节点到排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历二叉树</span></span><br><span class="line">        System.out.println(<span class="string">"中序遍历二插排序树"</span> );</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，则直接让root指向node</span></span><br><span class="line">            root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"此二叉树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"value="</span> + value +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点值和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//当前节点的左子节点为空</span></span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子结点添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉排序树的删除">二叉排序树的删除</h1><ul><li>情况一：当要删除的结点没有子结点的时候： (1)需要先去找到要删除的结点targetNode (2)找到targetNode的父节点parent (3)确定targetNode是parent的左子节点还是右子结点 (4)根据前面的情况对应的删除，左子节点:parent.left = null;右子结点:parent.right = null;</li><li>情况二：删除只有一颗子树的结点 (1)首先找到要删除的结点targetNode (2)找到target的父节点parent (3)确定targetNode的子结点是右子结点还是左子节点 (4)targetNode是parent的左子节点还是右子结点 (5)如果targetNode是parent的左子节点 5.1 targetNode的子结点是左子节点，parent.left=targetNode.left 5.2 targetNode的子结点是右子节点，parent.left=targetNode.right 如果targetNode是parent的右子结点 5.3 targetNode的子结点是左子节点，parent.left=targetNode.right 5.4 targetNode的子结点是右子节点，parent.right=targetNode.right</li><li>情况三：删除有两颗子树的结点 (1)首先找到要删除的结点targetNode (2)找到target的父节点parent (3)从targetNode的右子树找到最小的结点 (4)用一个临时变量，将最小的值保存到temp (5)删除最小节点 (6)targetNode.value = temp</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉排序树&quot;&gt;二叉排序树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>霍夫曼树</title>
    <link href="http://yoursite.com/2021/06/16/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2021/06/16/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/</id>
    <published>2021-06-16T00:50:48.000Z</published>
    <updated>2021-12-06T03:10:20.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="霍夫曼树">霍夫曼树</h1><a id="more"></a><p>给定n个权值1作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h1 id="构成哈夫曼树的思路">构成哈夫曼树的思路</h1><ul><li>从小到大进行排序，将每一个数据，每个数据都是一个结点，每个结点可以看成是一颗最简单的二叉树</li><li>取出根结点权值最小的两颗二叉树</li><li>组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两个二叉树根结点权值的和</li><li>再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中所有数据都被处理，就得到一颗哈夫曼树。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;霍夫曼树&quot;&gt;霍夫曼树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2021/06/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/06/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-06-10T09:02:55.000Z</published>
    <updated>2021-12-10T05:29:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><a id="more"></a><h2 id="博奕">1. 博奕</h2><h3 id="take-away-games">1.1 Take-Away Games</h3><p>组合游戏是指一种两个玩家的游戏，每个玩家有相同的信息，不存在随即动作，游戏的结果总是输或者赢。游戏的每个步骤由一个移动构成，通常玩家会交替的进行移动，直到达到终止条件。终止条件是指从该状态不存在任何一个状态移动方式的状态。</p><p>这种问题的模板为下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Boolean[] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>];<span class="comment">//设置memo</span></span><br><span class="line">    <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,Boolean[] memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//index边界结束</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[n];<span class="comment">//memo已有结束</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">false</span>;<span class="comment">//initial res</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">4</span>:i ++)&#123;<span class="comment">//核心递推公式</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= i) res |= !dfs(n - i,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[n] = res;<span class="comment">//返回结果并保存到memo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题">例题</h4><p><strong><em>LeetCode 292 Nim游戏：</em></strong></p><p><strong><em>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头。你们轮流进行自己的回合，你作为先手。每一回合，轮到的人拿掉 1 - 3 块石头。拿掉最后一块石头的人就是获胜者</em></strong>*</p><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这里保证我能赢的抓取原则是：</span></span><br><span class="line"><span class="comment">dp[i-1],dp[i-2],dp[i-3]都失败了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Boolean[] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,Boolean[] memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= i) res |= !dfs(n - i,memo);<span class="comment">//只有当res与!dfs都是false的时候才是false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[Math.max(n + <span class="number">1</span>,<span class="number">4</span>)];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i ++)</span><br><span class="line">        dp[i] = !dp[i - <span class="number">1</span>] || !dp[i - <span class="number">2</span>] || !dp[i -<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">终极方案</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划&quot;&gt;动态规划&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>顺序二叉树</title>
    <link href="http://yoursite.com/2021/06/07/%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2021/06/07/%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-06-06T18:52:37.000Z</published>
    <updated>2021-12-06T03:10:38.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序存储二叉树">顺序存储二叉树</h1><a id="more"></a><ul><li>通常只考虑完全二叉树</li><li>第n个元素的左子节点为2*n + 1</li><li>第n个元素的右子结点为2*n + 2</li><li>第n个元素的父节点为(n-1)/2</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;顺序存储二叉树&quot;&gt;顺序存储二叉树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
