<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris的个人博客</title>
  
  <subtitle>我的代码要为成艺术品</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-07T13:32:53.096Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Word2Vec总结</title>
    <link href="http://yoursite.com/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-07T12:22:41.000Z</published>
    <updated>2021-12-07T13:32:53.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Word2Vec算法简介"><a href="#1-Word2Vec算法简介" class="headerlink" title="1. Word2Vec算法简介"></a>1. Word2Vec算法简介</h1><a id="more"></a><p>为什么要进行word embedding？因为对于机器学习的输入来说，只接受数值型的输入，而对于NLP之中的语句，则是人类的特定的字符。所以必须要对其转换为数值类型，降维到一个数学空间中。最原始的方法就是one-hot embedding，但是这种算法复杂度太高，而且可扩展性不强。并且假设所有的词都是独立的，而现实中词与词之间不可能是独立的。</p><p>在NLP中，把x看作是一个句子中的词语，y是词语的上下文，f(x) -&gt; y就是语言模型，用来判断(x,y)是不是符合自然语言的法则。Word2vec就是这个思想，最终并不是要把f训练的多么完美，而是只关心模型参数(神经网络的权重)，并将这些参数，作为输入x的魔种向量化表示，也就是词向量。</p><p>按照下图的观念，我们有：</p><script type="math/tex; mode=display">\vec{king} - \vec{man} + \vec{women} = \vec{queen}</script><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/词向量降维.png" alt></p><p>所以当我们考虑上下文的时候，比方说”我觉得C++很难”，那么从上下文来推测中间的词汇，就可以学习到中间的词汇可能是”C++”,而从中间词汇推上下文，可以学习到”很难”。这两个就分别是word2vec中的CBOW模型以及Skip-gram模型的思想。</p><p>word2vec就是简化版的神经网络，输入是One-hot Vector，隐藏层没有激活函数，也就是线性的单元。输出的维度和输入的维度是一样的，用的是softmax进行分类输出。通过训练可以得到参数。</p><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/word2vec网络图.png" alt></p><p>Word2vec通过CBOW(Continuous Bag-of-Words)和Skip-Gram两种模型来定义输入或者输出。CBOW模型的训练输入是某一个特征词的上下文相关的词对应的词向量，而输出就是这特定的一个词的词向量。　Skip-Gram模型和CBOW的思路是反着来的，即输入是特定的一个词的词向量，而输出是特定词对应的上下文词向量。CBOW对小型数据库比较合适，而Skip-Gram在大型语料中表现更好。</p><h1 id="2-CBOW模型"><a href="#2-CBOW模型" class="headerlink" title="2. CBOW模型"></a>2. CBOW模型</h1><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/CBOW模型.png" alt></p><ul><li>输入层：上下文单词的独热向量，图中的向量空间维度为V，上下文单词个数为C</li><li>隐藏层：所有的独热向量分别乘以共享的权重矩阵$W_{v\times N}$，那么初始的$x_{1\times v}$就转换成了$H_{1\times N}$的向量，一共有C个，将C个hidden layer的向量取平均得到一个1 * N大小的向量，作为hidden layer的值</li><li>输出层：输出层的权重矩阵为$W’_{N\times V}$，将得到的hidden layer向量与W’相乘，并通过linear layer的softmax，得到一个1 * V的向量，也就是代表各个词的频率了。选取频率最高的作为预测出来的中间词</li><li>与ground truth中的one hot比较，找出lost function的最小值，一般都是用的cross-entropy</li><li>训练完毕之后，输入层每个单词与W相乘得到的结果就是想要的word embedding</li></ul><h1 id="3-Skip-Gram模型"><a href="#3-Skip-Gram模型" class="headerlink" title="3. Skip-Gram模型"></a>3. Skip-Gram模型</h1><p>Skip-Gram模型相当于CBOW模型的相反，是根据给定的input vector来预测上下文。训练skip-gram模型来实现以下为任务：给出一个句子中间的某个单词，观察输入单词旁边的单词并随机选择一个，而训练的神经网络将告诉我们词汇表中每个单词被选作临近单词的概率。所谓的临近单词与算法中设置的窗口大小(window size)有关，一般window size = 5，意思是预测上下文共10个词。</p><p><img src="/2021/12/07/Word2Vec%E6%80%BB%E7%BB%93/Skip-Gram模型.png" alt></p><ul><li>输入层：输入中心词汇$x_k$，其周围有C个上下文词汇。输入是中心词的one-hot vector，维度是1 * V</li><li>隐藏层：通过预先初始化的权重$W_{V\times N}$，来得到隐藏层的向量$H_{1\times N}$</li><li>输出层：从hidden layer到output layer做了C次的前向传递，每次的传递都与相同的W’权重矩阵相乘，产生V维的向量y。C由window size决定，故输出总和的大小为C*V</li><li>将这C次所产生的值$y_1$到$y_c$通过softmax进行分类，计算的是y的每一个维度的概率值。因此我们可以将y的每一个维度值视为所有相异的词汇与中心词汇的点积，点积越大，概率值就越大</li></ul><h1 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h1><p>skip-gram模型中包含着一个非常大的W向量，如果一个带有300个特征，含有10000个词汇，那么在隐藏层和输出层将会产生300w的向量维度，所以必须进行优化。</p><h2 id="4-1-Hierarchical-Softmax"><a href="#4-1-Hierarchical-Softmax" class="headerlink" title="4.1 Hierarchical Softmax"></a>4.1 Hierarchical Softmax</h2><p>Hierarchical Softmax是计算softmax的一种高效的方式。其思想是在求概率分布时，不对所有的词的概率求和来做归一化，这样就避免了对所有单词表示更新 。</p><p>softmax回归是对语料库中的每个词语(类)都计算一遍输出概率并进行归一化，在大语料库中无疑是非常复杂的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Word2Vec算法简介&quot;&gt;&lt;a href=&quot;#1-Word2Vec算法简介&quot; class=&quot;headerlink&quot; title=&quot;1. Word2Vec算法简介&quot;&gt;&lt;/a&gt;1. Word2Vec算法简介&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点.md</title>
    <link href="http://yoursite.com/2021/12/04/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-md/"/>
    <id>http://yoursite.com/2021/12/04/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9-md/</id>
    <published>2021-12-04T14:13:44.000Z</published>
    <updated>2021-12-07T03:05:27.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据库基本概念"><a href="#1-数据库基本概念" class="headerlink" title="1.数据库基本概念"></a>1.数据库基本概念</h1><a id="more"></a><ul><li>DQL：数据查询语言（凡是带有select关键字的都是查询语句）</li><li>DML：数据操作语言（凡是对表当中的数据进行增删改的都是DML）<br>  insert 增<br>  delete 删<br>  update 改</li><li>DDL：数据定义语言，凡是带有create、drop、alter的都是DDL<br>  DDL主要操作的是表的结构，不是表中的数据，与DML不同</li><li>TCL：事务控制语言，包括：事务提交（commit）；事务回滚（rollback）</li><li><p>DCL：数据控制语言（例如：授权grant、撤销权限revoke）</p></li><li><p>在所有的数据库中，单引号是字符串的标准，但是MySQL中可以使用’’来定义字符串，不过一般建议用’’定义字符串</p></li></ul><h1 id="2-MySQL基本操作"><a href="#2-MySQL基本操作" class="headerlink" title="2.MySQL基本操作"></a>2.MySQL基本操作</h1><ul><li><p>起别名：mysql&gt; select deptno,dname as deptname from dept;（只会改变显示的结果而不会改变原本表中的结果）</p></li><li><p>条件查询：mysql&gt; select empno,ename from emp where sal &gt; 800;<br>查询在某个值之间的值：mysql&gt; select empno,ename,sal from emp where sal between 2450 and 3000;</p></li><li><p>and的优先级比or更高，如果不确定优先级，加小括号就好了</p></li><li>模糊查询：like，支持%或下划线匹配，%匹配任意字符，下划线只匹配一个字符<br>eg.找出名字中含有o的：select ename from emp where ename like ‘%o%’;<br>找出名字以T结尾的：select ename from emp where ename like ‘%T’;<br>找出名字第二个字母是A的：select ename from emp where ename like ‘_A%’;<br>找出名字第三个字母是’R’的</li></ul><p>找出名字中含有’_’的（要使用转义字符）：select name from emp where name like ‘%_%’;</p><ul><li><p>排序：</p><ol><li>查询所有员工工资，排序（升序）：mysql&gt; select ename,sal from emp order by sal;</li><li>查询所有员工工资，排序（降序）：mysql&gt; select ename,sal from emp order by sal desc;</li><li>查询员工的名字和薪资，如果工资一样，按照名字首字母的升序排列：select ename,sal from emp order by sal asc,ename asc;</li><li><p>数据处理函数（单行处理函数）<br> 单行处理函数的特点：一个输入对应一个输出<br> 多行处理函数：多个输入对应一个输出</p><p>单行处理函数常见的：<br> lower：转成小写：mysql&gt; select lower(ename) from emp;<br> upper：转成大写<br> str_to_date：将字符串转换为日期<br> date_format：格式化日期<br> format：设置千分位<br> round：四舍五入<br> rand()：生成随机数<br> ifnull：将null转换成一个具体值<br> substr:截取字符串：select ename from emp where substr(ename,1,1) = ‘A’;（选取开头是A的名字）<br> concat：字符串拼接：mysql&gt; select concat(empno,ename) from emp;</p><p>分组函数（多行处理函数）：<br> 多行处理函数：输入多行，最终输出一行<br> count：计数<br> sum：求和<br> avg：平均值。计算工资的平均值mysql&gt; select avg(sal) from emp;<br> max：最大值<br> min：最小值<br>注意：分组函数在使用的时候必须先进行分组，然后才能使用。如果没有对数据进行分组，整张表默认为一组。</p><p>注意事项：</p><ol><li>分组函数会自动处理null，不用处理null</li><li>count(具体字段)：表示统计该字段下所有不为null的元素的总和<br>count(*)：统计表当中的总行数（只要有一行数据存在不为空就++）</li><li>分组函数不能直接使用在where语句中</li><li>所有的分组函数可以组合起来一起使用</li></ol></li></ol><ul><li><p>分组查询<br>在实际的应用中，可能有这样的需求，需要先进行分组，然后对每一分组进行操作，这时候就要进行分组查询。<br>语法为：select … from … group by …<br>为什么分组函数不能用在where后面：因为分组函数在使用的时候，必须先分组后才能使用，where执行的时候，还没有分组，所以where后面不能出现分组函数。</p><p>关键字的执行顺序：<br>1.from<br>2.where<br>3.group by<br>4.select<br>5.order by</p><p>结论：在一条select语句中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其他的一律不能跟。</p><p>找出每个部门的最高薪资：mysql&gt; select deptno,max(sal) from emp group by deptno;</p><p>mysql&gt; select job,deptno,max(sal) from emp group by job,deptno;</p></li><li><p>找出每个部门的最高薪资，并且薪资大于3000：mysql&gt; select deptno,max(sal) from emp group by deptno having max(sal) &gt; 3000;<br>使用的是having语句，当分组完之后还需要过滤的话就需要saving语句，saving必须与group by一起使用，且不能代替where语句。</p><p>优化策略：where和having，优先选择where，where实在完成不了的话，再选择having。</p></li><li><p>去除重复数据：使用关键字（distinct）<br>mysql&gt; select distinct job,deptno from emp;</p><p>distinct出现在job，deptno两个字段之前，表示两个字段联合起来去重。mysql&gt; select distinct job,deptno from emp;</p></li></ul></li></ul><pre><code>* 连接查询从一张表中单独查询，称为单表查询。emp表和sept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询。表连接的分类：1. 内连接：    等值连接    非等值连接    自连接2. 外连接    左外连接（左连接）    右外连接（右连接）笛卡尔积：当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表的条数的总和。这种现象称为笛卡尔积现象。避免笛卡尔积现象：连接时加条件，满足条件的被筛选出来mysql&gt; select ename,dname from emp,dept where emp.deptno = dept.deptno;最终的查询结果数是14条，但是匹配的过程中，匹配的次数并没有减少，只不过是进行了四选一。内连接之等值连接：查询每个员工所在部门名称，显示员工名1和部门名，条件是：e.deptno = d..deptno;SQL99的语法和之前的不太一样：mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;* 对比：1. mysql&gt; select ename,dname from emp,dept where emp.deptno = dept.deptno;//这是SQL92，结构不清晰，表的连接条件和后期进一步筛选的条件都放到了一起，都放到了where后面。2. mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;//表的连接条件是独立的，连接之后，如果还需要进一步筛选，可以再往后继续添加where* SQL99的语法：select ... from a join b on a连接b的条件 where 筛选条件* 内连接之非等值连接有下表：+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+薪资等级表：+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+找出每个员工的薪资等级，要求显示员工名、薪资、薪资与等级。mysql&gt; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;* 内连接之自连接查询员工的上级领导，要求显示员工名和对应的领导名。对应的技巧就是将一张表看成两张表。mysql&gt; select a.ename as &#39;员工名&#39;,b.ename as &#39;领导名&#39; from emp a join emp b on a.mgr = b.empno;+-----------+-----------+| 员工名    | 领导名    |+-----------+-----------+| SMITH     | FORD      || ALLEN     | BLAKE     || WARD      | BLAKE     || JONES     | KING      || MARTIN    | BLAKE     || BLAKE     | KING      || CLARK     | KING      || SCOTT     | JONES     || TURNER    | BLAKE     || ADAMS     | SCOTT     || JAMES     | BLAKE     || FORD      | JONES     || MILLER    | CLARK     |+-----------+-----------+* 外连接员工表：+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+部门表：+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+找出每个员工对应的岗位：mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+内连接的特点：完成能够匹配上这个连接的才显示出来外连接查询：mysql&gt; select e.ename,d.dname from emp e right (outer) join dept d on e.deptno = d.deptno;（右外连接，right表示将join关键字右边的表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表）outer关键字可以省略在外连接中，两张表连接产生了主次关系。外连接的查询结果条数&gt;=内连接的查询结果条数+--------+------------+| ename  | dname      |+--------+------------+| MILLER | ACCOUNTING || KING   | ACCOUNTING || CLARK  | ACCOUNTING || FORD   | RESEARCH   || ADAMS  | RESEARCH   || SCOTT  | RESEARCH   || JONES  | RESEARCH   || SMITH  | RESEARCH   || JAMES  | SALES      || TURNER | SALES      || BLAKE  | SALES      || MARTIN | SALES      || WARD   | SALES      || ALLEN  | SALES      || NULL   | OPERATIONS |+--------+------------+* 三张表和四张表的连接方式语法：select ... from a join b on a和b的连接条件 join c on a和c的连接条件 join d on a和d的连接条件（一条SQL中内连接和外连接可以混合，都可以出现）eg.找出每个员工的部门名称及工资等级，要求显示员工名、部门名、薪资、薪资等级新用到的表如下：+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+实现：mysql&gt; select e.ename,e.sal,d.dname,s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal;+--------+---------+------------+-------+| ename  | sal     | dname      | grade |+--------+---------+------------+-------+| SMITH  |  800.00 | RESEARCH   |     1 || ALLEN  | 1600.00 | SALES      |     3 || WARD   | 1250.00 | SALES      |     2 || JONES  | 2975.00 | RESEARCH   |     4 || MARTIN | 1250.00 | SALES      |     2 || BLAKE  | 2850.00 | SALES      |     4 || CLARK  | 2450.00 | ACCOUNTING |     4 || SCOTT  | 3000.00 | RESEARCH   |     4 || KING   | 5000.00 | ACCOUNTING |     5 || TURNER | 1500.00 | SALES      |     3 || ADAMS  | 1100.00 | RESEARCH   |     1 || JAMES  |  950.00 | SALES      |     1 || FORD   | 3000.00 | RESEARCH   |     4 || MILLER | 1300.00 | ACCOUNTING |     2 |+--------+---------+------------+-------+eg.找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级。mysql&gt; select e.ename,e.sal,d.dname,s.grade,l.ename from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp l on e.mgr = l.empno;+--------+---------+------------+-------+-------+| ename  | sal     | dname      | grade | ename |+--------+---------+------------+-------+-------+| SMITH  |  800.00 | RESEARCH   |     1 | FORD  || ALLEN  | 1600.00 | SALES      |     3 | BLAKE || WARD   | 1250.00 | SALES      |     2 | BLAKE || JONES  | 2975.00 | RESEARCH   |     4 | KING  || MARTIN | 1250.00 | SALES      |     2 | BLAKE || BLAKE  | 2850.00 | SALES      |     4 | KING  || CLARK  | 2450.00 | ACCOUNTING |     4 | KING  || SCOTT  | 3000.00 | RESEARCH   |     4 | JONES || KING   | 5000.00 | ACCOUNTING |     5 | NULL  || TURNER | 1500.00 | SALES      |     3 | BLAKE || ADAMS  | 1100.00 | RESEARCH   |     1 | SCOTT || JAMES  |  950.00 | SALES      |     1 | BLAKE || FORD   | 3000.00 | RESEARCH   |     4 | JONES || MILLER | 1300.00 | ACCOUNTING |     2 | CLARK |+--------+---------+------------+-------+-------+* 子查询select语句中嵌套select，被嵌套的select语句称为子查询。1. where子句中的子查询eg.找出比最低工资高的员工姓名和工资由于where子句中不能直接使用分组函数，所以使用嵌套mysql&gt; select ename,sal from emp where sal &gt; (select min(sal) from emp);结果为：+--------+---------+| ename  | sal     |+--------+---------+| ALLEN  | 1600.00 || WARD   | 1250.00 || JONES  | 2975.00 || MARTIN | 1250.00 || BLAKE  | 2850.00 || CLARK  | 2450.00 || SCOTT  | 3000.00 || KING   | 5000.00 || TURNER | 1500.00 || ADAMS  | 1100.00 || JAMES  |  950.00 || FORD   | 3000.00 || MILLER | 1300.00 |+--------+---------+2. from子句中的子查询注意：from后面的子查询，可以将子查询的查询结果当作一张临时表。eg.找出每个岗位的平均工资的薪资等级实现：mysql&gt;  select t.*,s.grade from (select job,avg(sal) as avgsal from emp group by job) t join salgrade s on t.avgsal between s.losal and s.hisal;结果：+-----------+-------------+-------+| job       | avgsal      | grade |+-----------+-------------+-------+| CLERK     | 1037.500000 |     1 || SALESMAN  | 1400.000000 |     2 || MANAGER   | 2758.333333 |     4 || ANALYST   | 3000.000000 |     4 || PRESIDENT | 5000.000000 |     5 |+-----------+-------------+-------+(select job,avg(sal) as avgsal from emp group by job)相当于一个新的表avgsal，是临时的表。* select后面出现的子查询eg.找出每个员工的部门名称，要求显示员工名，部门名实现：mysql&gt; select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e;结果：+--------+------------+| ename  | dname      |+--------+------------+| SMITH  | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || JONES  | RESEARCH   || MARTIN | SALES      || BLAKE  | SALES      || CLARK  | ACCOUNTING || SCOTT  | RESEARCH   || KING   | ACCOUNTING || TURNER | SALES      || ADAMS  | RESEARCH   || JAMES  | SALES      || FORD   | RESEARCH   || MILLER | ACCOUNTING |+--------+------------+* union合并查询结果集eg.查询工作岗位是MANAGER和SALESMAN的员工方法1：select ename,job from emp where job = &#39;MANAGER&#39; or job = &#39;SALESMAN&#39;;方法2：select ename,job from emp where job in(&#39;MANAGER&#39;,&#39;SALESMAN&#39;);方法3：select ename,job from emp where job = &#39;MANAGER&#39; union select ename,job from emp where job = &#39;SALESMAN&#39;;（这里的方法3的效率最高）结果：+--------+----------+| ename  | job      |+--------+----------+| JONES  | MANAGER  || BLAKE  | MANAGER  || CLARK  | MANAGER  || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+union在进行结果合并时，要求两个结果集的列数相等。* limit的作用将查询结果的一部分取出来，通常使用在分页查询中。eg.按照工资降序，取出排名在前5名的员工实现：mysql&gt; select ename,sal from emp order by sal desc limit 5;结果：+-------+---------+| ename | sal     |+-------+---------+| KING  | 5000.00 || SCOTT | 3000.00 || FORD  | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+完整用法：limit startIndex,lengthMySQL中的limit在order by之后执行。* 分页limit (pageNo - 1) * pageSize,pageSize;* DQL语句的总结select ... from ... where ... group by ... having ... order by ... limit ...</code></pre><h1 id="3-数据库基本操作2（DDL）"><a href="#3-数据库基本操作2（DDL）" class="headerlink" title="3. 数据库基本操作2（DDL）"></a>3. 数据库基本操作2（DDL）</h1><ul><li><p>表的创建<br>语法格式：create table 表名(字段1 数据类型，</p><pre><code>                      字段2 数据类型，                      字段3 数据类型);</code></pre><p>表名建议以t_或者tbl_开始，可读性强。；见名知义</p></li><li><p>MySQL数据类型<br>varchar：可变长度的字符串，比较智能，节省空间，会根据实际的数据长度动态分配空间。<br>char：定长字符串，固定长度空间去存储数据数据。速度快，使用不当可能会造成空间的浪费。<br>int：<br>longint：长整型<br>float：<br>double：<br>date：短日期类型<br>datetime：长日期类型<br>clob：字符大对象，最多可以存储4G的字符串，超过255个字符的都要采用CLOB大对象来存储。<br>blob：二进制大对象，专门用来存储图片、声音、视频等流媒体数据。插入数据时，要使用IO流。</p></li><li><p>创建表例子<br>mysql&gt; create table t_student(no int,</p><pre><code>                      name varchar(32),                      sex char(1),                      age int(3),                      email varchar(255));</code></pre></li></ul><p>删除表：drop table if exists t_student;</p><ul><li>插入数据（DML）<br>语法：insert into 表名（字段1，字段2，字段3） values（值1，值2，值3）;<br>注意：字段名和值要一一对应<br>eg.    mysql&gt; insert into t_student(no,name,sex,age,email) values(1,’zhangsan’,’m’,19,’zhangsan@gmail.com’);</li></ul><p>如果没有在创建的时候指定的话，默认值是null。<br>前面的字段名省略的话，等于都写上了，所以值也都要写上。</p><ul><li>insert插入日期<br>数字格式化：format<br>千分位显示：mysql&gt; select ename,format(sal,’$999,999’) as sal from emp;<br>结果：<br>  +————+———-+<br>  | ename  | sal   |<br>  +————+———-+<br>  | SMITH  | 800   |<br>  | ALLEN  | 1,600 |<br>  | WARD   | 1,250 |<br>  | JONES  | 2,975 |<br>  | MARTIN | 1,250 |<br>  | BLAKE  | 2,850 |<br>  | CLARK  | 2,450 |<br>  | SCOTT  | 3,000 |<br>  | KING   | 5,000 |<br>  | TURNER | 1,500 |<br>  | ADAMS  | 1,100 |<br>  | JAMES  | 950   |<br>  | FORD   | 3,000 |<br>  | MILLER | 1,300 |<br>  +————+———-+</li></ul><ol><li><p>str_to_date：将字符串varchar类型转化为date类型<br>格式：str_to_date(‘字符串日期’,’日期格式’)<br>mysql日期格式：<br>%Y 年，%m 月，%d 日，%h 时，%i 分，%s 秒</p></li><li><p>data_format：将data类型转换为varchar类型<br>格式：data_format(日期类型数据,’日期格式’)</p></li></ol><p><em>*</em> 数据库的命名规范：所有的标识符都是全部小写，单词和单词之间用下划线分割。</p><p>mysql&gt; insert into t_user(id,name,birth) values(1,’zhangsan’,str_to_date(‘01-10-1990’,’%d-%m-%Y’));</p><p>结果：<br>    +———+—————+——————+<br>    | id   | name     | birth      |<br>    +———+—————+——————+<br>    |    1 | zhangsan | 1990-10-01 |<br>    +———+—————+——————+</p><p>str_to_date函数可以把字符串varchar转换成日期，通常使用在insert里面，如果提供的日期字符串时%Y-%m-%d的格式，那么就不需要用该函数也可以达到一样的效果。</p><p>mysql&gt; select id,name,date_format(birth,’%m/%d%Y’) as birthday from t_user;</p><p>结果：<br>    +———+—————+—————-+<br>    | id   | name     | birthday  |<br>    +———+—————+—————-+<br>    |    1 | zhangsan | 10/011990 |<br>    |    2 | lisi     | 12/251991 |<br>    +———+—————+—————-+</p><p>mysql&gt; select * from t_user;<br>+———+—————+——————+<br>| id   | name     | birth      |<br>+———+—————+——————+<br>|    1 | zhangsan | 1990-10-01 |<br>|    2 | lisi     | 1991-12-25 |<br>+———+—————+——————+<br>上述的SQL语句其实是对数据进行了默认的数据类型转换，转换成为了varchar类型，且遵从的格式是：%Y-%d-%m</p><ul><li>date和datetime两个类型的区别<br>date是短日期：只包括年月日信息。<br>datetime：包括年月日时分秒信息。</li></ul><p>短日期默认格式：%Y-%m-%d<br>长日期默认格式：%Y-%m-%d  %h:%i:%s</p><p>eg.mysql&gt; insert into t_user1 values(1,’zhangsan’,’1999-10-1 15:23:10’);<br>结果：<br>    +———+—————+——————+——————————-+<br>    | id   | name     | birth      | create_time         |<br>    +———+—————+——————+——————————-+<br>    |    1 | zhangsan | 1999-10-01 | 2000-02-04 13:23:10 |<br>    +———+—————+——————+——————————-+</p><p>mysql获取当前时间：now()，获取的时间是datetime类型的</p><ul><li>修改（update DML语句）<br>update 表名 set 字段名1=值1，字段名2=值2，字段名3=值3… where 条件</li></ul><p>eg. mysql&gt; update t_user1 set name = ‘jack’, birth = ‘2000-10-11’ where id = 2;</p><ul><li>删除delete（DML）<br>语法：delete from 表名 where 条件;<br>没有条件的话，整张表的数据会全部删除。</li></ul><p>eg. delete from t_user where id=2;</p><ul><li><p>一次插入多条数据<br>insert into t_user1(id,name,birth,create_time) values(3,’zs’,’1999-10-8’,now()),(4,’zs’,’1999-10-8’,now()),(3,’zs’,’1999-10-8’,now());</p></li><li><p>快速创建一张表<br>mysql&gt; create table emp2 as select * from t_user1;（完成的是表的快速复制）<br>查询部分结果保留为一张表：<br>create table mytable as select empno,ename from emp where job = ‘MANAGER’;</p></li></ul><p>将查询到的结果插入到另一张表中：mysql&gt; insert into dept_bak select * from dept;</p><ul><li>删除大表<br>delete from dept_bak;<br>delete删除数据的时候，只是删除了数据，而这个数据在硬盘上的存储空间不会被删除，就相当于回收站的功能，缺点是删除效率比较低，优点是，支持回滚，后悔可以恢复。</li></ul><p>另一种删除数据的方法：truncate。删除的效率比较高，表被一次截断，物理删除。这种删除不支持回滚。<br>用法：truncate table dept_bak；（属于DDL操作）</p><p>删除表的操作：drop table 表名;//这不是删除表中的数据，而是把表删除。</p><ul><li><p>对表结构的增删改<br>很少进行表结构的修改，因为修改表结构成本较高。不需要写道程序中。</p></li><li><p>约束<br>约束的作用是为了保证表中的数据有效。<br>约束的分类：</p><ol><li>非空约束（not null）</li><li>唯一性约束（unique）</li><li>主键约束（primary key）（简称PK）</li><li>外键约束（foreign key）（简称FK）</li><li>检查约束（check）（MySQL不支持，Oracle支持）</li></ol></li><li><p>非空约束：not null<br>  非空约束not null约束的字段不能为null，创建的时候可以加</p><p>  create table t_vip(id int,name varchar(255) not null);</p></li><li><p>唯一性约束</p></li></ul><p>如何创建两个联合起来唯一的？<br>create table t_vip(<br>    id int,<br>    name varchar(255),<br>    email varchar(255),<br>    unique(name,email)//表级约束<br>)<br>unique有表级约束而not null 没有</p><ul><li>主键约束<br>在MySQL中，如果一个字段同时被not null约束的话，该字段自动变为主键字段。（Oracle中不一样）<br>主键值是每一行记录的唯一标识，主键值是每一行记录的身份证号。</li></ul><p>create table t_vip(<br>    id int primary key,<br>    name varchar(255)<br>);</p><p>表级约束主要是用来给多个字段联合起来添加约束。<br>联合起来做主键：<br>mysql&gt; create table t_vip(id int,name varchar(255),<br>                        email varchar(255),<br>                        primary key(id,name));</p><p>在实际开发中不建议使用复合主键，复合主键比较复杂。<br>一张表，主键约束只能添加一个。<br>主键值建议使用：int，bigint，char等类型，不建议使用：varchar类型。主键值一般都是数字，一般是定长的。</p><p>主键的分类：自然主键和业务主键。<br>自然主键：主键值是一个自然数，和业务没关系。<br>业务主键：主键值和业务紧密关联，例如拿银行卡账号作主键值。</p><p>实际开发中使用自然主键的多，因为主键只需要做到不重复即可，不需要有意义。当业务发生变化时，可能会影响到主键值，所以业务主键不建议使用。</p><p>自增给自动维护一个主键值：<br>    <em>cr</em>eate table t_vip2(<em>        </em>id int primary key auto_increment,<em>        </em>name varchar(255)<em>    </em>);<em>    </em>insert into t_vip2(name) values(‘zhangsan’);<em>    </em>insert into t_vip2(name) values(‘zhangsan’);<em>    </em>insert into t_vip2(name) values(‘zhangsan’);<em>    </em>insert into t_vip2(name) values(‘zhangsan’);<em>    </em>insert into t_vip2(name) values(‘zhangsan’);<em><br>    insert into t_vip2(name) values(‘zhangsan’);</em><br>    创建的表如下：<br>    +——+—————+<br>    | id | name     |<br>    +——+—————+<br>    |  1 | zhangsan |<br>    |  2 | zhangsan |<br>    |  3 | zhangsan |<br>    |  4 | zhangsan |<br>    |  5 | zhangsan |<br>    |  6 | zhangsan |<br>    +——+—————+</p><ul><li><p>外键约束（very important）FK<br>  外键约束就是为了减少数据的冗余度，有一张t_class作为父表（用作约束），t_student是子表（施加约束）。<br>  删除表的顺序：先删除子表，再删除父表<br>  创建表的顺序：先创建父表，再创建子表<br>  删除数据的顺序：先删除子表数据，再删除父表数据<br>  插入数据的顺序：先插入父表，再插入子表</p><p>  create table t_class(</p><pre><code>  classno int primary key,  classname varchar(255)</code></pre><p>  );<br>  create table t_student(</p><pre><code>  no int primary key auto_increment,  name varchar(255),  cno int,  foreign key(cno) references t_class(classno)</code></pre><p>  );</p></li></ul><h1 id="数据库了解内容"><a href="#数据库了解内容" class="headerlink" title="数据库了解内容"></a>数据库了解内容</h1><ul><li>存储引擎<br>存储引擎是MySQL中的特有的一个术语，实际上存储引擎是一个表，表存储数据的方式不同。</li></ul><p>怎么给表添加指定的存储引擎？<br>show create table t_student;<br>可以在建表的时候，可以在最后的后面使用ENGINE来指定存储引擎，CHARSET表示这张表的字符编码方式。MySQL的默认存储引擎是innodb。<br>MySQL支持九大存储引擎。</p><ul><li>不同的存储引擎</li></ul><ol><li>MYISAM存储引擎<br>使用三个文件表示表：<br> 格式文件：存储表结构的定义(mytable.frm)<br> 数据文件：存储表行的内容(mytable.MYD)<br> 索引文件：存储表上的索引(mytable.MYI)</li></ol><p>可被转换为压缩、只读表来节省空间。对于一张表来说，只要加有主键或者unique类型的，都会被自动加以索引。</p><ol><li>InnoDB存储引擎<br>是MySQL默认存储引擎，同时也是一个重量级的存储引擎。InnoDB支持事务，支持数据库崩溃后自动恢复机制。InnoDB存储引擎最主要的特点是：非常安全。</li></ol><p>管理的表具有以下特征：</p><pre><code>- 每个InnoDB表在数据库目录中以.frm格式文件表示    - InnoDB表空间tablespace被用于存储表的内容    - 提供一组用来记录事务性活动的日志文件    - 用COMMIT(提交)、SAVEPOINT及ROLLBACK支持事务处理    - 提供全ACID兼容    - 在MySQL服务器崩溃后自动恢复    - 多版本和行级锁定    - 支持外键及引用的完整性，包括级联删除和更新        效率不是很高，也不能压缩，不能转换为只读，不能很好的节省存储空间。</code></pre><ol><li>MEMORY存储引擎<br>使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定。MEMORY存储引擎管理的表具有以下特征：<ul><li>在数据库目录内，每个表都是以.frm格式文件存储。</li><li>表级锁机制</li><li>不能包含TEXT或BLOB字段<br>优点：查询效率是最高的，不需要和硬盘进行交互<br>缺点：不安全，关机之后数据消失，因为数据和索引都是在内存中</li></ul></li></ol><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p>一个事务其实就是一个完整的业务逻辑。只有DML语句（insert、delete、update）才和事务有关系。因为只有以上的三条语句是数据库表中的增删改的，一旦涉及到数据的增删改就必须考虑到安全问题。正是因为做某件事的时候，需要多条DML语句共同联合在一起才能完成，所以需要事务的存在。本质上，一个事务就是多条DML语句同时成功或者同时失败。</p><p>事务是如何做到同时成功或者同时失败的？前文讲到，InnoDB提供了一组用来记录事务性活动的日志文件。在事务的执行过程中，，每一条DML的操作都会记录到日志文件中，在事务的执行过程中，既可以提交事务，也可以回滚事务。</p><ul><li>提交事务：清空事务性活动的日志文件将数据全部彻底持久化到数据库表中，提交事务标志着事务的结束，并且是一种全部成功的标志</li><li>回滚事务：将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件。回滚事务标志着事务的结束，并且是一种全部失败的结束。</li></ul><p>在MySQL中，提交事务：commit语句，回滚事务：rollback（回滚永远只是回滚到上一次的提交点）。MySQL默认情况下是支持自动提交事务的，每执行一条DML语句，则提交一次。将MySQL自动提交关闭的方法是：start transaction</p><p>MySQL中的自动提交其实是不符合开发习惯的，为了保证数据的安全，必须要求同时成功之后再提交，不能执行一条就提交一条。</p><h2 id="4-1-事务的4个特性"><a href="#4-1-事务的4个特性" class="headerlink" title="4.1 事务的4个特性"></a>4.1 事务的4个特性</h2><p>A： 原子性</p><p>说明事务时最小的工作单元，不可再分</p><p>C：一致性</p><p>所有的事务要求，在同一个事务当中，所有的操作必须同时成功或者同时失败，以保证数据的一致性。</p><p>I：隔离性</p><p>A事务和B事务之间有一定的距离。</p><p>D：持久性</p><p>事务最终结束的一个保障，就相当于将没有保存在硬盘上的数据保存在硬盘上。</p><h2 id="4-2-事务的隔离级别"><a href="#4-2-事务的隔离级别" class="headerlink" title="4.2 事务的隔离级别"></a>4.2 事务的隔离级别</h2><ol><li><p>读未提交：read uncommitted（最低的隔离级别）</p><p>事务A可以读取到事务B未提交的数据，可能出现脏读的现象。这种隔离级别一般都是理论上的，大多数的数据库的隔离级别都是二档起步的。</p></li><li><p>读已提交：read committed</p><p>事务A只能读取到事务B提交之后的数据。解决了脏读的问题，但是引入了新的问题。</p><ul><li>不可重复读取数据：在事务开启之后，第一次读取到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，独到的数据是4条，3!=4称为不可重复读取。</li></ul><p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实，Oracle数据库默认的隔离级别是：read uncommitted</p></li><li><p>可重复度：repeatable read（提交之后也读不到，永远读取的是刚开启事务时的数据）</p><p>事务A开启之后，不管过去多久，每一次在事务A中读取到的数据都是一致的，即使事务B将数据已经修改了，并且提交，事务A读取的数据还是没有发生改变，这就是可重复读。这种解决了不可重复读取的问题。这是MySQL的默认隔离级别。但是引入了新的问题：</p><ul><li>每次读取到的数据都是幻象，不够真实，出现幻影读。</li></ul></li><li><p>序列换/串行化：serializable（最高的隔离级别）</p><p>最高隔离级别，效率最低，解决了所有的问题，表示事务排队，不能并发。每一次读取到的数据都是最真实的，并且效率是最低的。</p></li></ol><h1 id="5-索引"><a href="#5-索引" class="headerlink" title="5. 索引"></a>5. 索引</h1><p>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</p><p>t_user</p><pre><code>id(idIndex)    name(nameIndex)    email(emailIndex)        address  (emailAddressIndex)</code></pre><hr><p>​    1                zhangsan…<br>​    2                lisi<br>​    3                wangwu<br>​    4                zhaoliu<br>​    5                hanmeimei<br>​    6                jack</p><pre><code>select * from t_user where name = &#39;jack&#39;;以上的这条SQL语句会去name字段上扫描，为什么？    因为查询条件是：name=&#39;jack&#39;</code></pre><p>如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。（遵循左小右大的原则存放，采用中序遍历的方式来取数据）</p><h2 id="5-1-索引的实现原理"><a href="#5-1-索引的实现原理" class="headerlink" title="5.1 索引的实现原理"></a>5.1 索引的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设有一张用户表：t_user</span><br><span class="line"></span><br><span class="line">id(PK)name每一行记录在硬盘上都有物理存储编号</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">100zhangsan0x1111</span><br><span class="line">120lisi0x2222</span><br><span class="line">99wangwu0x8888</span><br><span class="line">88zhaoliu0x9999</span><br><span class="line">101jack0x6666</span><br><span class="line">55lucy0x5555</span><br><span class="line">130tom0x7777</span><br></pre></td></tr></table></figure><p>提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。</p><p>提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。</p><p>提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p><p>在MySQL中，主键上以及unique字段上都会自动添加索引，给字段添加索引的条件：</p><p>条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）<br>       条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。<br>       条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</p><p>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</p><h2 id="5-2-索引的创建和删除"><a href="#5-2-索引的创建和删除" class="headerlink" title="5.2 索引的创建和删除"></a>5.2 索引的创建和删除</h2><p>创建索引：</p><p>mysql&gt; create index emp_ename_index on emp(ename);<br>        给emp表的ename字段添加索引，起名：emp_ename_index</p><p>删除索引：</p><p>mysql&gt; drop index emp_ename_index on emp;<br>        将emp表上的emp_ename_index索引对象删除。</p><p>索引失效的情况：</p><ul><li><p>select * from emp where ename like ‘%T’;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ename上即使添加了索引，也不会走索引，为什么？</span><br><span class="line">原因是因为模糊匹配当中以“%”开头了！</span><br><span class="line">尽量避免模糊查询的时候以“%”开始。</span><br><span class="line">这是一种优化的手段&#x2F;策略。</span><br></pre></td></tr></table></figure></li><li><p>使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会实现。所以这就是为什么不建议使用or的原因。</p><p>mysql&gt; explain select * from emp where ename = ‘KING’ or job = ‘MANAGER’;</p></li><li><p>使用复合索引的时候，没有使用左侧的列查找，索引失效</p><pre><code>    什么是复合索引？      两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。</code></pre></li></ul><pre><code>      create index emp_job_sal_index on emp(job,sal);      mysql&gt; explain select * from emp where job = &#39;MANAGER&#39;;</code></pre><ul><li>在where当中索引列参加了运算，索引失效。</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index emp_sal_index on emp(sal);</span><br><span class="line">explain select * from emp where sal &#x3D; 800;</span><br></pre></td></tr></table></figure><ul><li>在where当中索引列使用了函数</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp where lower(ename) &#x3D; &#39;smith&#39;;</span><br></pre></td></tr></table></figure><h1 id="6-视图"><a href="#6-视图" class="headerlink" title="6. 视图"></a>6. 视图</h1><p>视图view:站在不同的角度去看待同一份数据。</p><p>怎么创建视图对象？怎么删除视图对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">表复制：</span><br><span class="line">mysql&gt; create table dept2 as select * from dept;</span><br><span class="line"></span><br><span class="line">dept2表中的数据：</span><br><span class="line">mysql&gt; select * from dept2;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">创建视图对象：</span><br><span class="line">create view dept2_view as select * from dept2;</span><br><span class="line"></span><br><span class="line">删除视图对象：</span><br><span class="line">drop view dept2_view;</span><br><span class="line"></span><br><span class="line">注意：只有DQL语句才能以view的形式创建。</span><br><span class="line">create view view_name as 这里的语句必须是DQL语句;</span><br></pre></td></tr></table></figure><p>用视图做什么？</p><pre><code>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）//面向视图查询select * from dept2_view; // 面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);// 查询原表数据mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     60 | SALES      | BEIJING  |+--------+------------+----------+// 面向视图删除mysql&gt; delete from dept2_view;// 查询原表数据mysql&gt; select * from dept2;Empty set (0.00 sec)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建视图对象</span><br><span class="line">create view </span><br><span class="line">emp_dept_view</span><br><span class="line">as</span><br><span class="line">select </span><br><span class="line">e.ename,e.sal,d.dname</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno &#x3D; d.deptno;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询视图对象</span><br><span class="line">mysql&gt; select * from emp_dept_view;</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| ename  | sal     | dname      |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| CLARK  | 2450.00 | ACCOUNTING |</span><br><span class="line">| KING   | 5000.00 | ACCOUNTING |</span><br><span class="line">| MILLER | 1300.00 | ACCOUNTING |</span><br><span class="line">| SMITH  |  800.00 | RESEARCH   |</span><br><span class="line">| JONES  | 2975.00 | RESEARCH   |</span><br><span class="line">| SCOTT  | 3000.00 | RESEARCH   |</span><br><span class="line">| ADAMS  | 1100.00 | RESEARCH   |</span><br><span class="line">| FORD   | 3000.00 | RESEARCH   |</span><br><span class="line">| ALLEN  | 1600.00 | SALES      |</span><br><span class="line">| WARD   | 1250.00 | SALES      |</span><br><span class="line">| MARTIN | 1250.00 | SALES      |</span><br><span class="line">| BLAKE  | 2850.00 | SALES      |</span><br><span class="line">| TURNER | 1500.00 | SALES      |</span><br><span class="line">| JAMES  |  950.00 | SALES      |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 面向视图更新</span><br><span class="line">update emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原表数据被更新</span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br></pre></td></tr></table></figure><p>视图对象在实际开发中到底有什么用？《方便，简化开发，利于维护》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create view </span><br><span class="line">emp_dept_view</span><br><span class="line">as</span><br><span class="line">select </span><br><span class="line">e.ename,e.sal,d.dname</span><br><span class="line">from</span><br><span class="line">emp e</span><br><span class="line">join</span><br><span class="line">dept d</span><br><span class="line">on</span><br><span class="line">e.deptno &#x3D; d.deptno;</span><br></pre></td></tr></table></figure><p>​    假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？可以把这条复杂的SQL语句以视图对象的形式新建。在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的SQL语句。我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><p>再提醒一下：<br>    视图对应的语句只能是DQL语句。<br>    但是视图对象创建完成之后，可以对视图进行增删改查等操作。</p><p>小插曲：<br>    增删改查，又叫做：CRUD。CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。一般都说CRUD。</p><p>C:Create（增）<br>       R:Retrive（查：检索）<br>       U:Update（改）<br>       D:Delete（删）</p><h1 id="7-数据库设计范式"><a href="#7-数据库设计范式" class="headerlink" title="7. 数据库设计范式"></a>7. 数据库设计范式</h1><p>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</p><p>第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。</p><p>第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。</p><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h2 id="7-1-第一范式"><a href="#7-1-第一范式" class="headerlink" title="7.1 第一范式"></a>7.1 第一范式</h2><p>最核心，最重要的范式，所有表的设计都需要满足。必须有主键，并且每一个字段都是原子性不可再分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">学生编号 学生姓名 联系方式</span><br><span class="line">------------------------------------------</span><br><span class="line">1001张三zs@gmail.com,1359999999</span><br><span class="line">1002李四ls@gmail.com,13699999999</span><br><span class="line">1001王五ww@163.net,13488888888</span><br><span class="line"></span><br><span class="line">以上是学生表，满足第一范式吗？</span><br><span class="line">不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话</span><br><span class="line"></span><br><span class="line">学生编号(pk) 学生姓名邮箱地址联系电话</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001张三zs@gmail.com1359999999</span><br><span class="line">1002李四ls@gmail.com13699999999</span><br><span class="line">1003王五ww@163.net13488888888</span><br></pre></td></tr></table></figure><h2 id="7-2-第二范式"><a href="#7-2-第二范式" class="headerlink" title="7.2 第二范式"></a>7.2 第二范式</h2><p>建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学生编号 学生姓名    教师编号    教师姓名</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001张三001王老师</span><br><span class="line">1002李四002赵老师</span><br><span class="line">1003王五001王老师</span><br><span class="line">1001张三002赵老师</span><br></pre></td></tr></table></figure><p>这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）<br>    这是非常典型的：多对多关系！</p><p>分析以上的表是否满足第一范式？不满足第一范式。</p><p>怎么满足第一范式呢？修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学生编号+教师编号(pk)       学生姓名       教师姓名</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001001张三王老师</span><br><span class="line">1002002李四赵老师</span><br><span class="line">1003001王五王老师</span><br><span class="line">1001002张三赵老师</span><br></pre></td></tr></table></figure><p>学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。产生部分依赖有什么缺点？数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。</p><p>为了让以上的表满足第二范式，你需要这样设计：使用三张表来表示多对多的关系！！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学生表</span><br><span class="line">学生编号(pk)学生名字</span><br><span class="line">1001张三</span><br><span class="line">1002李四</span><br><span class="line">1003王五</span><br></pre></td></tr></table></figure><hr><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">教师表</span><br><span class="line">教师编号(pk)教师姓名</span><br><span class="line">--------------------------------------</span><br><span class="line">001王老师</span><br><span class="line">002赵老师</span><br><span class="line"></span><br><span class="line">学生教师关系表</span><br><span class="line">id(pk)学生编号(fk)教师编号(fk)</span><br><span class="line">------------------------------------------------------</span><br><span class="line">11001001</span><br><span class="line">21002002</span><br><span class="line">31003001</span><br><span class="line">41001002</span><br></pre></td></tr></table></figure><h2 id="7-3-第三范式"><a href="#7-3-第三范式" class="headerlink" title="7.3 第三范式"></a>7.3 第三范式</h2><p>第三范式建立在第二范式的基础之上要求所有非主键字典必须直接依赖主键，不要产生传递依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学生编号（PK） 学生姓名 班级编号  班级名称</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">1001张三01一年一班</span><br><span class="line">1002李四02一年二班</span><br><span class="line">1003王五03一年三班</span><br><span class="line">1004赵六03一年三班</span><br></pre></td></tr></table></figure><p>以上表的设计是描述：班级和学生的关系。很显然是1对多关系！<br>    一个教室中有多个学生。</p><p>分析以上表是否满足第一范式？满足第一范式，有主键。</p><p>分析以上表是否满足第二范式？满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。</p><p>分析以上表是否满足第三范式？第三范式要求：不要产生传递依赖！一年一班依赖01，01依赖1001，产生了传递依赖。不符合第三范式的要求。产生了数据的冗余。</p><p>那么应该怎么设计一对多呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">班级表：一</span><br><span class="line">班级编号(pk)班级名称</span><br><span class="line">----------------------------------------</span><br><span class="line">01一年一班</span><br><span class="line">02一年二班</span><br><span class="line">03一年三班</span><br><span class="line"></span><br><span class="line">学生表：多</span><br><span class="line"></span><br><span class="line">学生编号（PK）       学生姓名     班级编号(fk)</span><br><span class="line">-------------------------------------------</span><br><span class="line">1001张三01</span><br><span class="line">1002李四02</span><br><span class="line">1003王五03</span><br><span class="line">1004赵六03</span><br><span class="line"></span><br><span class="line">背口诀：</span><br><span class="line">一对多，两张表，多的表加外键！！！！！！！！！！！！</span><br></pre></td></tr></table></figure><h2 id="7-4-表的设计总结"><a href="#7-4-表的设计总结" class="headerlink" title="7.4 表的设计总结"></a>7.4 表的设计总结</h2><p>一对多：一对多，两张表，多的表加外键！！！！！！！！！！！！</p><p>多对多：多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</p><p>一对一：一对一放到一张表中不就行了吗？为啥还要拆分表？在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。<br>    一对一怎么设计？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">没有拆分表之前：一张表</span><br><span class="line">t_user</span><br><span class="line">idlogin_namelogin_pwdreal_nameemailaddress........</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">1zhangsan123张三zhangsan@xxx</span><br><span class="line">2lisi123李四lisi@xxx</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">这种庞大的表建议拆分为两张：</span><br><span class="line">t_login 登录信息表</span><br><span class="line">id(pk)login_namelogin_pwd</span><br><span class="line">---------------------------------</span><br><span class="line">1zhangsan123</span><br><span class="line">2lisi123</span><br><span class="line"></span><br><span class="line">t_user 用户详细信息表</span><br><span class="line">id(pk)real_nameemailaddress........login_id(fk+unique)</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">100张三zhangsan@xxx1</span><br><span class="line">200李四lisi@xxx2</span><br></pre></td></tr></table></figure><pre><code>            口诀：一对一，外键唯一！！！！！！！！！！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-数据库基本概念&quot;&gt;&lt;a href=&quot;#1-数据库基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.数据库基本概念&quot;&gt;&lt;/a&gt;1.数据库基本概念&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>RNN and LSTM</title>
    <link href="http://yoursite.com/2021/10/18/RNN-and-LSTM/"/>
    <id>http://yoursite.com/2021/10/18/RNN-and-LSTM/</id>
    <published>2021-10-17T19:50:50.000Z</published>
    <updated>2021-10-19T08:53:23.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RNN与LSTM"><a href="#RNN与LSTM" class="headerlink" title="RNN与LSTM"></a>RNN与LSTM</h1><h2 id="RNN模型"><a href="#RNN模型" class="headerlink" title="RNN模型"></a>RNN模型</h2><a id="more"></a><p>RNN模型的结构图如下所示：<br><img src="/images/RNN模型.png" alt="avatar"><br>RNN其实是一个单元的重复使用，经常用在与时间序列相关的场景中。这是一种sequential-tosequential的模型。<br>由网络图可知，每个单元的状态表示为S_t = f(U<em>X_t + W</em>S_(t-1))，f代表的是激活函数。最后输出的是概率预测，使用的是softmax函数。<br><img src="/images/经典的RNN.png" alt="avatar"></p><p>其中U和W都是权重关系，前者称为状态-状态权重，后者称为状态-输入权重.<br>标准的RNN网络有以下的特点：</p><ol><li>权值共享：图中的W全部是相同的，U和V也都一样</li><li>每一个输入值都只与它本身的那条路线建立权连接，不会和别的神经元连接。</li></ol><p>RNN的模型表示：<br><img src="/images/RNN完整图.png" alt="avatar"><br>x表示输入，h表示隐层单元，o表示输出，L为损失函数，y为训练集标签。右上角的t表示t时刻的状态。隐层单元在t时刻不仅仅由此时刻的输入决定，还受t时刻之前的时刻的影响。U、W、V是权值，权值共享。<br>对于t时刻：<br><img src="/images/隐层时刻t.png" alt="avatar"><br>其中fai()是激活函数，一般在RNN里面会选择tanh函数，b为偏置。<br>t时刻的输出为：<br><img src="/images/t时刻输出.png" alt="avatar"><br>最终的预测模型为：<br><img src="/images/RNN预测.png" alt="avatar"><br>其中σ为激活函数，通常用于分类，为softmmax</p><h3 id="RNN的训练"><a href="#RNN的训练" class="headerlink" title="RNN的训练"></a>RNN的训练</h3><p>BPTT(back-propagation through time)算法是常用训练RNN的方法，核心思想和BP算法相似。需要寻优的参数有三个，分别是U、V、W。W和V的更新都要追溯到历史数据，参数V相对简单只需要关注目前状态，先更新V：<br><img src="/images/V参数更新.png" alt="avatar"><br>RNN的损失也是会随着时间累加的，所以不能只求t时刻的偏导。<br><img src="/images/V参数更新所有.png" alt="avatar"><br>W和U的更新要涉及到历史数据，其偏导求解相对复杂，假设只有三个时刻，那么在第三个时刻L对W的偏导数为：<br><img src="/images/L对W的偏导.png" alt="avatar"><br>相应的，L在第三个时刻对U的偏导为：<br><img src="/images/L对U的偏导.png" alt="avatar"><br>在某个时刻对W或是U的偏导，需要追溯这个时刻之前的所有时刻的信息，那么这个求导的工作将会非常的复杂。但是有规律可循，可以写出L在t时刻对W和U偏导数的通式：<br><img src="/images/RNN求导简化.png" alt="avatar"><br>整体的偏导公式就是将其按时刻再一一加起来。<br>激活函数是嵌套在求导里面的，如果把激活函数放进去，拿出中间累乘的部分：<br><img src="/images/梯度消失和梯度爆炸.png" alt="avatar"><br>累乘会导致激活函数导数的累乘，进而会导致梯度消失和梯度爆炸的现象发生。</p><p>但是RNN具有以下的局限性：</p><ul><li>当时间间隔不断增大的时候，RNN会丧失学习到连接如此远的信息的能力。理论上RNN可以处理长期依赖的关系，人们可以仔细挑选参数来解决这类问题中的最初形式，但是在实践中，RNN肯定不能成功的学习到这些知识。RNN会受到短时记忆的影响。如果一条序列足够长，那它们将很难从将信息从较早的时间步传送到后面的时间步。<br>因此如果正在1尝试处理一段文本进行预测，RNN可能从一开始就会遗漏重要的信息，在反向传播期间，RNN可能会面临梯度消失的问题。因为梯度用于更新神经网络的权重值，梯度会随着时间的推移不断下降减少，当梯度变得非常小的时候，就不会再学习。在递归的神经网络中，获得小梯度更新的层会停止学习，通常是较早的层。由于这些层不学习，RNN可以忘记它在较长的序列中看到的内容，因此具有短时记忆。而梯度爆炸则是因为计算的难度越来越复杂导致。</li></ul><h2 id="LSTM模型"><a href="#LSTM模型" class="headerlink" title="LSTM模型"></a>LSTM模型</h2><p>LSTM(Long short-term memory)长短期记忆网络是RNN的一种变体，通过巧妙的门控制将加法运算带入到网络中，缓解了RNN的问题。LSTM模型图如下所示：<br><img src="/images/LSTM模型图.png" alt="avatar"><br>图形的具体含义如下：<br><img src="/images/具体含义.png" alt="avatar"></p><ul><li>黄色的矩形是学习得到的神经网络层</li><li>粉色的圆形表示一些基本操作，如加法乘法</li><li>黑色的单箭头表示向量的传输</li><li>两个箭头合成一个表示向量的连接</li><li>一个箭头分开表示向量的复制</li></ul><h3 id="LSTM的核心思想"><a href="#LSTM的核心思想" class="headerlink" title="LSTM的核心思想"></a>LSTM的核心思想</h3><p>LSTM的关键就是细胞状态1，水平线在图上方贯穿运行。细胞状态类似于传送带，直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。<br><img src="/images/LSTM流传.png" alt="avatar"><br>LSTM有通过精心设计的称作“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息有选择的通过的方法，它们包含一个sigmoid神经曾和一个pointwise乘法操作。<br><img src="/images/门函数.png" alt="avatar"><br>sigmoid输出0-1之间的数值，描述每个部分有多少量可以通过，0代表不允许通过，1代表允许1任何通过，LSTM有三个门，来保护和控制细胞状态。</p><h4 id="什么信息会被丢弃？"><a href="#什么信息会被丢弃？" class="headerlink" title="什么信息会被丢弃？"></a>什么信息会被丢弃？</h4><p>这个地方要用到第一个门：遗忘门。该门会读取前一个隐藏层的h_t-1和当前输入x_t，输出一个在0-1之间的数值给每个细胞状态C_t-1中的数字。1表示“完全保留”，0表示“完全舍弃”。<br><img src="/images/LSTM丢弃层.png" alt="avatar"><br>首先，怎么做到遗忘？<br>“遗忘”可以理解为“之前的内容记住多少”，其精髓在于只能输出(0,1)小数的sigmoid函数和粉色圆圈的乘法，LSTM网络通过学习决定让网络记住以前百分之多少的内容。<br>其次，为啥要遗忘还要接受新的xt？<br>因为决定记住什么遗忘什么，其中新的输入肯定要产生影响。</p><h4 id="什么新的消息会被存放在细胞状态中？"><a href="#什么新的消息会被存放在细胞状态中？" class="headerlink" title="什么新的消息会被存放在细胞状态中？"></a>什么新的消息会被存放在细胞状态中？</h4><p>这个就叫做“输入门”，包含两个部分：（1）sigmoid层称“输入门层”决定什么值将被更新。（2）tanh层创建一个新的候选值向量，Ct，会被加入到状态中。<br><img src="/images/输入门.png" alt="avatar"><br>现在将要更新新旧细胞状态，Ct-1更新为Ct。把旧状态与ft相乘，丢弃掉我们确定需要丢弃的信息。接着加上it*Ct，这就是新的候选值，根据我们决定更新每个每个状态的程度进行变化。sigmoid函数选择更新内容，tanh函数创建更新候选。<br><img src="/images/输入门.png" alt="avatar"><br>最终，需要确定输出什么值，这个输出将会基于细胞状态，但是也是一个过滤后的版本。首先，运行一个sigmoid层来确定细胞状态的哪个部分会被输出出去。接着，把细胞状态通过tanh进行处理(得到一个-1到1之间的值)<br><img src="/images/输出门.png" alt="avatar"><br>这三个门虽然功能上不同，但在执行任务上的操作时相同的，都是使用sigmoid函数作为选择工具，tanh作为变换工具，这两个函数结合起来实现三个门的功能。</p><h4 id="LSTM的变体"><a href="#LSTM的变体" class="headerlink" title="LSTM的变体"></a>LSTM的变体</h4><p><img src="/images/LSTM变体1.png" alt="avatar"><br>增加了peephole<br>另一种变体时通过使用coupled忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。仅仅会当将要输入在当前位置时忘记。我们仅仅输入新的值到那些我们已经忘记旧的信息的那些状态。<br><img src="/images/LSTM变体2.png" alt="avatar"><br>另一个改动较大的变体是 Gated Recurrent Unit (GRU)，这是由 Cho, et al. (2014) 提出。它将忘记门和输入门合成了一个单一的 更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RNN与LSTM&quot;&gt;&lt;a href=&quot;#RNN与LSTM&quot; class=&quot;headerlink&quot; title=&quot;RNN与LSTM&quot;&gt;&lt;/a&gt;RNN与LSTM&lt;/h1&gt;&lt;h2 id=&quot;RNN模型&quot;&gt;&lt;a href=&quot;#RNN模型&quot; class=&quot;headerlink&quot; title=&quot;RNN模型&quot;&gt;&lt;/a&gt;RNN模型&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Transformer</title>
    <link href="http://yoursite.com/2021/10/11/Transformer/"/>
    <id>http://yoursite.com/2021/10/11/Transformer/</id>
    <published>2021-10-10T16:54:11.000Z</published>
    <updated>2021-10-10T09:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Transformer&quot;&gt;&lt;a href=&quot;#Transformer&quot; class=&quot;headerlink&quot; title=&quot;Transformer&quot;&gt;&lt;/a&gt;Transformer&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络</title>
    <link href="http://yoursite.com/2021/10/06/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2021/10/06/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2021-10-05T21:25:16.000Z</published>
    <updated>2021-10-07T16:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1. 图的基本概念"></a>1. 图的基本概念</h1><a id="more"></a><ul><li>连通图：对于一个无向图，如果任意的结点i能够通过一些结点边到达结点j，称之为连通图</li><li>非连通图：对于一个无向图，如果任意的结点i不能够通过一些结点边到达结点j，称之为非连通图</li><li>连通分量：无向图G的一个极大连通子图称为G的一个连通分量。连通图只有一个连通分量，即其自身，非连通图有多个连通分量。</li><li>强连通图：给定有向图G(V,E)，并且给定该图G中的任意两个结点u和v，如果结点u和结点v互相可达，那么就称该有向图G是强连通图。</li><li>弱连通图：若至少有一对结点不满足单向连通，但去掉边的方向后从无向图的观点看是连通图，则D称为弱连通图。</li><li>图直径：图中两两结点的最短路径的最大值。</li></ul><h1 id="2-Graph-Embedding"><a href="#2-Graph-Embedding" class="headerlink" title="2. Graph Embedding"></a>2. Graph Embedding</h1><h2 id="2-1-deepwalk算法"><a href="#2-1-deepwalk算法" class="headerlink" title="2.1 deepwalk算法"></a>2.1 deepwalk算法</h2><p>deepwalk的方法是参考了word2vec的思路的，将一个图作为输入，并产生一个潜在的表示(将图中的每个节点表示为一个向量)作为输出。<br>对于图结构来说，算法设计要满足以下几个要求：<br>1.适应性：社交网络是不断变化的，当网络发生变化不能对整个网络重新进行计算<br>2.社区意识：节点的潜在表示对应着维度空间中的距离，应该表示网络中对应的成员的相似度，以保证网络的同质性<br>3.低维：当被标记的成员很少时，低维的模型一般表现得更好，并且收敛性和推理速度更快<br>4.连续性：需要通过图的潜在表示对连续空间中的部分社区成员进行建模。除了提供对社区成员资格的细微视图之外，连续表示还可以使社区之间的决策界限平滑，从而实现更强大的分类</p><p>算法的流程：<br>1.展示用户行为序列<br>2.基于这些用户行为序列构建了物品相关图，图中的边是由用户行为产生的<br>3.采用随机游走的方式随机游走的方式随机选择起始点，产生局部物品序列<br>4.将这些物品序列当做初始句子进行word2vec建模，生成最终的物品embedding向量</p><p>random walk是从截断的随机游走序列中得到的网络局部信息，并以此来学习节点的向量表示。借助语言模型word2vec中的skip-gram模型来学习节点的向量表示。将网络中的结点作为语言模型中的单词，而结点的序列(随机游走得到)模拟为语言中的句子，作为skip-gram的输入。</p><p>优点：<br>1.并行性：同时进行多个随机游走<br>2.适应性：当图变化时，不需要全局重新计算，可以迭代的更新学习模型，适合online learning</p><ul><li>deepwalk算法架构<br><img src="/images/DeepWalk.png" alt="avatar"></li></ul><p>SkipGram是一个语言模型，用于最大化句子中出现在窗口w内的单词之间的共现概率。使用独立性假设，最后条件概率为：<br><img src="/images/SkipGram条件概率.png" alt="avatar"></p><p>对序列中的每个顶点，计算条件概率，即该结点出现的情况下序列中其他节点出现的概率的log值，借助随机梯度下降算法更新该结点的向量表示：<br><img src="/images/SkipGram更新.png" alt="avatar"></p><h2 id="2-2-line算法"><a href="#2-2-line算法" class="headerlink" title="2.2 line算法"></a>2.2 line算法</h2><h3 id="Line的原理介绍"><a href="#Line的原理介绍" class="headerlink" title="Line的原理介绍"></a>Line的原理介绍</h3><p>这里与deepwalk不一样的方法是作者考虑了两个方面：一阶相似性和二阶相似性。<br>(1) 一阶相似性<br>一阶相似性就是指图中两个结点有边相连接，边的权重衡量的就是两个结点的相似程度，假设我们定义两个结点的联合概率是:<br><img src="/images/一阶相似性.png" alt="avatar"><br>而又知道其对应的经验概率是：<br><img src="/images/一阶相似性的经验概率.png" alt="avatar"><br>利用KL散度的公式并且忽略掉一些常数之后，可以定义一阶相似性的损失函数为：<br><img src="/images/一阶相似性的损失函数.png" alt="avatar"></p><p>(2) 二阶相似性<br>假如两个结点他们的邻居很相似，我们则称这两个结点二阶相似。定义两个接地那的条件概率是：“<br><img src="/images/二阶相似性.png" alt="avatar"><br>要对比两个结点的二阶相似性，其实对比的就是两个结点的条件概率分布的相似性。只要能够保证所有结点的条件概率和经验条件概率一致，那么这个embedding就可以很好地保存这两个结点的二阶相似性。<br><img src="/images/对比二阶相似性.png" alt="avatar"><br>得到二阶的损失函数为：<br><img src="/images/二阶相似性的损失函数.png" alt="avatar"><br>在现实中，一般采用负彩样的方法进行训练，即：<br><img src="/images/负采样.png" alt="avatar"></p><p>(3)结合一阶相似性和二阶相似性<br>将一阶相似性训练得到的embedding和二阶相似性训练得到的embedding拼接起来，就是最终的embedding形式。</p><h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><p>(1) 我们会可以看到不管是一阶还是二阶的时候，损失函数每条边都有个weight，为了加速模型收敛，训练的时候可以对边采取抽样的方式生成训练样本，每条边被抽中的概率为边的权重。<br>(2) 对于邻居很少的结点，我们可以将结点邻居的邻居作为该结点的邻居，对应的权重为：<br><img src="/images/邻居很少的结点.png" alt="avatar"><br>然后将结点的权重进行排序，取出topN。</p><h2 id="2-3-node2vec算法"><a href="#2-3-node2vec算法" class="headerlink" title="2.3 node2vec算法"></a>2.3 node2vec算法</h2><p>要设计的网络表示学习算法的目标必须满足以下两点：<br>1.同一个社区内的结点表示类似<br>2.拥有类似结构特征的结点表示相似</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>该方法的损失函数是：<br><img src="/images/node2vec的损失函数.png" alt="avatar"><br>为了让结果更容易计算，引入了skip-gram中的两个假设：</p><ol><li>条件独立，即采样每个邻居是相互独立的，所以如果要计算采样所有邻居的概率只需要将采样每个邻居的概率相乘就好了，公式化表达就是：<br><img src="/images/采样所有邻居的概率.png" alt="avatar"></li><li>特征空间的对称性。假设一条边连接了a和b，那么映射到特征空间时，a对b的影响和b对a的影响是一样的。用一个模型来表示一个(结点，邻居)对：<br><img src="/images/结点邻居对.png" alt="avatar"><br>将上面的三个公式结合起来得到最终的优化结果：<br><img src="/images/node2vec优化结果.png" alt="avatar"><br>注意：<br>1.Zu直接计算特别费时，本文使用的是负采样的方式<br>2.Ns(u)未必是u的直接邻居，只是用s方法采样得到的邻居，跟具体的采样方法有关</li></ol><p>复杂网络处理的任务其实离不开两种特性，一种是同质性也就是社区，另一种是结构相似性。结构相似的两个点未必相连，可以是相距很远的两个结点。深度优先游走(DFS)和广度优先游走(BFS)是两种随机游走的方式。BFS倾向于在结点的初始结点的周围游走，可以反映出一个结点的邻居的微观特性；而DFS一般会跑的离初始结点越来越远，可以反映出一个结点邻居的宏观特性。<br>node2vec的随机游走产生的方式是：<br><img src="/images/node2vec随机游走.png" alt="avatar"><br>对于一个随机游走，如果已经采样了(t,v)，也就是说现在停留在结点v上，那么下一个要采样的结点是哪个？作者定义了一个概率分布，也就是一个结点到它不同邻居结点的转移概率：<br><img src="/images/node2vec随机游走转移概率.png" alt="avatar"></p><ul><li>如果t和x相等，那么采样x的概率系数是1/p</li><li>如果t和x相连，那么采样x的概率系数是1</li><li>如果t和x不相连，那么采样x的概率系数是1/q</li></ul><p>参数p、q的意义分别如下：<br>返回概率p：</p><ul><li>如果p &gt; max(q,1)，那么采样会尽量不往回走，对应上图的情况，就是下一个节点不太可能是上一个访问的结点t</li><li>如果p &lt; min(q,1)，那么采样会更倾向于返回上一个结点，这样会一直在起始点周围某些结点来回转来转去。<br>出入参数：</li><li>如果q &gt; 1，那么游走会倾向于在起始点周围的结点之间跑，可以反映一个结点的BFS特征。</li><li>如果q &lt; 1，那么游走会倾向于往远处跑，反映出DFS特性。<br>当 p = 1 , q = 1 时，游走方式就等同于DeepWalk中的随机游走。<br>q是用来控制模型是DFS还是BFS</li></ul><h3 id="node2vec算法流程"><a href="#node2vec算法流程" class="headerlink" title="node2vec算法流程"></a>node2vec算法流程</h3><p><img src="/images/node2vec算法.png" alt="avatar"></p><ol><li>根据p、q和之前的公式计算一个结点到它邻居的转移概率</li><li>将这个转移概率加到图G中形成G’</li><li>walks用来存储随机游走，先初始化为空</li><li>外循环r次表示每个节点作为初始结点要生成r个随机游走</li><li>然后对图中每个节点</li><li>生成一条随机游走walk</li><li>将walk添加到walks中保存</li><li>然后使用SGD方法对walks进行训练</li></ol><p>第6步中一条walk的生成方式如下：</p><ol><li>将初始节点u添加进去</li><li>walk的长度与为l，因此还要再循环添加l-1个结点</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-图的基本概念&quot;&gt;&lt;a href=&quot;#1-图的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 图的基本概念&quot;&gt;&lt;/a&gt;1. 图的基本概念&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CNN网络</title>
    <link href="http://yoursite.com/2021/10/01/CNN%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2021/10/01/CNN%E7%BD%91%E7%BB%9C/</id>
    <published>2021-09-30T19:21:38.000Z</published>
    <updated>2021-09-30T12:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>CNN网络的卷积与数学的卷积是不一样的，CNN的卷积是相关运算</li><li>CNN不用数学的卷积是因为翻转需要增加计算量，而翻转与不翻转并不会改变信息量</li><li>CNN网络中输出矩阵的尺寸是：(N - Kernel_size)/stride + 1</li><li>输入N个通道，输出M个通道，滤波器的数量为M*N</li><li>池化的两个参数：kernel_size和stride</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;CNN网络的卷积与数学的卷积是不一样的，CNN的卷积是相关运算&lt;/li&gt;
&lt;li&gt;CNN不用数学的卷积是因为翻转需要增加计算量，而翻转与不翻转并不会改变信息量&lt;/li&gt;
&lt;li&gt;CNN网络中输出矩阵的尺寸是：(N - Kernel_size)/stride + 
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tranformer</title>
    <link href="http://yoursite.com/2021/09/30/tranformer/"/>
    <id>http://yoursite.com/2021/09/30/tranformer/</id>
    <published>2021-09-30T08:41:51.000Z</published>
    <updated>2021-09-30T00:41:52.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>有意思的算法题</title>
    <link href="http://yoursite.com/2021/09/09/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/09/09/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</id>
    <published>2021-09-09T10:47:12.000Z</published>
    <updated>2021-12-06T03:07:06.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-318-最大单词长度乘积"><a href="#LeetCode-318-最大单词长度乘积" class="headerlink" title="LeetCode 318.最大单词长度乘积"></a>LeetCode 318.最大单词长度乘积</h1><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这里直接用哈希表，分词的话那么会很麻烦，所以这里使用的是移位的思想。首先用一个数组来存储每一个对应的字符串到底出现了哪个单词（这里并不需要记录出现的次数，因为只要找出两个没有公共字母的单词）。这里如何记录是否出现呢？可以用一个26位的二进制数，1表示对应位置的字母出现了。那么如何记录呢？那就是以下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">    hash[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随后就可以遍历两两组合，相与为零的二进制数就是不重复的单词。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> maxProduct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/01/31/20:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 最大单词长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String[] words = &#123;<span class="string">"abcw"</span>,<span class="string">"baz"</span>,<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"xtfn"</span>,<span class="string">"abcdef"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = solution.maxProduct(words);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 全是小写字母，可以用一个32为整数表示word中出现的字母，</span></span><br><span class="line"><span class="comment">         * hash[i]存放第i个单词出现过的字母，a对应32位整数的最后一位</span></span><br><span class="line"><span class="comment">         * b对应整数的倒数第二位，以此类推</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用移位1来记录出现了哪一位字符，一共最多32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                hash[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hash[i] &amp; hash[j]) == <span class="number">0</span>)</span><br><span class="line">                    max = Math.max(words[i].length()*words[j].length(),max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-43-字符串相乘"><a href="#LeetCode-43-字符串相乘" class="headerlink" title="LeetCode 43.字符串相乘"></a>LeetCode 43.字符串相乘</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>如果num1和num2之一是0，则直接将0作为结果返回即可</li><li>如果num1和num2都不是0，则可以通过模拟竖式乘法的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。<br><img src="/images/字符串相乘.png" alt="avatar"></li></ul><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiply;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/05/09/9:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String s = solution.multiply(<span class="string">"222"</span>, <span class="string">"53"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            StringBuffer curr = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                curr.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> y = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = x * y + add;</span><br><span class="line">                curr.append(product % <span class="number">10</span>);</span><br><span class="line">                add = product / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">                curr.append(add % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = addStrings(ans, curr.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-No166-分数到小数"><a href="#LeetCode-No166-分数到小数" class="headerlink" title="LeetCode No166.分数到小数"></a>LeetCode No166.分数到小数</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 任意一个 。</p><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>这里要用到的一个容器就是哈希表，当然哈希表键值对是用来存储除数得到的余数的10倍是否出现过，用的就是长除法的思想。每一次除不下的时候我们要考虑的是补零，若补零之后出现的整数之前出现过在哈希表中，那么可以肯定的是从这一位开始就要产生一个循环。那么这样就可以得到一个循环的结束条件。</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">long</span> a = numerator,b = denominator;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> || a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>)</span><br><span class="line">            sb.append(<span class="string">'-'</span>);</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        sb.append(a/b);</span><br><span class="line">        <span class="keyword">if</span> (a % b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        sb.append(<span class="string">'.'</span>);</span><br><span class="line">        HashMap&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((a = (a % b) * <span class="number">10</span>) &gt; <span class="number">0</span> &amp;&amp; !map.containsKey(a))&#123;</span><br><span class="line">            map.put(a,sb.length());</span><br><span class="line">            sb.append(a / b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        <span class="keyword">return</span> sb.insert(map.get(a).intValue(),<span class="string">'('</span>).append(<span class="string">')'</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-No29-不使用除法运算符计算除法"><a href="#LeetCode-No29-不使用除法运算符计算除法" class="headerlink" title="LeetCode No29.不使用除法运算符计算除法"></a>LeetCode No29.不使用除法运算符计算除法</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>不使用除法运算符，进行除法的计算，返回的结果是除数取整的结果</p><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>不使用除法运算符，得到整数除法的求余结果</li><li>考虑的是移位法，可以先把一个被除数除以2^n，n的初始值为31</li><li>不断减少n去试探，当某个n满足被除数/2^n&gt;=divisor时</li><li>表示找到了一个足够大的数，这个数*除数是不大于被除数的，所以可以减去2^n个除数</li></ul><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> divide;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/10/12/8:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> divide = solution.divide(-<span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(divide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不使用除法运算符，得到整数除法的求余结果</span></span><br><span class="line"><span class="comment">         * 考虑的是移位法，可以先把一个被除数除以2^n，n的初始值为31</span></span><br><span class="line"><span class="comment">         * 不断减少n去试探，当某个n满足被除数/2^n&gt;=divisor时</span></span><br><span class="line"><span class="comment">         * 表示找到了一个足够大的数，这个数*除数是不大于被除数的，所以可以减去2^n个除数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> negative;</span><br><span class="line">        negative = (dividend ^ divisor) &lt; <span class="number">0</span>;<span class="comment">//用相与来计算是否符号相异</span></span><br><span class="line">        <span class="keyword">long</span> t = Math.abs((<span class="keyword">long</span>) dividend);</span><br><span class="line">        <span class="keyword">long</span> d = Math.abs((<span class="keyword">long</span>) divisor);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;&gt; i) &gt;= d)&#123;</span><br><span class="line">                <span class="comment">//找出足够大的2^n*divisor</span></span><br><span class="line">                result += <span class="number">1</span> &lt;&lt; i;<span class="comment">//将结果加上2^n</span></span><br><span class="line">                t -= d &lt;&lt; i;<span class="comment">//将被除数减去2^n*divisor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? - result : result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-318-最大单词长度乘积&quot;&gt;&lt;a href=&quot;#LeetCode-318-最大单词长度乘积&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 318.最大单词长度乘积&quot;&gt;&lt;/a&gt;LeetCode 318.最大单词长度乘积&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>tensor知识</title>
    <link href="http://yoursite.com/2021/09/07/tensor%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2021/09/07/tensor%E7%9F%A5%E8%AF%86/</id>
    <published>2021-09-07T11:45:29.000Z</published>
    <updated>2021-09-07T03:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Tensor简介"><a href="#Tensor简介" class="headerlink" title="Tensor简介"></a>Tensor简介</h1><ol><li>什么是tensor</li></ol><p>scalar(标量)：一个数值<br>vector(向量)：一维数组<br>matrix(矩阵)：二维数组<br>tensor(张量)：多维数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Tensor简介&quot;&gt;&lt;a href=&quot;#Tensor简介&quot; class=&quot;headerlink&quot; title=&quot;Tensor简介&quot;&gt;&lt;/a&gt;Tensor简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是tensor&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="pytorch学习" scheme="http://yoursite.com/tags/pytorch%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常用的十种算法</title>
    <link href="http://yoursite.com/2021/08/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%81%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/08/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%81%E7%A7%8D%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-12T09:48:46.000Z</published>
    <updated>2021-12-06T03:08:16.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的十种算法"><a href="#常用的十种算法" class="headerlink" title="常用的十种算法"></a>常用的十种算法</h1><a id="more"></a><h1 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1.二分查找算法"></a>1.二分查找算法</h1><p>二分查找有两种思想：一种是递归的思想，另一种是非递归的思想。</p><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法一：使用递归的方式</span></span><br><span class="line">        <span class="comment">//递归的方式就是首先找到中间位置，如果大于，那么往前找，否则往后找</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch(arr,mid + <span class="number">1</span>,end,target);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch(arr,start,mid - <span class="number">1</span>,target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>非递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; arr[mid])&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-分治算法"><a href="#2-分治算法" class="headerlink" title="2.分治算法"></a>2.分治算法</h2><p>分治算法的思想是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或者相似的子问题，再把子问题分成更小的子问题…直到最后子问题可以简单地直接求解，原问题的解即为子问题的解的合并。</p><ul><li>分治算法的基本步骤<br>1.分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题<br>2.解决：将子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>3.将各个子问题的解合并为原问题的解</li></ul><p>eg. 汉诺塔问题<br>1) 如果是有一个盘，A-&gt;C<br>如果我们有n&gt;=2的情况，我们总是可以看做是两个盘：1.最下边的盘 2.上面的盘</p><p>1.先把最上面的盘A-&gt;B<br>2.把最下边的盘A-&gt;C<br>3.把B塔所有的盘从B-&gt;C</p><p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DividedandConquer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/08/12/10:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 分治算法解决汉诺塔问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoTower(<span class="number">5</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//汉诺塔的移动方案</span></span><br><span class="line">    <span class="comment">//使用分治算法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoTower</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span>+a+<span class="string">"-&gt;"</span>+c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有n&gt;=2的情况，我们总是可以看做是两个盘，一个是最下边的盘，加上上面所有的盘</span></span><br><span class="line">            <span class="comment">//1.先把最上面所有的盘A-&gt;B,移动过程用到c</span></span><br><span class="line">            hanoTower(num - <span class="number">1</span>,a,c,b);</span><br><span class="line">            <span class="comment">//2.把最下边的盘A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span>+num+<span class="string">"个盘从"</span>+a+<span class="string">"-&gt;"</span>+c);</span><br><span class="line">            <span class="comment">//把B塔的所有盘B-&gt;C，移动过程中使用到A盘</span></span><br><span class="line">            hanoTower(num - <span class="number">1</span>,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3.动态规划算法"></a>3.动态规划算法</h2><ul><li>简要介绍<br>1.动态规划算法的核心是：将大问题划分为小问题进行解决，进而一步步获取最优解的处理算法<br>2.动态规划算法与分治算法类似，其基本思想也是将待求解问题分解为若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<br>3.与分治算法不同的是，适用于用动态规划求解的问题，经分解得到子问题往往不是相互独立的，即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解。<br>4.动态规划可以通过填表的方式来逐步求解最优解。</li></ul><ul><li>动态规划解决背包问题<br>算法主要思想：每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：<br>(1)v[i][0] = v[0][j] = 0//表示填入表第一行和第一列是0<br>(2)当w[i] &gt; j时：v[i][j] = v[i - 1][j]//当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略<br>(3)当j&gt;=w[i]时：v[i][j] = max{v[i - 1][j],v[i - 1][j - w[i]] + v[i]}</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用的十种算法&quot;&gt;&lt;a href=&quot;#常用的十种算法&quot; class=&quot;headerlink&quot; title=&quot;常用的十种算法&quot;&gt;&lt;/a&gt;常用的十种算法&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性判别分析LDA</title>
    <link href="http://yoursite.com/2021/08/04/%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90LDA/"/>
    <id>http://yoursite.com/2021/08/04/%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90LDA/</id>
    <published>2021-08-03T16:20:41.000Z</published>
    <updated>2021-08-03T08:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LDA思想"><a href="#LDA思想" class="headerlink" title="LDA思想"></a>LDA思想</h1><p>LDA的思想是将数据在低纬度上进行投影，投影后希望每一种数据的投影点尽可能接近，而不同类别的数据中心之间的距离尽可能的大。</p><h1 id="瑞利商-Rayleigh-quotient-与广义瑞利商-generalized-Rayleigh-quotient"><a href="#瑞利商-Rayleigh-quotient-与广义瑞利商-generalized-Rayleigh-quotient" class="headerlink" title="瑞利商(Rayleigh quotient)与广义瑞利商(generalized Rayleigh quotient)"></a>瑞利商(Rayleigh quotient)与广义瑞利商(generalized Rayleigh quotient)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LDA思想&quot;&gt;&lt;a href=&quot;#LDA思想&quot; class=&quot;headerlink&quot; title=&quot;LDA思想&quot;&gt;&lt;/a&gt;LDA思想&lt;/h1&gt;&lt;p&gt;LDA的思想是将数据在低纬度上进行投影，投影后希望每一种数据的投影点尽可能接近，而不同类别的数据中心之间的距离尽可能
      
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2021/07/20/%E5%9B%BE/"/>
    <id>http://yoursite.com/2021/07/20/%E5%9B%BE/</id>
    <published>2021-07-20T15:39:42.000Z</published>
    <updated>2021-12-06T03:09:24.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h1><a id="more"></a><p>图是一种数据结构，其中结点可以具有零个或者多个相邻元素。两个结点之间的连接称为边，结点也可以称为顶点。线性表局限于直接前驱和一个直接后继的关系，树叶只能有一个直接前驱也就是父节点，当我们需要表示多对多的关系时，就需要图这一数据结构。</p><ul><li><p>图的表示方式：二维数组表示(邻接矩阵)；链表表示(邻接表)。</p></li><li><ol><li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间的一定损失。</li></ol></li><li><ol><li>邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成。</li></ol></li></ul><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>图的遍历就是对结点的访问，一个图有很多结点，需要特定的策略来遍历结点，一般有两种方法：(1)深度优先遍历 (2)广度优先遍历</p><h2 id="1-深度优先遍历思想："><a href="#1-深度优先遍历思想：" class="headerlink" title="(1) 深度优先遍历思想："></a>(1) 深度优先遍历思想：</h2><p>1) 深度优先遍历，从初始访问结点开始，初始访问结点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始结点，访问它的第一个邻接节点，可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一个邻接节点。<br>2) 我们可以看到，这样的访问策略是有限往纵向挖掘深入，而不是对一个结点的所有邻接节点进行横向访问。<br>3) 显然，深度优先搜索是一个递归过程。</p><ul><li>深度优先遍历算法步骤<br>1) 访问初始结点v，并标记结点v为已访问。<br>2) 查找结点v的第一个邻接节点w。<br>3) 若w存在，则继续执行4，若w不存在，则回到第一步，将从v的下一个节点继续。<br>4) 若w未被访问，对w进行深度优先遍历递归(即把w当做另一个v，然后进行步骤123)。<br>5) 查找结点v的w邻接节点的下一个邻接节点，转到步骤3.</li></ul><h2 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="(2) 广度优先遍历"></a>(2) 广度优先遍历</h2><p>图的广度优先搜索类似于一个分层搜索过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接节点。</p><ul><li>广度优先遍历算法步骤<br>1) 访问初始结点v并标记结点v为已访问<br>2) 结点v入队列<br>3) 当队列非空时，继续执行，否则算法结束<br>4) 出队列，取得队头结点u<br>5) 查找结点u的第一个邻接节点w<br>6) 若结点u的邻接节点w不存在，则转到步骤3，否则循环执行以下三个步骤：<br>6.1 若结点w尚未被访问，则访问结点w并标记为已访问<br>6.2 结点w入队列<br>6.3 查找结点u的继w邻接节点的下一个邻接节点w，转到步骤6</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图的基本介绍&quot;&gt;&lt;a href=&quot;#图的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;图的基本介绍&quot;&gt;&lt;/a&gt;图的基本介绍&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>多叉树</title>
    <link href="http://yoursite.com/2021/07/07/%E5%A4%9A%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2021/07/07/%E5%A4%9A%E5%8F%89%E6%A0%91/</id>
    <published>2021-07-07T10:06:14.000Z</published>
    <updated>2021-12-06T03:09:38.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树存在的问题"><a href="#二叉树存在的问题" class="headerlink" title="二叉树存在的问题"></a>二叉树存在的问题</h1><a id="more"></a><ul><li><p>二叉树需需要加载到内存，如果二叉树的结点很多就会出现如下问题：<br>(1) 在构建二叉树时，需要多次进行I/O操作，结点海量，构建二叉树时，速度有影响<br>(2) 结点海量，也会造成二叉树的高度很大，会降低操作速度</p></li><li><p>多叉树<br>(1) 在二叉树中，每个节点有数据项，最多有两个结点。如果允许每个接地那可以有更多的数据项和更多的结点，那就是多叉树。<br>(2) 多叉树通过重新组织结点，减少树的高度，能对二叉树进行优化。<br>(3) B树通过重新组织结点，降低了树的高度<br>(4) 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页(页的大小通常是4K)，这样每个节点只需要一次I/O就可以完全载入<br>(5) 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树广泛用于文件存储系统以及数据库系统中。</p></li></ul><h1 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h1><p>2-3树是最简单的B树结构，具有如下特点：<br>(1) 2-3树的所有结点都在同一层(只要是B树都满足这个条件)<br>(2) 有两个子结点的结点叫做二节点，二节点要么没有子结点要么有两个子结点<br>(3) 有三个子结点的结点叫做三节点，三节点要么没有子结点要么有三个子结点<br>(4) 2-3树是由二节点和三节点构成的树</p><ul><li><p>2-3树的插入规则<br>(1) 2-3树的所有叶子结点都在同一层(只要是B树均满足这个条件)<br>(2) 有两个子结点的结点叫做二节点，二节点要么没有子结点要么有两个子结点<br>(3) 有三个子结点的结点叫做三节点，三节点要么没有子结点要么有三个子结点<br>(4) 当按照规则插入一个树到某个节点时，不能满足上述三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后需要满足上面三个条件。<br>(5) 对于上三节点的子树的值的大小仍遵守二叉排序树的规则。</p></li><li><p>B树的说明：<br>(1) B树的阶：结点的最多子结点个数。如2-3树的阶是3<br>(2) B-树的搜索，从根结点开始，对结点内的关键字进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子结点<br>(3) 关键字集合分布在整棵树中，即叶子结点和非叶子结点都存放数据<br>(4) 搜索有可能在非叶子结点结束<br>(5) 其搜索心梗等价于在关键字全集内做一次二分查找</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉树存在的问题&quot;&gt;&lt;a href=&quot;#二叉树存在的问题&quot; class=&quot;headerlink&quot; title=&quot;二叉树存在的问题&quot;&gt;&lt;/a&gt;二叉树存在的问题&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2021/07/02/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2021/07/02/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-07-01T16:22:09.000Z</published>
    <updated>2021-12-06T03:09:50.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><a id="more"></a><ul><li>平衡二叉树也叫平衡二叉搜索树，AVL树，可以保证查询效率较高。</li><li>主要特点是：是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两颗子树都是一个平衡二叉树。</li></ul><h2 id="创建一颗平衡二叉树的方法"><a href="#创建一颗平衡二叉树的方法" class="headerlink" title="创建一颗平衡二叉树的方法"></a>创建一颗平衡二叉树的方法</h2><p>怎么处理？—&gt;进行左旋转(降低右子树的高度)</p><ul><li>创建一个新的结点newNode，值等于当前根结点的值</li><li>把新节点的左子树设置为当前节点的左子树。newNode.left = left</li><li>把新节点的右子树设置为当前节点的右子树的左子树。newNode,right = right.left</li><li>把当前节点的值换为右子结点的值。value = right.value</li><li>把当前节点的右子树设置为右子树的右子树。right = right.right</li><li>把当前节点的左子树设置为新节点。left = newLeft。</li></ul><p>进行右旋转(降低左子树的高度)</p><ul><li>创建一个新的结点，其值等于当前节点的值newNode</li><li>把新节点的右子树设置为当前节点的右子树(newNode.right = right)</li><li>把新节点的左子树设置为当前节点的左子树的右子树(newNode.left = left.right)</li><li>把当前节点的值换为左子节点的值(value = left.value)</li><li>把当前节点的左子树设置为左子树的左子树(left = left.left)</li><li>把当前节点的右子树设置为新节点(right = newLeft)</li></ul><h1 id="AVL树双旋转"><a href="#AVL树双旋转" class="headerlink" title="AVL树双旋转"></a>AVL树双旋转</h1><ul><li>当符号右旋转的条件时</li><li>如果它的左子树的右子树高度大于它的左子树的高度</li><li>先对当前这个节点的左结点进行左旋转</li><li>再对当前节点进行右旋转的操作即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/07/01/18:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="comment">//添加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">"中序遍历"</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"未旋转之前的高度："</span>);</span><br><span class="line">        System.out.println(avlTree.getRoot().height());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建AVL树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当做二叉排序树的根结点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的以node为根结点的二叉排序树的最小节点的值</span></span><br><span class="line"><span class="comment">     * 还要删除这个返回的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环查找左结点就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时target就只向了最小节点\\44\\</span></span><br><span class="line">        <span class="comment">//删除最小节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先去找到要删除的结点targetnode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发现这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetnode的父节点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//叶子结点</span></span><br><span class="line">                <span class="comment">//判断targetnode是父节点的左子节点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value)&#123;</span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value)&#123;</span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//删除的结点是两颗树的结点</span></span><br><span class="line">                <span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minVal;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//删除的结点是有一棵子树的结点,排除的是其他的情况</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果targetnode是parent的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value == value)&#123;</span><br><span class="line">                        parent.left = targetNode.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//targetnode是parent的右子结点</span></span><br><span class="line">                        parent.right = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//要删除的结点有右子结点</span></span><br><span class="line">                    <span class="comment">//如果targetnode是parent的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent.left.value == value)&#123;</span><br><span class="line">                        parent.left = targetNode.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//如果targetnode是parent的右子结点</span></span><br><span class="line">                        parent.right = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，则直接让root指向node</span></span><br><span class="line">            root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"此二叉树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前节点的高度，以该结点为根结点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(),right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前节点的左子树</span></span><br><span class="line">        newNode.left = left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        <span class="comment">//把当前节点的值替换为右子结点的值</span></span><br><span class="line">        value = right.value;</span><br><span class="line">        <span class="comment">//把当前节点的右子树设置为当前节点的右子树的右子树</span></span><br><span class="line">        right = right.right;</span><br><span class="line">        <span class="comment">//把当前节点的左子节点(左子树)设置为新的结点</span></span><br><span class="line">        left = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        value = left.value;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//找到节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="comment">//这时候应该向左子树查找</span></span><br><span class="line">            <span class="comment">//如果左子节点为空则停止查找，而且停止查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不小于。则向右查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value)||(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//找到了父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果查找的值小于当前节点的值,并且当前节点左子节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找不到了,没有父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"value="</span> + value +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点值和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//当前节点的左子节点为空</span></span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子结点添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果右子树的高度-左子树的高度&gt;1，施加一个左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; right .rightHeight() &lt; right.leftHeight())&#123;</span><br><span class="line">                <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight())&#123;</span><br><span class="line">                    <span class="comment">//先对右子结点进行右旋转，再对当前节点进行左旋转</span></span><br><span class="line">                    right.rightRotate();</span><br><span class="line">                    left.leftRotate();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    leftRotate();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当添加完一个结点后如果出现左子树的高度-右子树的高度&gt;1，右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; leftHeight())&#123;</span><br><span class="line">                <span class="comment">//先对当前节点的左结点进行左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前节点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://yoursite.com/2021/06/26/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2021/06/26/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</id>
    <published>2021-06-25T20:29:18.000Z</published>
    <updated>2021-12-06T03:10:04.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><a id="more"></a><p>二叉排序树：BST(Binary Sort Tree)，对于二叉排序树的任何一个非叶子结点，要求左子节点的值比当前节点的值小，右子结点的值比当前节点的大。如果有相同的值，可以将该结点放在左子节点或者右子结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BinarySortTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ChrisPeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/25/20:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="comment">//for循环添加节点到排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历二叉树</span></span><br><span class="line">        System.out.println(<span class="string">"中序遍历二插排序树"</span> );</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，则直接让root指向node</span></span><br><span class="line">            root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"此二叉树为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"value="</span> + value +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加节点，需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点值和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//当前节点的左子节点为空</span></span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子结点添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h1><ul><li>情况一：当要删除的结点没有子结点的时候：<br>(1)需要先去找到要删除的结点targetNode<br>(2)找到targetNode的父节点parent<br>(3)确定targetNode是parent的左子节点还是右子结点<br>(4)根据前面的情况对应的删除，左子节点:parent.left = null;右子结点:parent.right = null;</li><li>情况二：删除只有一颗子树的结点<br>(1)首先找到要删除的结点targetNode<br>(2)找到target的父节点parent<br>(3)确定targetNode的子结点是右子结点还是左子节点<br>(4)targetNode是parent的左子节点还是右子结点<br>(5)如果targetNode是parent的左子节点<br>5.1 targetNode的子结点是左子节点，parent.left=targetNode.left<br>5.2 targetNode的子结点是右子节点，parent.left=targetNode.right<br>如果targetNode是parent的右子结点<br>5.3 targetNode的子结点是左子节点，parent.left=targetNode.right<br>5.4 targetNode的子结点是右子节点，parent.right=targetNode.right</li><li>情况三：删除有两颗子树的结点<br>(1)首先找到要删除的结点targetNode<br>(2)找到target的父节点parent<br>(3)从targetNode的右子树找到最小的结点<br>(4)用一个临时变量，将最小的值保存到temp<br>(5)删除最小节点<br>(6)targetNode.value = temp</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>霍夫曼树</title>
    <link href="http://yoursite.com/2021/06/16/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2021/06/16/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91/</id>
    <published>2021-06-16T00:50:48.000Z</published>
    <updated>2021-12-06T03:10:20.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h1><a id="more"></a><p>给定n个权值1作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h1 id="构成哈夫曼树的思路"><a href="#构成哈夫曼树的思路" class="headerlink" title="构成哈夫曼树的思路"></a>构成哈夫曼树的思路</h1><ul><li>从小到大进行排序，将每一个数据，每个数据都是一个结点，每个结点可以看成是一颗最简单的二叉树</li><li>取出根结点权值最小的两颗二叉树</li><li>组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两个二叉树根结点权值的和</li><li>再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中所有数据都被处理，就得到一颗哈夫曼树。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;霍夫曼树&quot;&gt;&lt;a href=&quot;#霍夫曼树&quot; class=&quot;headerlink&quot; title=&quot;霍夫曼树&quot;&gt;&lt;/a&gt;霍夫曼树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2021/06/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/06/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-06-10T09:02:55.000Z</published>
    <updated>2021-12-06T03:10:28.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><a id="more"></a><ol><li>计数，有多少种方式走到右下角，有多少种方式选出k个数使得和为sum</li><li>求最大最小值：最长上升子序列的长度</li><li>求存在性：取石子游戏，先手是否必胜</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>顺序二叉树</title>
    <link href="http://yoursite.com/2021/06/07/%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2021/06/07/%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-06-06T18:52:37.000Z</published>
    <updated>2021-12-06T03:10:38.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h1><a id="more"></a><ul><li>通常只考虑完全二叉树</li><li>第n个元素的左子节点为2*n + 1</li><li>第n个元素的右子结点为2*n + 2</li><li>第n个元素的父节点为(n-1)/2</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;顺序存储二叉树&quot;&gt;&lt;a href=&quot;#顺序存储二叉树&quot; class=&quot;headerlink&quot; title=&quot;顺序存储二叉树&quot;&gt;&lt;/a&gt;顺序存储二叉树&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>周会第一次</title>
    <link href="http://yoursite.com/2021/05/29/%E5%91%A8%E4%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
    <id>http://yoursite.com/2021/05/29/%E5%91%A8%E4%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1/</id>
    <published>2021-05-29T10:30:06.000Z</published>
    <updated>2021-06-02T06:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Structure-Based-User-Identification-across-Social-Networks"><a href="#Structure-Based-User-Identification-across-Social-Networks" class="headerlink" title="Structure Based User Identification across Social Networks"></a>Structure Based User Identification across Social Networks</h1><a id="more"></a><h2 id="摘要概述"><a href="#摘要概述" class="headerlink" title="摘要概述"></a>摘要概述</h2><p>这篇文章介绍的是一种基于结构的用户跨社交网络身份识别模型，目前跨社交网络的可访问性和可靠性大多数基于网络结构，都是需要余弦了解某些特定用户，是受监督或者半监督的。在一些先验知识难以获取的前提下，手工标记先验知识是一项费力的工作。考虑不同的SNs中朋友关系的可靠性和一致性，提出了一种无监督的基于朋友关系的无先验知识用户识别算法(FRUI-P)。算法的思路是：首先将SN中每个用户的好友特征提取为好友特征向量，然后计算两个SNs之间所有相同的候选用户的相似度。最后，提出了一种基于相似度的一对一map识别方法。大量实验结果表明，在没有先验知识的情况下，FRUI-P算法比现有的基于网络结构的算法性能要好得多。由于具有较高的精度，FRUI-P还可以用于生成监督和半监督方案的先验知识。在应用程序中，无监督匿名相同用户识别方法适用于无法获得种子用户的更多场景。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>首先介绍了社交网络SNs的应用，介绍跨社交网络的用途，跨社交用户的建模可以构建全方位的用户刻画，增加更多的信息。接着介绍了用户识别的概念，跨系统用户身份识别已经获得很多的关注。后来着重介绍前人工作，SNs之间的可访问信息变得越来越碎片化、不一致性和破坏性。这些特点使得传统的解决方案被边缘化，引发了对用户识别新技术的需求。单跟随连接中并不是所有的连接都代表着真正的朋友关系。朋友关系(微博之中的相互关联的关系)更加的可靠和一致，因此更适合跨平台的识别任务。<br>在该研究中，作者研究了无监督策略，以纯粹的朋友关系识别SNs中的匿名相同用户。在没有规范的情况下，SN的网络结构表示用户之间的朋友关系，忽略单向连接的关系。虽然该算法在现实社交网络中只能识别一部分相同的用户，但它可以与其他无特征的用户识别算法联合应用，获得更高的性能。</p><p>本研究的贡献：</p><ul><li>提出了一种新的无监督用户识别算法，即基于朋友关系的无先验知识用户识别(FRUI-P)。它从网络结构中提取每个用户的多维特征，然后从多维特征中评估两个不同SNs中任意两个用户的相似性。与大多数现有方案不同的是，FRUI-P可以在没有显眼只是的情况下识别相同的用户，并为监督和半监督算法提供先验知识。</li><li>结合环境呈现朋友特征学习的过程。受Word2Vec在自然语言处理的启发，提出了一个利用随机游走能力的朋友特征向量模型(FFVM)，虽然Word2Vec在测量任意两个词之间的相似度方面得到了广泛地应用，但是在无监督跨平台任务中的表现尚不清楚。</li><li>讨论了FRUI-P的效率以及在FRUI-P中确保用户识别性能的策略。证明了FRUI-P在运行时间上比NM(neighbor matching)高效的多。引入三个参数来提高性能，引入一个参数来保证FRUI-P的精度。</li><li>基于中国的三大合成网络和两个主要的SNs：新浪和人人，对FRUI-P的性能进行了具体的演示。合成的网站包括(erdos renyi ER) 随机网络、Watts-Strogatz(WS)小型世界网络和Barabasi-Albert优先关联模型网站(BA)。</li></ul><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><ul><li>SN = {U,F}，U表示用户集，F表示朋友关系集合，SN表示社交网络，<script type="math/tex">SN^A={U^A,F^A}</script>表示社交网络A，SN被建模成一个无向图，其中结点和边分别是用户和朋友的关系。在论文中上标表示与SN相关的变量(或符号)，下标为SN中的用户。<br><script type="math/tex">U^A_i</script>表示<script type="math/tex">SN^A</script>中的用户i。具体的术语表示如下图：<br><img src="/images/周会1变量表示图.png" alt="avatar"></li><li><p>定义1：候选相同用户对</p><script type="math/tex; mode=display">U^A_i$$和$$U^B_j$$来自两个不同的社交网络$$SN^A$$和$$SN^B$$形成了候选的相同用户对，记为![avatar](/images/周会1用户对.png)I(.,.)表示所有的用户对，I($$U^A_i$$,.)表示所有的包括社交网络A上的用户i的候选相同用户对。$$|U^A|x|U^B|$$的候选相同用户对存在于I(.,.),$$|U^B|$$存在于$$I(U^A_i)</script></li><li><p>定义2：相同用户<br>对于任意的I(<script type="math/tex">U^A_i,U^B_j</script>)，如果在现实生活中<script type="math/tex">U^A_i</script>和<script type="math/tex">U^B_j</script>属于同一个用户，那么这俩就是同一用户，认为他们相等。</p></li><li><p>定义3：上下文<br>Ui在社交网络中的上下文文本定义为Ci或者C(Ui)，<br>在研究中，使用随机游走来模拟用户的情景。由于一个用户可能在一个或多个随机游走中出现多次，因此一个用户可能有多个上下文。我们预测Ui有着更高的概率预测Ui而有着更低的概率预测Uj。</p></li><li>定义4：良性抽样<br>在一个社交网络中，对于一个给定的Ci,(Ci,Ui)是一个良性的sample。所有的正样本构成正样本集S</li><li>定义5：负用户集，负样本<br>与正样本的定义相反，除Ui外的其他用户，记做Ni或者N(Ui)被定义为Ci的负用户集，因此Ni=U-{Ui}，对于任意的用户Uj属于Ni,(Ci,Uj)组成了负样本。</li><li>定义6：朋友特征向量<br>对于任意的用户，他的friend feature向量fi是一个x维向量，嵌入了他的朋友的特征，x是预先给定的参数。</li><li>定义7：朋友特征相似度<br>任何一个I(U^A_i,U^B_j)的相似度为两个用户在朋友特性上的相似性，表示为s(U^A_i,U^B_j).由于朋友特征被表示为friend feature vector，s(U^A_i,U^B_j)被测定为f^A_i和f^B_j</li></ul><h3 id="问题定义-1"><a href="#问题定义-1" class="headerlink" title="问题定义"></a>问题定义</h3><p>在现实世界中，每个人都有自己的朋友圈，这是高度个人化的。因此，如果我们知道一个人的所有朋友，我们可能知道他/她是谁。<br><img src="/images/问题定义.png" alt="avatar"><br>假设人们在现实世界中是随机建立友谊，任何两个人之间建立友谊的概率是P(0~1)。s_a和s_b分别是友谊存在于SN^A和SN^B中的概率。因此，在SN^A和SN^B中存在友谊的概率是Pxs_a和Pxs_b，将一段友谊在SN^A和SN^B中都存在的概率定义为Pxs_axs_b。随后，当U^A_i=U^B_j时，U^A_i和U^B_j共享|U|xPxs_axs_b个朋友，或者|U|xPxs_axs_b，|U|就是社交网络中的用户数量。显然，在U^A_i=U^B_j和U^_I!=U^B_j之间，共享好友的差异是1/p倍。这为纯粹使用网络结构的跨平台用户识别奠定了基础。<br>跨平台用户识别问题是判断U^A_i和U^B_j在两个不同额度社交网络AB之间是否为同一个用户，它被定义为<br><img src="/images/周会1问题定义是否为同一用户.png" alt="avatar"></p><p>这里面的P是先验知识，或者额外的信息，除了SN^A和SN^B外预先给定的。比方说，P就是FRUI的种子用户。当没有其他可用的额外信息时，P=φ。在这个场景中，只有朋友关系可以被利用，并且(2)变成<br><img src="/images/周会1公式2.png" alt="avatar"><br>显然，f(.)是我们在本研究中寻求的功能。由于各种原因，有些人在同一个SN中存在着多个账户，但我们通常认为这些多个账户是独立的，属于不同的个人。换句话说，我们只确定了其中一个账户。(这里不太赞同和理解<em>*</em>)</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>这一章里面作者主要从基于概要、基于内容和基于网络结构三个方面综述了跨平台用户识别的研究现状，并对网络嵌入进行了简要总结。</p><h3 id="profile-based-user-identification"><a href="#profile-based-user-identification" class="headerlink" title="profile-based user identification"></a>profile-based user identification</h3><p>个人的profile界面上有公共个人资料：包括用户名、性别、生日、城市和个人资料形象。在几乎所有SNs中，用户名都是公共必须的配置文件特性。公共profile属性为用户标识提供了强大的信息，然而在大规模SNs中，有些属性是重复的，很容易被模拟出来。</p><h3 id="content-based-user-identification"><a href="#content-based-user-identification" class="headerlink" title="content-based user identification"></a>content-based user identification</h3><p>这个方法就是根据用户发布内容的时间和地点，以及内容的写作风格来识别用户。地理位置具有强大的用户识别功能，但是在社交网络中，这类信息很少，因为只有一小部分用户愿意发布自己的位置。</p><h3 id="network-structure-based-user-identification"><a href="#network-structure-based-user-identification" class="headerlink" title="network structure-based user identification"></a>network structure-based user identification</h3><h4 id="network-structure-based-user-identification-with-prior-knowledge"><a href="#network-structure-based-user-identification-with-prior-knowledge" class="headerlink" title="network structure-based user identification with prior knowledge"></a>network structure-based user identification with prior knowledge</h4><p>基于网络结构的先验知识可分为两类：监督模型和半监督模型。</p><h4 id="network-structure-based-user-identification-without-prior-knowledge"><a href="#network-structure-based-user-identification-without-prior-knowledge" class="headerlink" title="network structure-based user identification without prior knowledge"></a>network structure-based user identification without prior knowledge</h4><p>这里作者首先简要介绍了NM的工作。<br>假设两个社交网络SNs都有n个用户，SN^A和SN^B,NM首先定义了一个相似度s(U^A_i,U^B_j)。最开始，s^(0)(U^A_i,U^B_j)=1，NM会反复地更新相似度的数值。在第k次的迭代中，NM构造了一个完全二部图B^(K+1)_i,j=(F^A_i,F^B_j,F^A_ixF^B_j)，其中每一个边界(U^A’_i,U^B’_j)权重为s^(k)(U^A’_i,U^B’_j)。最终，NM找到B^(k+1)_i,j的最大权值匹配，定义为M^(k+1)_i,j，并且更新s(i,j)为：<br><img src="/images/周会1公式3.png" alt="avatar"><br>当s归一化收敛之后，NM返回的是B=(U^A,U^B,U^AxU^B)的最大加权匹配的top m映射，每次迭代的整体运行时间是O(n^2d^3_max)，其中d_max是用户好友数量的上限。SN多次被验证为无标度的网络，因此，d_max≈n并且SN中NM的时间复杂度为O(n^5)。虽然NM在去匿名化的任务中是有效的，但是时间复杂度很高，在两个SNs不保证重叠的情况下还没有得到验证。<br>图内核方法从两个图中找到相似的子图，并与用户识别任务相关。但是图核解决方案主要集中于计算子图的相似度。</p><p>本文中的FRUI-P与之前的研究的不同之处在于：</p><ul><li>1 FRUI需要先验知识，而FRUI-P和NM不需要。FRUI-P解决了获得匹配的相同用户的问题。在没有先验知识的情况下，单纯使用网络结构来衡量两个SNs中两个用户的相似度几乎是不可能的。NM通过一个相似度迭代过程来解决这个问题，而FRUI-P从网络结构中提取朋友特征向量来评估相似度。</li><li>2 NM适用于去匿名化的任务，而FRUI-P和FRUI侧重于不同SNs上的用户识别。虽然这三种算法都能在两个不同的网络中找到相同的用户，但NM实际上工作在相同你的SN上。</li><li>3 FRUI-P和FRUI可以在异构SNs上运行，朋友关系是稳定的，可靠的和一致的SNs。FRUI和FRUI-p都将不同SNs中的连接转换为好友关系，并通过好友关系识别相同的用户。</li><li>4 FRUI-P比NM更高效。我们证明了FRUI-P的运行时间复杂度为O(n^2)，而NM的成本为O(n^5)。显然，FRUI-P在用户识别任务中的成本要低得多。</li><li>5 FRUI-P可以很容易地以并行的方式实现，而NM不能。</li><li>6 FRUI-P在内存空间中运行O(xn)，而NM需要O(n^2)，其中x是一个小整数，表示友元特征向量的维数。因此，FRUI-P可以应用于更大的SNs。</li></ul><h3 id="network-embedding"><a href="#network-embedding" class="headerlink" title="network embedding"></a>network embedding</h3><p>网络嵌入的目的是学习网络中定点的潜在表示。</p><h2 id="user-identification-without-prior-knowledge"><a href="#user-identification-without-prior-knowledge" class="headerlink" title="user identification without prior knowledge"></a>user identification without prior knowledge</h2><p>通常，当两个给定用户的相似性大于某个阈值时，这两个用户是相同的。因此跨平台用户识别的关键在于找到在两个给定网络中的任意在I(.,.)中的item。给定足够的相同用户作为先验知识，可以使用许多解决方案来定义和评估候选相同用户的相似性。但是，在没有先验知识的情况，评价任意两个用户的相似度任然是一项具有挑战性的任务。为了解决社交网络去匿名化领域的这个问题，NM通过迭代过程预计了所有I(.,.)中的item的相似性。在一定程度上，NM只是利用了用户网络的一种特性。从直观上看，NM的表现可以通过施加多维特征加以提高。<br>对于现实世界中的任意个体i，如果他的朋友关系特征可以被提取并嵌入到向量f_i中，那么他在SN^A和SN^B中的朋友特征向量f^A_i和f^B_j一定是相似的，因为个人在不同的SNs中部署了相似的朋友关系。以图2为例，由于个人1在SN^A和SN^B中有相似的朋友，如果我们将个人1以及他在SN^A中的账户U^A_a和在SN^B中的账户U^B_a’转换为二维向量，他们必须在几何上紧密地定位，也就是说在二维空间上f^A_a和f^B_a’几乎在同一个点上。<br>基于非监督好友关系的用户识别算法的关键技术可以分为两类：用户好友特征向量模型(FFVM)和基于特征向量的用户识别模型。</p><h3 id="朋友特征向量模型"><a href="#朋友特征向量模型" class="headerlink" title="朋友特征向量模型"></a>朋友特征向量模型</h3><p>维数的限制和嵌入特征的无用使传统的相邻顶点无法方便的识别问题，因此，主要的任务是指定朋友特征向量。深度学习允许由多个处理层组成的计算模型学习具有多个抽象层的数据表示，其有效性已在多个领域得到验证。我们还使用深度学习的力量来抽象朋友特征向量。我们的算法采用了随机游走，并且是在word2vec上的方法之上。如图所示，FFVM由正样本模型和朋友特征向量学习模型两部分组成。</p><h4 id="4-1-1-Positive-Sample-Model"><a href="#4-1-1-Positive-Sample-Model" class="headerlink" title="4.1.1  Positive Sample Model"></a>4.1.1  Positive Sample Model</h4><p>正样本模型的目的是生成给定SN地正样本集合S。由于Ci对Ui的预测概率较高，因此可以从Ci中提取出Ui的特征。随机漫步的威力已经在多个领域得到验证，在本研究中，我们使用简单随机游走(SRW)来构建正样本模型。因为启动结点上存在重启(RWR)偏差，节点上存在较大程度的Metropolis-Hasting随机游走(MHRW)偏差。<br>在随机漫步的开始，一个随机用户U_i1被选择为根据用户并设置为当前用户。然后遍历一个随机的用户Ui2∈Fi1并将其设置为当前用户。按照这个程序，随机漫步(Ui1,Ui2,…)当l&gt;0个用户被覆盖。由于朋友有更多的能力来预测一个用户，而那些建立在另一个用户之上的潜在联系在会引入噪音，所以在这项研究中只有朋友被考虑。随后，给定一个随机游走(…,U_ik-1,U_ik,U_ik+1,…)，C_ik={U_ik-1,Uik+1}。显然，每个随机游走可以生成两个正样本。最后，用近似|S|/l个随机游走过程产生S。显然，S应该足够大以确保能够正确提取给定SN中每个用户的好友特征。值得注意的是，在随机漫步中允许重复的用户，因此这些有声望的用户将在随机漫步中出现多次。<br>以图1b为例，(U^A_a,U^A_c,U^A_b,U^A_d,U^A_b)是一个随机游走的结果。对于一个用户U^A_c，我们有C^A_c={U^A_a,U^A_b}和NAc包含于{U^A_a,U^A_b,U^A_d,U^A_e}。因此，(C^A_c,U^A_c)是一个positive的样本，但(C^A_a,U^A_b)是一个negative的样本。正样本模型为朋友特征向量学习模型奠定了基础。<br><img src="/images/周会1图3.png" alt="avatar"></p><h4 id="4-1-2-friend-feature-vector-learning-model"><a href="#4-1-2-friend-feature-vector-learning-model" class="headerlink" title="4.1.2 friend feature vector learning model"></a>4.1.2 friend feature vector learning model</h4><p>朋友特征向量学习模型学习给定SN中的任意U_i的f_i(用户特征)。在本研究中，我们在NLP中使用了基于负采样的CBOW模型。在一开始，定义：<br><img src="/images/周会1公式4.png" alt="avatar"><br>其中，U_i和U_j是在给定SN中的两个用户。<br>这里使用极大似然法建立最有函数，对于给定的positive样本(C_i,U_i)，我们有：<br><img src="/images/周会1公式5.png" alt="avatar"><br>在本研究中，我们使用s行函数来定义p(U_j|C_i)<br><img src="/images/周会1公式6.png" alt="avatar"><br>我们有：<br><img src="/images/周会1公式7.png" alt="avatar"><br>其中q_j∈R^x是U_j的一个辅助参数，c^T代表c的转置，c_i∈R^x是f_j的求和U_j∈C_i<br><img src="/images/周会1公式8.png" alt="avatar"><br>公式7也可以被如下表示：<br><img src="/images/周会1公式9.png" alt="avatar"><br>因此，(5)转换为:<br><img src="/images/周会1公式10.png" alt="avatar"><br>显然的是，σ(c^T_i<em>q_i)表示C_i正确预测U_i的概率，而σ(c^T_i</em>q_j)，U_J∈N_i表示C_i正确预测用户U_j的概率。因此，对于任意的C_i，我们都希望最大化，σ(c^T_i<em>q_i)并且最小化σ(c^T_i</em>q_j)。因此，tuidao推导出最优函数(10)<br>同样，给定S，极大似然函数，即全局的最优函数如下：<br><img src="/images/周会1公式11.png" alt="avatar"><br>为了降低计算复杂度，我们通过去对数来转换(11)，因此我们有：<br><img src="/images/周会1公式12.png" alt="avatar"><br>优化目标采用异步随机梯度算法。令：<br><img src="/images/周会1公式13.png" alt="avatar"><br>使用：<br><img src="/images/周会1公式14.png" alt="avatar"><br>并且：<br><img src="/images/周会1公式15.png" alt="avatar"><br>我们有：<br><img src="/images/周会1公式16.png" alt="avatar"><br>因此，q_j的更新方程是：<br><img src="/images/周会1公式17.png" alt="avatar"><br>其中ε是学习率。更高的ε可以是q_j收敛更快，但是效率更低。类似的，根据q_j和c_i的对称性，我们有：<br><img src="/images/周会1公式18.png" alt="avatar"><br>由于c_i是f_v,U_v∈C_i的求和，c_i的梯度可以直接提供f_v的更新。随后，更新f_v的等式为：<br><img src="/images/周会1公式19.png" alt="avatar"><br>不幸的是，发现(19)在计算上是昂贵的。因为(19)需要对在N_i所有的用户集合求和，近似等于U。为了解决这一问题，我们采用噪声对比估计(NCE)方法，根据每个用户Ui的某些噪声，对多个negative情况进行抽样。这个过程也被称为负采样(NEG)，冰杯证明是有掉的学习高质量向量表示。具体来说，N_i被NEG(U_i)如下：<br><img src="/images/周会1公式20.png" alt="avatar"><br>其中,{.}^h表示{.}的数量，h是每个数据集的negative样本。任务是使用逻辑回归从噪声分布P_n(v)中区分目标用户U_i的样本。我们令P_n(v)∝d^(3/4)_v，如文献54中提出来的，其中n=|U|表示SN中的所有用户，并且d_v是F_v的小。因此，每个用户的目标函数可以转换为：<br><img src="/images/周会1公式21.png" alt="avatar"><br>第一项模型观察用户，而第二项反映负样本从噪声分布。随后，(19)变成:<br><img src="/images/周会1公式22.png" alt="avatar"><br>算法1总结了FFVM的整个过程。第二行生成所有用户的负样本，第三行为每个用户初始化随机值f_i和q_i，第四行生成整样本S。第5-14行迭代每个正样本并更新f_i和q_i，第15行返回所有用户的好友特征。<br><img src="/images/周会1算法1.png" alt="avatar"></p><h4 id="4-2-基于朋友特征向量的用户识别"><a href="#4-2-基于朋友特征向量的用户识别" class="headerlink" title="4.2 基于朋友特征向量的用户识别"></a>4.2 基于朋友特征向量的用户识别</h4><p>基于两个已知社交网络中的每个用户的好友特征向量，可以利用多个指标来评估所有的在I(.,.)中所有items的相似度，比如说欧几里德距离，切比雪夫距离，余弦。在这里，我们认为相同用户的朋友特征向量比非相同用户的朋友特征向量更接近。因此我们使用欧几里得距离来评价在I(.,.)中items的相似性。为了归一化相似度，我们有：<br><img src="/images/周会1公式23.png" alt="avatar"><br>用户识别问题通常转化为二部匹配问题。不同于完美匹配问题或完全匹配问题，用户识别寻求一种稳定的匹配。因为我们只考虑一个人在一个SN中拥有一个账户的情况，并且相同的用户比其他用户拥有最相似的朋友特征向量。因此，如果U^A_i=U^A_j，那么s(U^A_i,U^B_j)相较于s(U^A_i,.)和s(.,U^B_j)是不会更少的。因此，无需先验知识的用户识别函数可求解为<br><img src="/images/周会1公式24.png" alt="avatar"><br>其中max{.}返回的是{.}的最大值，并且s(U^A_i)返回的是在I(U^A_i,.)中所有的items的相似度。H(y)是Heaviside阶跃函数，定义如下:<br><img src="/images/周会1公式25.png" alt="avatar"><br>显然，没有先验知识的用户识别是一项具有挑战性的攻击任务。在某些场景中，一轮特性学习过程可能不足以确保性能。用f^(t1)表一个用户的t1个朋友特征向量，(23)可以被概括为：<br><img src="/images/周会1公式26.png" alt="avatar"><br>其中,1&lt;=t1,t2&lt;=t。为了降低运行时间的复杂性，我们简化(24)为：<br><img src="/images/周会1公式27.png" alt="avatar"><br>每个SN对应t个特征矩阵，t^2次用户识别，由t^2对特征矩阵组合得到的结果被执行。对于每一对，只有那些在I(.,.)中的items满足f(.,.)=1的被保留。注意到相同的用户出现了好几次，我们总结了它们的相似之处。最后，定义相似度为<br><img src="/images/周会1公式28.png" alt="avatar"><br>此外，(24)用于确保一对一的映射。<br>可想而知，只有几个朋友的用户的朋友特性是很难了解的。它实际上是直观的，因为这些用户的有限上下文可以表述出来。随后，为了提高精度，相似性和朋友的大小都应该考虑。此处，我们对每个在I中的item更新s(.,.)<br>这里min{.}返回{.}的最小值。只有在I(.,.)中的items满足s(.,.) λ&gt;=0才被认为是同一个用户。随后，我们有：<br><img src="/images/周会1公式30.png" alt="avatar"><br>算法2给出了FRUI-P。第2行启动参数。第3行和第4行学习每个节点的好友特征向量。第5-9行更新所有节点对的相似性。第10行确保了一一映射，并返回相似度大于λ的相同用户。<br><img src="/images/周会1算法2.png" alt="avatar"></p><h3 id="4-3-讨论"><a href="#4-3-讨论" class="headerlink" title="4.3 讨论"></a>4.3 讨论</h3><ul><li>引理1：FFVM的时间复杂度是O(|U|)+O(|S|xx^2)，其中|U|,|S|和x分别为SN中的用户数、正样本数和朋友特征向量的维数。</li><li>证明：negative采样的产生是O(|U|)。由于|S|positive采样要求大约|S|随机选择结点或者其临近结点，随机游走过程的时间复杂度为O(|S|)。在FFVM中的8-14行是对于每个(C_i,U_i)的过程，并且时间复杂度是O(|NEG_i|x x^2)，其中|NEG_i|表示在NEG_i中用户的个数。因此，FFVM的总的复杂度是O(|U|)+O(|S|)+O(|S|x|NEG_i|xx^2)=O(|U|)+O(|S|xx^2)，因为|NEG_i|是一个小整型数。<br>虽然FFVM也从朋友关系中学习用户的潜在朋友表示，但它与目前的网络嵌入解决方案不同。我们以DeepWalk[47]作为比较，因为它的进程类似于FFVM。首先，在建模S时只考虑朋友，因为建立在另一个用户之上的底层连接会在识别用户时引入噪声[28]。然而，为了模拟全局网络特征，DeepWalk包含了大量未连接的用户。第二，FFVM中使用了CBOW, DeepWalk中使用了SkipGram[39]。最后，为了加快训练时间，FFVM使用了负采样，而DeepWalk使用了层层化的Softmax。</li><li>定理1：FRUI-P的总的时间复杂度是O(t<em>max{|S^A|,|S^B|}</em>x^2)+O(t^2<em>max{|U^A|,|U^B|}^2)，其中t,|U^A|,|U^B|,|S^A|,|S^B|和x分别为好友特征学习的次数、sna和SNB中的用户数量、sna和SNB的正样本数量、好友特征向量的维数。t轮朋友特征向量学习的时间复杂度为<br><a href="/images/周会1t轮.png">avatar</a><br>FRUI-P中的第7-8行计算I(.,.)中每个items中的相似度并且f(.,.)=1和在时间复杂度的花费O(|U^A||U^B|)。因此，行5-8的时间复杂度是O(t^2</em>|U^A||U^B|)。由于行9的花费不大于O(|U^A||U^B|)，FRUI-P的总的时间复杂度是O(t<em>max{|U^A|,|U^B|})+O(t</em>max{|S^A|,|S^B|}<em>x^2)+O(t^2</em>|U^A||U^B|)+O(|U^A||U^B|)=O(t<em>max{|S^A|,|S^B|}</em>x^2)+O(t^2*max{|U^A|,|U^B|}^2)<br>显然，较大的t会增加FRUIP的复杂度，但也保证了FRUI-P的查全率和查准率。更多的正样本确保充分学习朋友特征向量，更大的x意味着考虑更多维度的特征。增加S或x会提高FRUI-P的复杂性，但可以提高用户识别的性能。我们的实证研究也证实了t、S和x可以提高FRUI-P的绩效。λ保证识别用户的最小相似度，并确保精度。既然相同用户的相似度小于λ错过了,高λ结果找回率较低。当λ=0，所有识别出的用户均视为相同用户。<br>由于在实际中|S|&gt;=|F|，并且|S|&lt;=|U|^2，我们大约设O(|S|)=O(|U|^2)。因此，FRUI-P的时间复杂度可简化为<br><a href="/images/周会1FRUI-P时间复杂度.png">avatar</a><br>注意到FFVM中的f_i和q_i的更新没有获取一个锁来访问共享参数。这允许我们在多工作器的情况下是使用一部随机梯度算法，并帮助实现最优的手链策略。而且，(26)和(27)可以以并行的方式工作。因此，FRUI-P的并行版本易于实现，从而使FRUI-P具有可伸缩性。</li></ul><h2 id="实验研究"><a href="#实验研究" class="headerlink" title="实验研究"></a>实验研究</h2><p>我们在合成和地面真实网络中验证了FRUI-P。所有实验均使用8G内存和2.8 GHz CPU的计算机进行。</p><p>我们使用NM作为主要基线，因为它是最接近FRUI-P的一种先进的、基于网络结构的非监督算法，该算法在WSDM 2013数据挑战[38]的去匿名任务中获得了一等奖。在我们的NM经验测试中，图的大小不超过1000个节点。由于NM的运行时间和空间要求，分别是O(n^5)和O(n^2)，限制了NM的可扩展性。例如，一对有50,000个节点的图，NM要求不少于50000x50000x4Bx2(NM使用kth和(k+1)th相似度矩阵)=20G内存，超过了设备的能力。<br>FRUI是本研究的另一个对手，因为它是纯使用网络结构的最先进的半监督用户识别技术。<br>我们采用召回率、准确率和F1-measure来衡量性能。它们被定义为<br><img src="/images/周会1公式31.png" alt="avatar"><br>更高的查全率、精度和F1-measure表明用户识别方案的性能更好。<br>除了真实世界的实验，我们还在合成网络上进行了大量的实验来评估FRUI-P的性能。SNs在用户(节点)和好友(边缘)[28]中自然是重叠的。节点重叠是所有用户识别方案的基本假设，而边缘重叠是所有基于网络结构的算法的基础。为了实现不同程度的节点和边缘重叠，我们添加了不同程度的噪声图。对于给定的网络，通过保持每个节点/边具有一定的抽样概率来生成子网。经过两轮采样过程，产生一对子网，两个子网中保持的共同节点是相同的。图4给出了图解。我们引入了Jaccard系数来度量节点/边重叠的程度，<br><img src="/images/周会1公式32.png" alt="avatar"><br>其中，overlap(.,.)表示X的重叠程度，X表示两个图的U/F。因此，当两个图每一个都共享2/3的结点，overlap(U^A,U^B)=0.5,边缘重叠程度受重叠节点之间关系的限制。</p><h3 id="5-1-合成网络实验"><a href="#5-1-合成网络实验" class="headerlink" title="5.1 合成网络实验"></a>5.1 合成网络实验</h3><p>为了验证FRUI-P的性能，我们在ER[40]随机网络、WS[41]小世界网络和BA[42]网络中进行了实验。三种合成网络的性质参照了我们之前的研究[28]。ER和WS网络都是由规则随机网络以一定的概率重新布线每条边而产生的。如果所有的边都重新布线，使得重新布线的概率等于1，那么这个网络就是一个ER网络;否则为WS网络。在实验中，WS网络中重接线的概率为0.5。</p><p>我们在实验中生成了75对网络来说明FRUI-P在合成网络中的性能。在这三个合成网络实验中，总共创建了5个5000个节点的网络。在5个ER和WS网络实验中，两个节点之间存在一条边的概率p分别为0.02、0.04、0.06、0.08和0.1。同样，在BA网络实验中，连接一个新节点到现有节点的边数m从20增加到100，增加了20。随后，由15个合成网络产生75对网络，overlap(U^A,U^B)=1并且overlap(F^A,F^B)等于0.25,0.36,0.49,0.64和0.81.我们在所有实验中设置t=1,λ=0，|S|=50|F|并且x=500。值得注意的是，在我们的实验中，所有的边缘都是随机采样的，这可以更准确地模拟现实世界的SNs。这种随机抽样也描述了跨平台用户识别任务和去匿名任务之间的差异，这两个SNs在一堆节点上完全重叠。<br>ER网络实证检验结果如表2所示。<br><img src="/images/周会1表格2.png" alt="avatar"><br>随着两种SNs边缘重叠程度的增加，FRUI-P的性能有所提高。同样值得注意的是，FRUI-P识别几乎所有相同的结点当overlap(F^A,F^B)&gt;=0.49.此外，所有25对网络的精度均大于90%。FRUI-P在WS网络中的性能如表3所示。与在ER网络中的实验类似，FRUI-P识别不少于90%的所有相同用户当overlap(F^A,F^B)&gt;=0.36，所有25对网络的准确率都大于96.3%。结果表明，FRUI-P在WS网络中的性能要优于ER网络。表4的结果显示，FRUI-P在BA网络中也表现良好。<br><img src="/images/周会1表格3.png" alt="avatar"><br>虽然在BA网络中，FRUI-P的性能不如在ER和SW网络中，但在同一时间内，其精度均大于91.5%当overlap(F^A,F^B)&gt;=0.49.此外，当m&gt;=40时，几乎所有被识别的用户都是正确的。并且几乎所有相同的用户在overlap(F^A,F^B)&gt;=0.64时均被识别。毫无疑问，通过增加x、t和|S|，可以进一步提高FRUI-P在BA网络中的性能,如第5.2节所验证。在所有ER、WS和BA网络上的实验中，FRUI-P发现了几乎所有相同的节点当overlap(F^A,F^B)&gt;=0.64，这与现实世界的社交网络大致相同。这表明FRUI-P可以在没有种子用户的情况下处理用户标识任务。同时，精度几乎为1当overlap(F^A,F^B)&gt;=0.49，这验证了FRUI-P可以用于为其他一些用户识别算法生成先验知识，例如FRUI<br><img src="/images/周会1表格4.png" alt="avatar"></p><p>我们还对FRUI- p、FRUI和NM的有效性进行了实验比较。三种合成网络中FRUI- p、FRUI和NM的比较如图5所示。我们改变overlap(F^A,F^B)的值从0.25-1在实验之中。在ER和WS网络中p=0.02，并且在BA网络中m=20。我们使用具有5000个节点的图来评价FRUI- p、FRUI和NM。FRUI的先验知识为50。由于召回率、precision和F1-Measure在实验中呈现相同的趋势，只有召回率被证明。ER模型和WS模型生成的网络实验结果如图5a和5b所示。显然，在ER和WS网络中FRUI- p和FRUI识别出几乎所有相同的节点当overlap(F^A,F^B)&gt;=0.36时。三种算法在BA网络中的召回率如图5c所示。FRUI- p和FRUI都具有良好的性能，尤其是当overlap(F^A,F^B)&gt;=0.64。相比之下，当，NM识别所有相同的节点当overlap(F^A,F^B)几乎是1，如果没有什么区别的话，当overlap(F^A,F^B)&lt;=0.81,在这三个合成网络中。这意味着当两个图被随机抽样时，NM执行不充分。因此，当两个SNs重叠在65%左右时，我们可以采取NM不能应用于跨平台用户识别任务的态度。<br><img src="/images/周会1图5.png" alt="avatar"><br>此外，还比较了FRUI- p和FRUI之间的微妙差别，在三种合成网络中均具有overlap(F^A,F^B)=0.25，如图6所示。我们比较了50个和100个匹配的相同用户作为先验知识的FRUI- p和FRUI。显著的是，在WS和BA网络中，当预先给出一小部分相同用户时，FRUI- p的性能优于FRUI。<br><img src="/images/周会1图6.png" alt="avatar"></p><h3 id="5-2-参数的影响"><a href="#5-2-参数的影响" class="headerlink" title="5.2 参数的影响"></a>5.2 参数的影响</h3><p>x、|S|和t三个参数可以提高FRUI-P的性能，而λ被引入来保证FRUI-P的高精度。本节将验证四个参数的效果。不规范,overlap(F^A,F^B)=0.64.x=500,|S|=50|F|,t=1,λ=0在这个部分。<br>作为对三种合成网络的实证检验，FRUI-P几乎识别出了ER和WS网络中所有相同的节点。因此，我们只在BA网络上进行了进一步的实验，以显示这些参数对FRUI-P的影响。<br>由于增大|S|可以为朋友特征学习提供更多的正样本，我们通过10jFj的步长将|S|从30|F|变化到70|F|来观察正样本数对FRUI-P的影响。图7a和7b的结果显示，阳性样本越多，可以保证更多的相同用户，精度越高。我们还将x从100变化到900，以200步来评估x对FRUIP的影响。如图7c和7d所示，x越大，查全率越高，查准率也越高。<br><img src="/images/周会1图7.png" alt="avatar"><br>在overlap(F^A,F^B)=0.49时的实验结果如图8a所示，召回率随着t的增加而增加。换句话说，t越高，用户越相同，无论网络是多么稀疏还是稠密。图8b显示的结果显示了m = 60时t的影响。无论这两个SNs之间有多少重叠，高t也能保证更多相同的用户。<br>当m=60并且overlap(F^A,F^B)=0.36时的实验结果如图8c和图8d所示。图8c给出了精度与λ之间的关系。显然，精确度随着λ的增加而增加，当λ=1时，几乎所有的用户都被识别出来。我们还提出了精度和召回率之间的权衡以及λ在图8 d。说明准确率的提高可能会导致召回率的下降。值得注意的是，即使在特殊情况下，FRUI-P也能以不低于95%的精度识别20%的相同用户。这证明了FRUI- p有能力为其他解决方案(例如FRUI)提供先验知识。<br><img src="/images/周会1图8.png" alt="avatar"></p><h3 id="5-3-社交网络实验"><a href="#5-3-社交网络实验" class="headerlink" title="5.3 社交网络实验"></a>5.3 社交网络实验</h3><p>在本节中，我们使用地面真实数据集来评估用户识别分辨率。为了验证不同类型的社交网络，我们从新浪微博和人人网这两个异构的社交网络中收集数据。新浪微博拥有117万用户和190万好友关系，人人网拥有550万用户和1460万好友关系。更多数据集的细节可以在我们之前的研究[24]中找到。为了评估真实数据集的FRUI-P性能，我们生成了一系列受控数据集。我们从这两个SNs中选择了一对子图，每个子图都有超过50,000个节点。<br>在这个实验之中，我们随机选择了一些共享节点作为先验相等的FRUI用户，并且对于FRUI-P t=1，λ=0，x=500并且|S|=50|F|。然后，我们在FRUI- p和FRUI中执行用户标识。我们将所有相同用户中先验相同用户的百分比从0.01增加到0.1，增加的步长是0.01。由于新浪微博和人人网的平均度都比较低，所以只选择邻居不小于u的节点作为重叠节点。为了验证FRUI-P的表现，我们把u从20增加到100，每次增加20。虽然只选择好友在你以上的用户，但抽样后，度分布也遵循幂律分布。也就是说，在抽样的社交网络中，有很多(如果不是大多数)好友数低于5的用户，这些用户很难识别。<br>图9比较了新浪和人人网络中FRUI- p和FRUI的召回率。在FRUI中，1%和8%的相同用户是先验知识。尽管FRUI显示了更好的性能，但FRUI- p也能够识别所有相同用户的20%左右，而无需事先知道这些相同用户。此外，在θ=20的SNS中，FRUI- p比FRUI发现更多的相同用户，而在FRUI中只有1%的先验知识。在真实社交网络中，FRUI-P的表现并不像在合成网络中那样令人满意，因为在这些真实社交网络中，几乎有一半的用户只有一个朋友，而这些朋友的特征几乎不可能从他们的朋友那里了解到。<br><img src="/images/周会1图9.png" alt="avatar"><br>我们还考察了在FRUI-P中的朋友数量和λ该方法适用于解释FRUI-P在现实SNs中的性能。在u = 100的SNs中，精确好友数的趋势如图10a所示。显然，FRUI-P的精度随着朋友数的增加而增加。同时，对于好友数在60以上的用户，其识别精度在80%以上，表明FRUI-P识别好友数较多的用户具有较高的识别精度，验证了好友数较少的用户的好友特征很难学到。此外，当用户在新浪有超过120个好友，在人人网有超过250个好友时，几乎所有的用户都是相同的。精度随λ的变化趋势如图10b所示。与合成网络实验相似，λ越高，识别结果的精度就越高，并且精度达到0.9当λ=0.4同时在sina和人人网上。准确率和召回率之间的权衡如图10c所示。很明显，在新浪和人人网，FRUI-P以95%的精确度回报了15%以上的相同用户。如之前[21]的研究所示，只有一小部分的先验知识，例如1%，可以帮助识别新浪数据集中40%以上的相同用户和人人数据集中60%以上的相同用户。因此，FRUI- p可以是FRUI的强大补充，因此FRUI- p可以用于为那些需要先验知识的算法提供先验知识。<br><img src="/images/周会1图10.png" alt="avatar"><br>我们还通过三组实验评估了FRUI-P在新浪微博和人人网用户识别中的性能。在每个实验中，我们从中国人民大学(RUC)的相同用户出发，选择一对子图，采用广度优先搜索提取两层朋友。删除叶节点，只留下具有RUC教育背景的用户。由于相同用户的确切数量是未知的，所以只比较精度。当λ=0时，FRUI-P返回的相同用户几乎和NM一样多。这里我们选择了300个相似度最高的用户来检测FRUI-P和NM的精度，实证结果见表5，在三个实验中，FRUI-P的精度都在80%左右，优于NM。这些发现表明，FRUI-P在识别新浪微博和人人网上的相同用户方面更为熟练。<br>最后，我们联合使用FRUI- p和FRUI进行了实验。选取FRUI- p相似度最高的150个用户作为FRUI的先验知识。我们随机选择300名识别用户检查准确性。实证结果表明，通过联合使用FRUI- p和FRUI，约有一半的被识别用户是相同的。所识别的用户总数和精度如表5所示。结果表明，FRUI-P可用于监督或半监督方案的先验知识获取。<br><img src="/images/周会1表5.png" alt="avatar"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本研究解决了跨SN平台的用户身份识别问题，提供了一种创新的解决方案。网络结构作为网络序列号的一个关键方面，对解决用户识别问题至关重要。许多研究报告称，相同的用户在不同的SN平台上有相似的朋友。因此，我们提出了一种基于统一网络结构的用户识别解决方案。基于我们之前的研究[28]，我们开发了一个新的无监督的基于朋友关系的算法称为FRUI-P。我们还讨论了其复杂性和可伸缩性。最后，我们在合成网络和ground-truth网络中验证了我们的算法。<br>实验结果表明，该网络结构能够完成重要的用户识别任务。我们的FRUI-P算法效率高，性能比NM算法好得多。在原始文本数据稀疏、不完整或由于隐私设置而难以获取的情况下，FRUIP非常适合跨平台任务。此外，FRUI- p可以为许多基于先验知识的用户识别方案(如FRUI)提供可靠的先验知识。由于FRUI-P的并行版本易于实现，所以我们的方法是可伸缩的，可以很容易地应用于大型数据集。为了提高效率，我们将在未来的工作中探讨对另一个图上的每个节点缩小候选相同节点的预处理过程。显然，没有先验知识的匿名相同用户识别方法适用于难以获得种子用户的更多场景，因此在很大程度上增强了适用性。<br>跨多个SNs识别匿名用户是一项具有挑战性的工作。因此，只能使用此方法识别具有不同别名的部分相同用户。本研究为进一步研究这一问题奠定了基础。最终，我们希望能够开发出一种最终的方法，以在理想情况下识别所有具有不同昵称的相同用户。其他用户识别方法可以同时用于检测多个SN平台。这些方法是互补的，而不是相互排斥的，因为最终的决策可能依赖于人类用户的参与。因此，我们建议协同应用这些方法，并适当利用其优势，应导致有利于其共同目标的最佳效果</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Structure-Based-User-Identification-across-Social-Networks&quot;&gt;&lt;a href=&quot;#Structure-Based-User-Identification-across-Social-Networks&quot; class=&quot;headerlink&quot; title=&quot;Structure Based User Identification across Social Networks&quot;&gt;&lt;/a&gt;Structure Based User Identification across Social Networks&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="周会论文讲解" scheme="http://yoursite.com/tags/%E5%91%A8%E4%BC%9A%E8%AE%BA%E6%96%87%E8%AE%B2%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>User Bheavior Learning and Transfer in Composite Social Networks</title>
    <link href="http://yoursite.com/2021/05/21/User-Bheavior-Learning-and-Transfer-in-Composite-Social-Networks/"/>
    <id>http://yoursite.com/2021/05/21/User-Bheavior-Learning-and-Transfer-in-Composite-Social-Networks/</id>
    <published>2021-05-21T14:10:30.000Z</published>
    <updated>2021-05-21T06:10:32.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
